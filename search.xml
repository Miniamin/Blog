<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【转】向恐龙解释现代JavaScript]]></title>
    <url>%2F2018%2F10%2F24%2F%E3%80%90%E8%BD%AC%E3%80%91%E5%90%91%E6%81%90%E9%BE%99%E8%A7%A3%E9%87%8A%E7%8E%B0%E4%BB%A3JavaScript%2F</url>
    <content type="text"><![CDATA[本文的目的是提供JavaScript工具是如何一步步发展到今天(2017年)的一个历史背景。我们将从零开始，构建一个不借助任何工具，只需要简单的HTML和JavaScript的示例网站。接着我们将依次引入不同的工具，并解释它解决了什么样的问题。有了这种历史背景，你将能更好地学习和适应未来不断变化的JavaScript格局。让我们开始吧！ JavaScript的”老派”使用方式让我们从一个只使用HTML和JavaScript的“老派(old-school)”网站开始，它需要我们手动地下载和链接文件。这里是一个简单的’index.html 文件，并链接了一个 JavaScript 文件： 123456789101112&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;JavaScript Example&lt;/title&gt; &lt;script src="index.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello from HTML!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 其中 &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt; 这一行引用了一个与 index.html 在同一目录下名为 index.js 的 JavaScript 文件。 12// index.jsconsole.log("Hello from JavaScript!"); 这就是你制作一个网站所需的一切。现在，假设我们想要添加一个第三方的库，如 moment.js (一个可以将日期格式化为人类可读方式的库)。如下所示，你可以在JavaScript使用 moment 提供的功能： 1moment().startOf('day').fromNow(); // 20 hours ago 但是这需要你在你的网站中加入 mement.js。在 moment.js 主页，你会看到以下说明： 我们暂时先忽略右边的 Install 部分的内容。我们可以通过手动下载 moment.min.js，并将其放到index.html所在的文件夹中，最后在index.html中引用moment.min.js的方式来给我们的网站添加moment.js功能，如下所示： 1234567891011121314&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Example&lt;/title&gt; &lt;link rel="stylesheet" href="index.css"&gt; &lt;script src="moment.min.js"&gt;&lt;/script&gt; &lt;script src="index.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello from HTML!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 注意，moment.min.js在index.js加载之前被加载，这意味着我们可以在index.js中使用moment的功能，如下所示： 123// index.jsconsole.log("Hello from JavaScript!");console.log(moment().startOf('day').fromNow()); 这就是以前我们使用JavaScript库制作网站的方式，它的好处是很容易理解；而坏的一面是，当JavaScript库更新时，我们需要重新寻找并下载新版本的JavaScript库，这很烦人。 使用JavaScript包管理器(npm)大概从2010年开始，出现了几个相互之间具有竞争关系的包管理器，它们帮助开发者自动化地完成从中央存储库下载和升级第三方依赖包的过程。2013年前后，Bower 毫无疑问是最受欢迎的包管理器，但最终在2015年左右，它被 npm 取代。(值得注意的是，从2016年年末开始，yarn 作为npm的替代品，已经获得了很大的吸引力，但yarn的背后依然使用npm。) 请注意，npm最初是专门为node.js制作的包管理器，node.js是一个旨在运行在服务器而非浏览器上的JavaScript运行时。所以使用npm作为一个前端包管理器来管理运行在浏览器上的库，是一个非常奇怪的选择。 注意：使用包管理器通常会涉及命令行的使用，而在过去，这是一个前端开发者从不需要掌握的技能。如果你从未使用过命令行，这里有一个很好的入门教程 。无论好与坏，知道如何使用命令行是当代JavaScript开发的一个重要组成部分(同时它也为你在其他领域下的开发打开了一扇大门)。 下面让我们来看看如何通过npm，而非手动下载的方式来安装moment.js。如果你已经安装了node.js，你也已经安装了npm，这意味着你可以在命令行中导航到index.html所在的文件夹下并输入如下命令： 1$ npm init 这将提示你几个问题(一般情况下选默认值即可)并创建一个名为package.json的新文件。package.json是一个配置文件，npm用它来存储一些与工程相关的信息。默认情况下，package.json中的内容应该是这样的： 1234567891011&#123; "name": "your-project-name", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "author": "", "license": "ISC"&#125; 要安装moment.js JavaScript库，我们可以按照moment.js主页上的指导，在命令行中输入如下命令： 1$ npm install moment --save 这句命令做了两件事，首先它将moment.js包中的所有代码下载到一个名node_modules的本地文件夹中。其次，它自动修改 package.json文件，并将moment.js作为工程的一项依赖记录下来。 1234567891011121314&#123; "name": "modern-javascript-example", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "author": "", "license": "ISC", "dependencies": &#123; "moment": "^2.19.1" &#125;&#125; 这在与他人共享工程时非常有用－－你只需要共享 package.json文件，而非整个 node_modules文件夹(它可能会变得非常大)，其他开发者可以通过 npm install命令来自动安装工程所需要的软件包。 所以，现在我们再也不用从网站上手动下载moment.js了，我们可以通过使用npm来自动下载并更新它。查看 node_modules文件夹，我们可以在 node_modules/moment/min文件夹下找到 moment.min.js文件，这意味着我们可以直接在index.html中链接通过npm下载下来的 moment.min.js： 12345678910111213&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;JavaScript Example&lt;/title&gt; &lt;script src="node_modules/moment/min/moment.min.js"&gt;&lt;/script&gt; &lt;script src="index.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello from HTML!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 此时，好的一面是，通过命令行，我们可以使用npm来下载和更新我们的依赖包；坏的一面是，我们需要深入到 node_modules文件夹内部来寻找每个依赖包的位置，并且需要手动将它们添加到HTML中。这非常麻烦，接下来我们将看看如何自动化地执行这一过程。 使用JavaScript模块打包工具(webpack)大部分编程语言都提供了将代码从一个文件加载(import)到另一个文件的方法。JavaScript最初被设计成只能在浏览器中运行，出于安全的考虑，它不能访问客户端计算机的文件系统，因此JavaScript不支持这一特性。在很长的一段时间内，我们需要通过全局共享变量的方式来加载组织在不同文件中的JavaScript代码。 在上述moment.js例子中，我们就是这么干的，整个 moment.min.js文件被加载到HTML中，该HTML定义了一个叫 moment的全局变量，然后在 moment.min.js之后加载的任何文件都可以使用这个变量(无论这个文件是否需要使用到这个变量)。 在2009年，一个名为CommonJS的项目启动，它的目的是定义一个在浏览器之外运行的JavaScript生态系统。CommonJS的一个重要组成部分就是它的模块规范，它最终允许JavaScript能像大多数编程语言一样可以跨跃文件导入和导出代码，而不需要借助全局共享变量。CommonJS模块规范最著名的应用就是node.js。 正如上文提到的，node.js 是一个运行在服务器上的JavaScript时。我们可以使用 node.js 的模块语法来改造前面的例子。此时，我们不需要使用HTML的script标签，就可以直接在JavaScript文件中加载 moment.min.js，代码如下： 1234// index.jsvar moment = require('moment');console.log("Hello from JavaScript!");console.log(moment().startOf('day').fromNow()); 这就是node.js加载模块的方式，它效果很好，因为node.js是一门可以访问计算机文件系统的服务器端语言。同时node.js也知道每个npm模块路径的位置，所以加载模块时，我们可以简单地写成 require(&#39;moment&#39;)，而不需要写 require(&#39;./node_modules/moment/min/moment.min.js&#39;)。 这一切在node.js上都能很好地运行，但当你尝试在浏览器中运行上述代码时，浏览器会报出一个 require未被定义的错误。加载文件必须以同步(会降低执行速度)或异步(可能有时间问题)的方式动态完成，而浏览器不能访问计算机的文件系统，这意味着以这种方式来加载模块会非常的棘手。 这时我们就需要使用到模块打包工具。JavaScript模块打包工具，通过添加一步叫做build(可以访问计算机文件系统)的操作，创建一个与浏览器兼容的最终输出(不需要访问文件系统)，来解决上述问题。在这种场景下，我们需要用模块打包工具来找到所有的 require (这是无效的浏览器JavaScript语法)语句，并将它们替换成每个需要引入的文件的实际内容。最终的输出结果是一个打包好的JavaScript文件(没有require语法)。 Browserify 在2011年发布后，即成为最受欢迎的模块打包器，它率先在前端引入了node.js样式的require语句(这也是使npm成为前端包管理器之一的原因)。在2015年左右，受React前端框架普及的推动，webpack 打败Browserify成为最受欢迎的模块打包器，React框架充分利用了webpack的各种特性。 让我们来看看如何通过webpack来使 require(&#39;moment&#39;)语句在浏览器中正常运行。首先，我们需要将webpack安装到工程中，webpack本身就是一个npm包，所以我们可以从命令行安装它： 1$ npm install webpack --save-dev 请注意 --save-dev参数，webpack将会被保存为开发依赖项，这意味着它是在开发环境而非生产环境所需要的软件包，你可以从 package.json中看出这一区别： 1234567891011121314151617&#123; "name": "modern-javascript-example", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "author": "", "license": "ISC", "dependencies": &#123; "moment": "^2.19.1" &#125;, "devDependencies": &#123; "webpack": "^3.7.1" &#125;&#125; 现在，我们将webpack软件包安装到了 node_modules目录下，你可以在通过下述命令来使用 webpack： 1$ ./node_modules/.bin/webpack index.js bundle.js 这句命令会运行安装在 node_modules文件夹下的webpack工具，它将从 index.js 文件开始，查找所有的 require 语句，并将它们替换为对应的代码，最后创建了名为 bundle.js 的单个输出文件。在浏览器中，我们不再使用包涵无效 require 语句的 index.js 文件了，相反，我们使用webpack输出的 bundle.js 文件，HTML文件的改动如下： 123456789101112&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;JavaScript Example&lt;/title&gt; &lt;script src="bundle.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello from HTML!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 此时刷新浏览器，你会看到一切都像以前一样正常工作。 注意，每次修改 index.js文件后，我们都需要运行上述webpack命令，这很枯燥。尤其当我们使用webpack的高级功能(例如生成源码映射以帮助我们从转译后的代码调试原始代码)时，它会变得更加枯燥乏味。webpack可以从工程的根目录下一个名为 webpack.config.js的文件中读取配置选项，在我们的例子中，webpack.config.js应该长这样： 1234567// webpack.config.jsmodule.exports = &#123; entry: './index.js', output: &#123; filename: 'bundle.js' &#125;&#125;; 现在每次修改 index.js文件后，我们只需要运行下述命令： 1$ ./node_modules/.bin/webpack 我们不需要再指定index.js和 bundle.js这两个选项了，因为webpack可以从 webpack.config.js 中读取这些选项。相比之前，这更简单一点，但每次修改代码后都需要输入这行命令依然很枯燥。接下来我们将会使这个过程变得更顺滑一点。 我们虽然没有做很大的改进，但这个工作流程却有一些巨大的优势。我们再也不用通过全局共享变量的方式来加载外部脚本了，任何新的JavaScript库都将通过JavaScript语言中的require语句来添加，而不是通过在HTML中添加新的&lt;script&gt;标签。相对加载多个JavaScript文件而言，加载单个打包好的JavaScript文件通常会有更好的性能表现。同时，既然我们已经在开发工作流程中添加了一个构建步骤，我们还可以添加一些其他的强大功能！ 转译代码以支持新的语言特性(babel)转译代码意味着将一种语言的代码转换为另一种语言的代码，这是前端开发的另外一个重要组成部分－－因为浏览器添加新功能的速度非常缓慢，而带有实验性功能的新语言可以被转译成浏览器兼容的语言。 对CSS来说，有Sass，Less和Stylus等。而对于JavaScript，曾经一段时间内最受欢迎的转换器是CoffeeScript(2010年左右发布)，而现在，大部分人都使用 babel 或 TypeScript。CoffeeScript是一门通过大量修改JavaScript语言来提升JavaScript能力的一门语言。Babel本身不是一门新的语言，但是它是一个将浏览器尚未全部兼容的下一代JavaScript(ES6及以上)转换为更兼容的JavaScript(ES5)的转换器。Typescript是一种与下一代JavaScript基本相同的语言，同时也增加了可选的静态类型。许多人选择使用babel，因为它最接近vanilla JavaScript。 下面让我们来看一个如何在现有的webpack构建过程中使用babel的例子。首先我们需要通过下面的命令将babel安装到我们的工程中： 1$ npm install babel-core babel-preset-env babel-loader --save-dev 请注意，我们在开发依赖中安装了三个独立的软件包babel-core 是babel的主要组成部分，babel-preset-env预定义了需要转换的JavaScript新特性，babel-loader是一个能使babel与webpack一起工作的软件包。我们通过修改 webpack.config.js来使用babel-loader： 123456789101112131415161718192021// webpack.config.jsmodule.exports = &#123; entry: './index.js', output: &#123; filename: 'bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\.js$/, exclude: /node_modules/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['env'] &#125; &#125; &#125; ] &#125;&#125;; 这个语法可能会让人感到困惑，不过幸运的是，我们不需要经常去改动它。它的基本工作原理是，告诉webpack去查找所有.js文件(包括 node_modules中的.js文件)，然后通过babel-loader与babel-preset-env来进行转换。你可以在这里看到webpack的更多配置语法。 现在一切都已搭建好，我们可以在JavaScript中使用ES2015的新特性了。以下是一个使用ES2015模版字符串的例子： 12345678// index.jsvar moment = require('moment');console.log("Hello from JavaScript!");console.log(moment().startOf('day').fromNow());var name = "Bob", time = "today";console.log(`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`); 我们还可以使用ES2015 的import语句来替代require语句加载模块的功能。今天，你可以在很多代码库发现这种写法。 12345678// index.jsimport moment from 'moment';console.log("Hello from JavaScript!");console.log(moment().startOf('day').fromNow());var name = "Bob", time = "today";console.log(`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`); 在这个例子中，import语法与require语法并没有多大的区别，但对于更高级的场景，import语法会更灵活。 因为修改了 index.js文件，我们需要再次运行这句命令： 1$ ./node_modules/.bin/webpack 刷新浏览器后你会看到期望的效果。在写这篇文章的时候，许多当代浏览器都已经支持了ES2015的特性，所以很难分辨出babel是否起了作用。你可以在IE9等旧版浏览器中进行测试，也可以在 bundle.js查找转换后的这行代码： 1234// bundle.js// ...console.log('Hello ' + name + ', how are you ' + time + '?');// ... 你可以看到，babel将ES2015的模版字符串转换成了常规的JavaScript字符串拼接，以此来保证浏览器的兼容性。尽管这个例子可能不太令人兴奋，但是能转译代码是一个非常强大的功能。它让我们现在就可以使用JavaScript即将要支持的新特性，如async/await等，来编写更好的代码。尽管转译过程有时候会很繁琐很痛苦，但它让我们能够在今天去测试将来的语言特性，这也使得JavaScript语言在过去几年里取得了显著的提升。 至此，我们差不多已经讲完了，但在我们的工作流中依然存在一些未完成的边界。如果我们关心性能，我们需要缩小(minifying)打包后的文件，因为我们有了构建这一步，缩小代码也变得非常简单。每次修改JavaScript后，我们都需要重新运行webpack命令，接下来我们将讨如何通过工具来解决这一问题。 使用task runner(npm脚本)既然我们已经使用了构建步骤来处理JavaScript模块，使用一个task runner来自动化各构建任务也变得非常合理。对于前端开发，任务包括缩小代码(minifying code)、优化图片，运行测试等。 在2013年，Grunt是最流行的前端task runner，随后Glup流行了一小段时间，它们都是借助插件来包装其他的命令行工具。而现在最流行的选择似乎是使用npm包管理器内置的脚本功能，该功能不需要依赖插件，而是直接与其他命令行工具一起使用。 让我们编写一些npm脚本来帮助我们更方便地使用webpack，这需要改动 package.json文件： 12345678910111213141516171819202122&#123; "name": "modern-javascript-example", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "build": "webpack --progress -p", "watch": "webpack --progress --watch" &#125;, "author": "", "license": "ISC", "dependencies": &#123; "moment": "^2.19.1" &#125;, "devDependencies": &#123; "babel-core": "^6.26.0", "babel-loader": "^7.1.2", "babel-preset-env": "^1.6.1", "webpack": "^3.7.1" &#125;&#125; 这里我们添加了两个新的脚本：build和watch。我们需要通过下述命令来运行build脚本： 1$ npm run build 这会运行webpack(使用我们之前写在webpack.config.js中的配置项)，并带了--progress和-p这两个可选项。其中--progress用于展示百分比进度，-p会在生产环境下压缩代码。下述命令会运行watch脚本： 1$ npm run watch 这使用了--watch选项，它会在每次JavaScript文件更改后自动运行webpack，这对开发者来说非常有用。 请注意，在使用 package.json中的脚本运行webpack时，因为 node.js知道所有npm模块的路径，我不需要指定webpack的全路径：./node_modules/.bin/webpack。这非常方便！此外，我们还可以通过安装 webpack-dev-server，来让事情变得更加简单。 webpack-dev-server是一个单独的工具，它提供了一个带有实时重新加载(live reloading)功能的简单web服务器。我们可以通过下述命令将它安装为开发依赖： 1$ npm install webpack-dev-server --save-dev 然后在 package.json文件添加如下npm脚本： 1234567891011121314151617181920212223&#123; "name": "modern-javascript-example", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "build": "webpack --progress -p", "watch": "webpack --progress --watch", "server": "webpack-dev-server --open" &#125;, "author": "", "license": "ISC", "dependencies": &#123; "moment": "^2.19.1" &#125;, "devDependencies": &#123; "babel-core": "^6.26.0", "babel-loader": "^7.1.2", "babel-preset-env": "^1.6.1", "webpack": "^3.7.1" &#125;&#125; 现在，你可以通过以下命令启动开发服务器： 1$ npm run server 它会自动在浏览器中打开地址为 localhost:8080(默认情况下)的网站，并显示 index.html中的内容。你每次改变 index.js中的JavaScript代码， webpack-dev-server都会重新生成打包(bundle)后的JavaScript代码，并自动刷新浏览器。这可以显著地节省我们的时间，因为它能够使我们专注于代码，而不需要不断地在代码与浏览器之间切换以查看新的更改。 你当然也可以编写npm脚本来执行其他的任务，例如将Sass转换为CSS、压缩图片，运行测试 – 任何具有命令行的工具我们都可以通过npm脚本来执行。npm本身也有一些很棒的高级选项和技巧，Kate Hudson的这个演讲就是一个很好的开始。 结论简而言之，这就是现代JavaScript。我们从简单的HTML和JS转向使用包管理器(package manager)来自动下载第三方依赖包，使用模块打包器(module bundler)来创建单个脚本文件，使用转译器(transpiler)来支持未来的语言特性，和使用task runner来自动化各构建过程。这里面肯定有许多迷人的东西，特别是对一个初学者来说。Web开发因为它很容易开始与运行，曾是编程新手们的一个很好的切入点；但现在它可能会非常难，特别是在各种工具都在快速变化的情况下。 尽管如此，这一切并没有像看起来的那么糟。事情正在稳定下来，特别是在引入node生态作为一种可用的前端开发方式后。我们可以使用npm作为包管理器，使用node的require或import语句来处理模块，使用npm脚本来运行各种任务，这个开发流程很好也很一致，与一两年前相比，这已经是一个大大简化的工作流程了。 对初学者或经验丰富的开发人员来说，另外一个好消息是现在的框架通常都会提供一些工具，以帮助开发者们更简单地开始或入门。如Ember的 ember-cli，它对Angular的 angular-cli有非常大的影响、React的 create-react-app、Vue的vue-cli等等。所有这些工具都会帮你设置好工程需要的一切－－你所需要做的就是开始编写代码。这些工具本身并不神奇，它们只是按照一种一致且起作用的方式帮你设置好所有的东西－－但你依然可能会遇到需要对webpack、babel等工具进行额外配置的情况，因此理解这些工具都是干什么的依然十分重要。 现代JavaScript肯定会让人感到沮丧，因为它依然在快速地发展与进化。即使它有时可能会重复造一些轮子，但JavaScript的快速发展也推动了诸如hot reloading、real-time linting和time-travel debugging等创新技术的产生。成为一名开发人员是一个激动人心的时刻，我希望这些信息能够成为一份路线图，帮助您踏上旅途！ 原文链接：点击此处]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端工程化</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Way to Go（十）]]></title>
    <url>%2F2018%2F09%2F27%2FThe-Way-to-Go%EF%BC%88%E5%8D%81%EF%BC%89%2F</url>
    <content type="text"><![CDATA[注意事项误用字符串当需要对一个字符串进行频繁的操作时，谨记在 go 语言中字符串是不可变的（类似 java 和 c#）。使用诸如 a += b 形式连接字符串效率低下，尤其在一个循环内部使用这种形式。这会导致大量的内存开销和拷贝。应该使用一个字符数组代替字符串，将字符串内容写入一个缓存中。 例如以下的代码示例： 123456var b bytes.Buffer...for condition &#123; b.WriteString(str) // 将字符串str写入缓存buffer&#125; return b.String() 注意：由于编译优化和依赖于使用缓存操作的字符串大小，当循环次数大于15时，效率才会更佳。 发生错误时使用defer关闭一个文件如果你在一个 for 循环内部处理一系列文件，你需要使用 defer 确保文件在处理完毕后被关闭，例如： 123456789for _, file := range files &#123; if f, err = os.Open(file); err != nil &#123; return &#125; // 这是错误的方式，当循环结束时文件没有关闭 defer f.Close() // 对文件进行操作 f.Process(data)&#125; 但是在循环结尾处的 defer 没有执行，所以文件一直没有关闭！垃圾回收机制可能会自动关闭文件，但是这会产生一个错误，更好的做法是： 123456789for _, file := range files &#123; if f, err = os.Open(file); err != nil &#123; return &#125; // 对文件进行操作 f.Process(data) // 关闭文件 f.Close() &#125; defer仅在函数返回时才会执行，在循环的结尾或其他一些有限范围的代码内不会执行。 何时使用 new() 和 make() 切片、映射和通道，使用 make 数组、结构体和所有的值类型，使用 new 不需要将一个指向切片的指针传递给函数切片实际是一个指向潜在数组的指针。我们常常需要把切片作为一个参数传递给函数是因为：实际就是传递一个指向变量的指针，在函数内可以改变这个变量，而不是传递数据的拷贝。 因此应该这样做：1func findBiggest( listOfNumbers []int ) int &#123;&#125; 而不是：1func findBiggest( listOfNumbers *[]int ) int &#123;&#125; 当切片作为参数传递时，切记不要解引用切片。 使用指针指向接口类型查看如下程序：nexter是一个接口类型，并且定义了一个next() 方法读取下一字节。函数 nextFew 将 nexter 接口作为参数并读取接下来的 num 个字节，并返回一个切片：这是正确做法。但是 nextFew2 使用一个指向 nexter 接口类型的指针作为参数传递给函数：当使用 next() 函数时，系统会给出一个编译错误：*n.next undefined (type nexter has no field or method next)* 123456789101112131415161718192021222324package mainimport ( “fmt”)type nexter interface &#123; next() byte&#125;func nextFew1(n nexter, num int) []byte &#123; var b []byte for i:=0; i &lt; num; i++ &#123; b[i] = n.next() &#125; return b&#125;func nextFew2(n *nexter, num int) []byte &#123; var b []byte for i:=0; i &lt; num; i++ &#123; b[i] = n.next() // 编译错误:n.next未定义（*nexter类型没有next成员或next方法） &#125; return b&#125;func main() &#123; fmt.Println(“Hello World!”)&#125; 永远不要使用一个指针指向一个接口类型，因为它已经是一个指针。 使用值类型时误用指针将一个值类型作为一个参数传递给函数或者作为一个方法的接收者，似乎是对内存的滥用，因为值类型一直是传递拷贝。但是另一方面，值类型的内存是在栈上分配，内存分配快速且开销不大。如果你传递一个指针，而不是一个值类型，go编译器大多数情况下会认为需要创建一个对象，并将对象移动到堆上，所以会导致额外的内存分配：因此当使用指针代替值类型作为参数传递时，我们没有任何收获。 闭包和协程的使用123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( "fmt" "time")var values = [5]int&#123;10, 11, 12, 13, 14&#125;func main() &#123; // 版本A: for ix := range values &#123; // ix是索引值 func() &#123; fmt.Print(ix, " ") &#125;() // 调用闭包打印每个索引值 &#125; fmt.Println() // 版本B: 和A版本类似，但是通过调用闭包作为一个协程 for ix := range values &#123; go func() &#123; fmt.Print(ix, " ") &#125;() &#125; fmt.Println() time.Sleep(5e9) // 版本C: 正确的处理方式 for ix := range values &#123; go func(ix interface&#123;&#125;) &#123; fmt.Print(ix, " ") &#125;(ix) &#125; fmt.Println() time.Sleep(5e9) // 版本D: 输出值: for ix := range values &#123; val := values[ix] go func() &#123; fmt.Print(val, " ") &#125;() &#125; time.Sleep(1e9)&#125; 输出：12345670 1 2 3 44 4 4 4 41 0 3 4 210 11 12 13 14 版本 A 调用闭包 5 次打印每个索引值，版本 B 也做相同的事，但是通过协程调用每个闭包。按理说这将执行得更快，因为闭包是并发执行的。如果我们阻塞足够多的时间，让所有协程执行完毕，版本 B 的输出是：4 4 4 4 4。为什么会这样？在版本 B 的循环中，ix 变量实际是一个单变量，表示每个数组元素的索引值。因为这些闭包都只绑定到一个变量，这是一个比较好的方式，当你运行这段代码时，你将看见每次循环都打印最后一个索引值 4，而不是每个元素的索引值。因为协程可能在循环结束后还没有开始执行，而此时 ix值是 4。 版本 C 的循环写法才是正确的：调用每个闭包是将 ix 作为参数传递给闭包。ix 在每次循环时都被重新赋值，并将每个协程的 ix 放置在栈中，所以当协程最终被执行时，每个索引值对协程都是可用的。注意这里的输出可能是 0 2 1 3 4或者 0 3 1 2 4 或者其他类似的序列，这主要取决于每个协程何时开始被执行。 在版本 D 中，我们输出这个数组的值，为什么版本 B 不能而版本 D 可以呢？ 因为版本 D 中的变量声明是在循环体内部，所以在每次循环时，这些变量相互之间是不共享的，所以这些变量可以单独的被每个闭包使用。 实用代码片段字符串（1）如何修改字符串中的一个字符： 1234str:="hello"c:=[]byte(str)c[0]='c's2:= string(c) // s2 == "cello" （2）如何获取字符串的子串： 1substr := str[n:m] （3）如何使用for 或者for-range 遍历一个字符串： 12345678// gives only the bytes:for i:=0; i &lt; len(str); i++ &#123;… = str[i]&#125;// gives the Unicode characters:for ix, ch := range str &#123;…&#125; （4）如何获取一个字符串的字节数：len(str) 如何获取一个字符串的字符数： 最快速：utf8.RuneCountInString(str) len([]int(str)) （5）如何连接字符串：最快速：with a bytes.Buffer Strings.Join() 使用+=： 123str1 := "Hello " str2 := "World!"str1 += str2 //str1 == "Hello World!" （6）如何解析命令行参数：使用 os 或者flag包 数组和切片创建：123arr1 := new([len]type)slice1 := make([]type, len) 初始化：12345arr1 := [...]type&#123;i1, i2, i3, i4, i5&#125;arrKeyValue := [len]type&#123;i1: val1, i2: val2&#125;var slice1 []type = arr1[start:end] （1）如何截断数组或者切片的最后一个元素：1line = line[:len(line)-1] （2）如何使用 for 或者 for-range 遍历一个数组（或者切片）： 123456for i:=0; i &lt; len(arr); i++ &#123;… = arr[i]&#125;for ix, value := range arr &#123;…&#125; （3）如何在一个二维数组或者切片 arr2Dim 中查找一个指定值 V：123456789found := falseFound: for row := range arr2Dim &#123; for column := range arr2Dim[row] &#123; if arr2Dim[row][column] == V&#123; found = true break Found &#125; &#125;&#125; 映射创建： map1 := make(map[keytype]valuetype) 初始化：map1 := map[string]int{&quot;one&quot;: 1, &quot;two&quot;: 2} （1）如何使用 for 或者for-range 遍历一个映射：123for key, value := range map1 &#123;…&#125; （2）如何在一个映射中检测键 key1 是否存在：1val1, isPresent = map1[key1] 返回值：键 key1 对应的值或者 0, true 或者 false （3）如何在映射中删除一个键：1delete(map1, key1) 结构体创建：123456type struct1 struct &#123; field1 type1 field2 type2 …&#125;ms := new(struct1) 初始化：1ms := &amp;struct1&#123;10, 15.5, "Chris"&#125; 当结构体的命名以大写字母开头时，该结构体在包外可见。通常情况下，为每个结构体定义一个构建函数，并推荐使用构建函数初始化结构体 1234ms := Newstruct1&#123;10, 15.5, "Chris"&#125;func Newstruct1(n int, f float32, name string) *struct1 &#123; return &amp;struct1&#123;n, f, name&#125; &#125; 接口（1）如何检测一个值 v 是否实现了接口 Stringer： 123if v, ok := v.(Stringer); ok &#123; fmt.Printf("implements String(): %s\n", v.String())&#125; （2）如何使用接口实现一个类型分类函数： 123456789101112131415161718func classifier(items ...interface&#123;&#125;) &#123; for i, x := range items &#123; switch x.(type) &#123; case bool: fmt.Printf("param #%d is a bool\n", i) case float64: fmt.Printf("param #%d is a float64\n", i) case int, int64: fmt.Printf("param #%d is an int\n", i) case nil: fmt.Printf("param #%d is nil\n", i) case string: fmt.Printf("param #%d is a string\n", i) default: fmt.Printf("param #%d’s type is unknown\n", i) &#125; &#125;&#125; 函数如何使用内建函数 recover 终止 panic 过程 1234567891011func protect(g func()) &#123; defer func() &#123; log.Println("done") // Println executes normally even if there is a panic if x := recover(); x != nil &#123; log.Printf("run time panic: %v", x) &#125; &#125;() log.Println("start") g()&#125; 文件（1）如何打开一个文件并读取：12345678910111213141516file, err := os.Open("input.dat") if err != nil &#123; fmt.Printf("An error occurred on opening the inputfile\n" + "Does the file exist?\n" + "Have you got acces to it?\n") return &#125; defer file.Close() iReader := bufio.NewReader(file) for &#123; str, err := iReader.ReadString('\n') if err != nil &#123; return // error or EOF &#125; fmt.Printf("The input was: %s", str) &#125; （2）如何通过切片读写文件：12345678910111213141516171819func cat(f *file.File) &#123; const NBUF = 512 var buf [NBUF]byte for &#123; switch nr, er := f.Read(buf[:]); true &#123; case nr &lt; 0: fmt.Fprintf(os.Stderr, "cat: error reading from %s: %s\n", f.String(), er.String()) os.Exit(1) case nr == 0: // EOF return case nr &gt; 0: if nw, ew := file.Stdout.Write(buf[0:nr]); nw != nr &#123; fmt.Fprintf(os.Stderr, "cat: error writing from %s: %s\n", f.String(), ew.String()) &#125; &#125; &#125;&#125; 协程（goroutine）与通道（channel）出于性能考虑的建议： 实践经验表明，如果你使用并行运算获得高于串行运算的效率：在协程内部已经完成的大部分工作，其开销比创建协程和协程间通信还高。 1 出于性能考虑建议使用带缓存的通道： 使用带缓存的通道可以很轻易成倍提高它的吞吐量，某些场景其性能可以提高至10倍甚至更多。通过调整通道的容量，甚至可以尝试着更进一步的优化其性能。 2 限制一个通道的数据数量并将它们封装成一个数组： 如果使用通道传递大量单独的数据，那么通道将变成性能瓶颈。然而，将数据块打包封装成数组，在接收端解压数据时，性能可以提高至 10 倍。 创建：ch := make(chan type,buf) （1）如何使用 for 或者 for-range 遍历一个通道： 123for v := range ch &#123; // do something with v&#125; （2）如何检测一个通道 ch 是否关闭：12345678 // read channel until it closes or error-conditionfor &#123; if input, open := &lt;-ch; !open &#123; break &#125; fmt.Printf("%s", input)&#125; 或者使用（1）自动检测。 （3）如何通过一个通道让主程序等待直到协程完成： （信号量模式）： 12345678ch := make(chan int) // Allocate a channel.// Start something in a goroutine; when it completes, signal on the channel.go func() &#123; // doSomething ch &lt;- 1 // Send a signal; value does not matter.&#125;()doSomethingElseForAWhile()&lt;-ch // Wait for goroutine to finish; discard sent value. 如果希望程序一直阻塞，在匿名函数中省略 ch &lt;- 1 即可。 （4）通道的工厂模板：以下函数是一个通道工厂，启动一个匿名函数作为协程以生产通道： 123456789func pump() chan int &#123; ch := make(chan int) go func() &#123; for i := 0; ; i++ &#123; ch &lt;- i &#125; &#125;() return ch&#125; 如何在程序出错时终止程序1234if err != nil &#123; fmt.Printf(“Program stopping with error %v”, err) os.Exit(1)&#125; 或者：123if err != nil &#123; panic(“ERROR occurred: “ + err.Error())&#125; 出于性能考虑的最佳实践和建议（1）尽可能的使用 :=去初始化声明一个变量（在函数内部）； （2）尽可能的使用字符代替字符串； （3）尽可能的使用切片代替数组； （4）尽可能的使用数组和切片代替映射 ； （5）如果只想获取切片中某项值，不需要值的索引，尽可能的使用 for range 去遍历切片，这比必须查询切片中的每个元素要快一些； （6）当数组元素是稀疏的（例如有很多 0 值或者空值 nil），使用映射会降低内存消耗； （7）初始化映射时指定其容量； （8）当定义一个方法时，使用指针类型作为方法的接受者； （9）在代码中使用常量或者标志提取常量的值； （10）尽可能在需要分配大量内存时使用缓存； （11）使用缓存模板]]></content>
      <categories>
        <category>The Way to Go</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Way to Go（九）]]></title>
    <url>%2F2018%2F09%2F15%2FThe-Way-to-Go%EF%BC%88%E4%B9%9D%EF%BC%89%2F</url>
    <content type="text"><![CDATA[web 应用tcp 服务器一个（web）服务器应用需要响应众多客户端的并发请求：go 会为每一个客户端产生一个协程用来处理请求。我们需要使用 net 包中网络通信的功能。它包含了用于 TCP/IP 以及 UDP 协议、域名解析等方法。 服务器代码，单独的一个文件：123456789101112131415161718192021222324252627282930313233343536373839// server.gopackage mainimport ( "fmt" "net")func main() &#123; fmt.Println("Starting the server ...") // 创建 listener listener, err := net.Listen("tcp", "localhost:50000") if err != nil &#123; fmt.Println("Error listening", err.Error()) return //终止程序 &#125; // 监听并接受来自客户端的连接 for &#123; conn, err := listener.Accept() if err != nil &#123; fmt.Println("Error accepting", err.Error()) return // 终止程序 &#125; go doServerStuff(conn) &#125;&#125;func doServerStuff(conn net.Conn) &#123; for &#123; buf := make([]byte, 512) len, err := conn.Read(buf) if err != nil &#123; fmt.Println("Error reading", err.Error()) return //终止程序 &#125; fmt.Printf("Received data: %v", string(buf[:len])) &#125;&#125; 我们在 main()创建了一个 net.Listener 的变量，他是一个服务器的基本函数：用来监听和接收来自客户端的请求（来自 localhost 即IP地址为 127.0.0.1 端口为 50000 基于 TCP 协议）。这个Listen() 函数可以返回一个 error 类型的错误变量。用一个无限for循环的listener.Accept() 来等待客户端的请求。客户端的请求将产生一个net.Conn 类型的连接变量。然后一个独立的协程使用这个连接执行doServerStuff()，开始使用一个 512 字节的缓冲data 来读取客户端发送来的数据并且把它们打印到服务器的终端，len 获取客户端发送的数据字节数；当客户端发送的所有数据都被读取完成时，协程就结束了。这段程序会为每一个客户端连接创建一个独立的协程。必须先运行服务器代码，再运行客户端代码。 1234567891011121314151617181920212223242526272829303132333435363738// client.gopackage mainimport ( "bufio" "fmt" "net" "os" "strings")func main() &#123; //打开连接: conn, err := net.Dial("tcp", "localhost:50000") if err != nil &#123; //由于目标计算机积极拒绝而无法创建连接 fmt.Println("Error dialing", err.Error()) return // 终止程序 &#125; inputReader := bufio.NewReader(os.Stdin) fmt.Println("First, what is your name?") clientName, _ := inputReader.ReadString('\n') // fmt.Printf("CLIENTNAME %s", clientName) trimmedClient := strings.Trim(clientName, "\r\n") // Windows 平台下用 "\r\n"，Linux平台下使用 "\n" // 给服务器发送信息直到程序退出： for &#123; fmt.Println("What to send to the server? Type Q to quit.") input, _ := inputReader.ReadString('\n') trimmedInput := strings.Trim(input, "\r\n") // fmt.Printf("input:--s%--", input) // fmt.Printf("trimmedInput:--s%--", trimmedInput) if trimmedInput == "Q" &#123; return &#125; _, err = conn.Write([]byte(trimmedClient + " says: " + trimmedInput)) &#125;&#125; 客户端通过net.Dial 创建了一个和服务器之间的连接 它通过无限循环中的 os.Stdin 接收来自键盘的输入直到输入了 “Q”。注意使用\r 和\n 换行符分割字符串（在windows平台下使用\r\n）。接下来分割后的输入通过 connection的Write方法被发送到服务器。 在网络编程中net.Dial 函数是非常重要的，一旦你连接到远程系统，就会返回一个 Conn 类型接口，我们可以用它发送和接收数据。Dial函数巧妙的抽象了网络结构及传输。所以 IPv4 或者 IPv6，TCP 或者 UDP 都可以使用这个公用接口。 一个简单的网页服务器Http 是一个比 tcp 更高级的协议，它描述了客户端浏览器如何与网页服务器进行通信。Go 有自己的 net/http 包，我们来看看它。首先编写一个“Hello world!”： 我们引入了 http 包并启动了网页服务器，使用http.ListenAndServe(&quot;localhost:8080&quot;, nil) 函数，如果成功会返回空，否则会返回一个错误 http.URL 描述了 web 服务器的地址，内含存放了 url 字符串的 Path 属性；http.Request 描述了客户端请求，内含一个 URL 属性 如果 req 请求是一个 POST 类型的 html 表单，“var1” 就是 html 表单中一个输入属性的名称，然后用户输入的值就可以通过 GO 代码：req.FormValue(&quot;var1&quot;) 获取到。还有一种方法就是先执行 request.ParseForm()然后再获取request.Form[&quot;var1&quot;] 的第一个返回参数，就像这样： 1var1, found := request.Form["var1"] 第二个参数 found 就是true，如果 var1 并未出现在表单中，found 就是 false 表单属性实际上是一个 map[string][]string 类型。网页服务器返回了一个http.Response，它是通过 http.ResponseWriter对象输出的，这个对象整合了 HTTP 服务器的返回结果；通过对它写入内容，我们就将数据发送给了 HTTP 客户端。 现在我们还需要编写网页服务器必须执行的程序，它是如何处理请求的呢。这是在http.HandleFunc函数中完成的，就是在这个例子中当根路径 “/”（url 地址是 http://localhost:8080 ）被请求的时候（或者这个服务器上的其他地址），HelloServer 函数就被执行了。这个函数是http.HandlerFunc 类型的，它们通常用使用 Prehandler 来命名，在前边加了一个 Pref 前缀。 http.HandleFunc注册了一个处理函数(这里是 HelloServer)来处理对应 / 的请求。 / 可以被替换为其他特定的 url 比如 /create，/edit 等等；你可以为每一个特定的 url 定义一个单独的处理函数。这个函数需要两个参数：第一个是 ReponseWriter类型的w；第二个是请求req。程序向 w 写入了 Hello 和r.URL.Path[1:] 组成的字符串后边的 [1:]表示“创建一个从第一个字符到结尾的子切片”，用来丢弃掉路径开头的 “/”，fmt.Fprintf() 函数完成了本次写入；另外一种写法是 io.WriteString(w, &quot;hello, world!\n&quot;) 总结：第一个参数是请求的路径，第二个参数是处理这个路径请求的函数的引用。 1234567891011121314151617181920package mainimport ( "fmt" "log" "net/http")func HelloServer(w http.ResponseWriter, req *http.Request) &#123; fmt.Println("Inside HelloServer handler") fmt.Fprintf(w, "Hello,"+req.URL.Path[1:])&#125;func main() &#123; http.HandleFunc("/", HelloServer) err := http.ListenAndServe("localhost:8080", nil) if err != nil &#123; log.Fatal("ListenAndServe: ", err.Error()) &#125;&#125; 前两行（没有错误处理代码）可以替换成以下写法： http.ListenAndServe(&quot;:8080&quot;, http.HandlerFunc(HelloServer)) 读取并访问页面在下边这个程序中，数组中的 url 都将被访问：会发送一个简单的 http.Head() 请求查看返回值；它的声明如下：func Head(url string) (r *Response, err error) 返回状态码会被打印出来。 123456789101112131415161718192021222324package mainimport ( "fmt" "net/http")var urls = []string&#123; "http://www.google.com/", "http://golang.org/", "http://blog.golang.org/",&#125;func main() &#123; // Execute an HTTP HEAD request for all url's // and returns the HTTP status string or an error string. for _, url := range urls &#123; resp, err := http.Head(url) if err != nil &#123; fmt.Println("Error:", url, err) &#125; fmt.Println(url, ": ", resp.Status) &#125;&#125; 输出为：123http://www.google.com/ : 302 Foundhttp://golang.org/ : 200 OKhttp://blog.golang.org/ : 200 OK 在下边的程序中我们使用 http.Get() 获取网页内容； Get 的返回值 res 中的 Body 属性包含了网页内容，然后我们用 ioutil.ReadAll把它读出来： 12345678910111213141516171819202122package mainimport ( "fmt" "io/ioutil" "log" "net/http")func main() &#123; res, err := http.Get("http://www.google.com") checkError(err) data, err := ioutil.ReadAll(res.Body) checkError(err) fmt.Printf("Got: %q", string(data))&#125;func checkError(err error) &#123; if err != nil &#123; log.Fatalf("Get : %v", err) &#125;&#125; 访问不存在的网站时，这里有一个 CheckError 输出错误的例子： 12011/09/30 11:24:15 Get: Get http://www.google.bex: dial tcp www.google.bex:80:GetHostByName: No such host is known. http 包中的其他重要的函数： http.Redirect(w ResponseWriter, r *Request, url string, code int)：这个函数会让浏览器重定向到url（是请求的url的相对路径）以及状态码。 http.NotFound(w ResponseWriter, r *Request)：这个函数将返回网页没有找到，HTTP 404 错误。 http.Error(w ResponseWriter, error string, code int)：这个函数返回特定的错误信息和 HTTP 代码。 另 http.Request 对象的一个重要属性 req：req.Method，这是一个包含 GET 或 POST 字符串，用来描述网页是以何种方式被请求的。 go 为所有的 HTTP 状态码定义了常量，比如： 12345678http.StatusContinue = 100http.StatusOK = 200http.StatusFound = 302http.StatusBadRequest = 400http.StatusUnauthorized = 401http.StatusForbidden = 403http.StatusNotFound = 404http.StatusInternalServerError = 500 你可以使用 w.header().Set(&quot;Content-Type&quot;, &quot;../..&quot;)设置头信息 比如在网页应用发送html字符串的时候，在输出之前执行 w.Header().Set(&quot;Content-Type&quot;, &quot;text/html&quot;)。]]></content>
      <categories>
        <category>The Way to Go</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Way to Go（八）]]></title>
    <url>%2F2018%2F09%2F10%2FThe-Way-to-Go%EF%BC%88%E5%85%AB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[协程（goroutine）与通道（channel）什么是协程一个应用程序是运行在机器上的一个进程；进程是一个运行在自己内存地址空间里的独立执行体。一个进程由一个或多个操作系统线程组成，这些线程其实是共享同一个内存地址空间的一起工作的执行体。几乎所有’正式’的程序都是多线程的，以便让用户或计算机不必等待，或者能够同时服务多个请求（如 Web 服务器），或增加性能和吞吐量。一个并发程序可以在一个处理器或者内核上使用多个线程来执行任务，但是只有同一个程序在某个时间点同时运行在多核或者多处理器上才是真正的并行。 并行是一种通过使用多处理器以提高速度的能力。所以并发程序可以是并行的，也可以不是。 公认的，使用多线程的应用难以做到准确，最主要的问题是内存中的数据共享，它们会被多线程以无法预知的方式进行操作，导致一些无法重现或者随机的结果（称作 竞态）。 不要使用全局变量或者共享内存，它们会给你的代码在并发运算的时候带来危险。 解决之道在于同步不同的线程，对数据加锁，这样同时就只有一个线程可以变更数据。在 Go 的标准库 sync 中有一些工具用来在低级别的代码中实现加锁； 不过过去的软件开发经验告诉我们这会带来更高的复杂度，更容易使代码出错以及更低的性能，所以这个经典的方法明显不再适合现代多核/多处理器编程：thread-per-connection 模型不够有效。 在 Go 中，应用程序并发处理的部分被称作 goroutines（协程），它可以进行更有效的并发运算。在协程和操作系统线程之间并无一对一的关系：协程是根据一个或多个线程的可用性，映射（多路复用，执行于）在他们之上的；协程调度器在 Go 运行时很好的完成了这个工作。 协程工作在相同的地址空间中，所以共享内存的方式一定是同步的；这个可以使用sync 包来实现，不过我们很不鼓励这样做：Go 使用 channels 来同步协程 当系统调用（比如等待 I/O）阻塞协程时，其他协程会继续在其他线程上工作。协程的设计隐藏了许多线程创建和管理方面的复杂工作。 存在两种并发方式：确定性的（明确定义排序）和非确定性的（加锁/互斥从而未定义排序）。Go 的协程和通道理所当然的支持确定性的并发方式（例如通道具有一个 sender 和一个 receiver）。 协程是通过使用关键字go 调用（或执行）一个函数或者方法来实现的（也可以是匿名或者 lambda 函数）。这样会在当前的计算过程中开始一个同时进行的函数，在相同的地址空间中并且分配了独立的栈，比如：go sum(bigArray)，在后台计算总和。 协程的栈会根据需要进行伸缩，不会出现栈溢出；开发者无需关心栈的大小。当协程结束的时候，它会静默退出：用来启动这个协程的函数也不会得到任何的返回值。 任何 Go 程序都必须有的main() 函数也可以看做是一个协程，尽管它并没有通过go 来启动。协程可以在程序初始化的过程中运行（在 init() 函数中）。 协程间的信道Go有一个特殊的类型，通道（channel），像是通道（管道），可以通过它们发送类型化的数据在协程之间通信，可以避开所有内存共享导致的坑；通道的通信方式保证了同步性。数据通过通道：同一时间只有一个协程可以访问数据：所以不会出现数据竞争，设计如此。数据的归属（可以读写数据的能力）被传递。 工厂的传送带是个很有用的例子。一个机器（生产者协程）在传送带上放置物品，另外一个机器（消费者协程）拿到物品并打包。 通道服务于通信的两个目的：值的交换，同步的，保证了两个计算（协程）任何时候都是可知状态。 通常使用这样的格式来声明通道：1var identifier chan datatype 未初始化的通道的值是nil。 通道只能传输一种类型的数据，比如 chan int 或者 chan string，所有的类型都可以用于通道，空接口interface{} 也可以。甚至可以（有时非常有用）创建通道的通道。 通道实际上是类型化消息的队列：使数据得以传输。它是先进先出（FIFO）的结构所以可以保证发送给他们的元素的顺序。通道也是引用类型，所以我们使用 make() 函数来给它分配内存。这里先声明了一个字符串通道 ch1，然后创建了它（实例化）： 12var ch1 chan stringch1 = make(chan string) 当然可以更短：1ch1 := make(chan string)。 int通道的通道： chanOfChans := make(chan int) 函数通道：funcChan := chan func() 通信操作符 &lt;-这个操作符直观的标示了数据的传输：信息按照箭头的方向流动。 流向通道（发送） ch &lt;- int1 表示：用通道ch发送变量 int1（双目运算符，中缀 = 发送） 从通道流出（接收），三种方式： int2 = &lt;- ch 表示：变量 int2从通道 ch（一元运算的前缀操作符，前缀 = 接收）接收数据（获取新值）；假设 int2 已经声明过了，如果没有的话可以写成：int2 := &lt;- ch。 &lt;- ch可以单独调用获取通道的（下一个）值，当前值会被丢弃，但是可以用来验证，所以以下代码是合法的： 123if &lt;- ch != 1000&#123; ...&#125; 下面的示例展示了通信操作。 1234567891011121314151617181920212223242526272829303132package mainimport ( "fmt" "time")func main() &#123; ch := make(chan string) go sendData(ch) go getData(ch) time.Sleep(1e9)&#125;func sendData(ch chan string) &#123; ch &lt;- "Washington" ch &lt;- "Tripoli" ch &lt;- "London" ch &lt;- "Beijing" ch &lt;- "Tokio"&#125;func getData(ch chan string) &#123; var input string // time.Sleep(2e9) for &#123; input = &lt;-ch fmt.Printf("%s ", input) &#125;&#125; 输出：1Washington Tripoli London Beijing Tokio main()函数中启动了两个协程：sendData()通过通道ch 发送了 5 个字符串，getData()按顺序接收它们并打印出来。 main() 等待了 1 秒让两个协程完成，如果不这样，sendData() 就没有机会输出。 getData()使用了无限循环：它随着 sendData()的发送完成和ch 变空也结束了。 如果我们移除一个或所有 go关键字，程序无法运行，Go 运行时会抛出 panic 为什么会这样？运行时会检查所有的协程（也许只有一个是这种情况）是否在等待（可以读取或者写入某个通道），意味着程序无法处理。这是死锁（deadlock）形式，运行时可以检测到这种情况。 注意：不要使用打印状态来表明通道的发送和接收顺序：由于打印状态和通道实际发生读写的时间延迟会导致和真实发生的顺序不同。 通道阻塞默认情况下，通信是同步且无缓冲的：在有接受者接收数据之前，发送不会结束。可以想象一个无缓冲的通道在没有空间来保存数据的时候：必须要一个接收者准备好接收通道的数据然后发送者可以直接把数据发送给接收者。所以通道的发送/接收操作在对方准备好之前是阻塞的： 1）对于同一个通道，发送操作（协程或者函数中的），在接收者准备好之前是阻塞的：如果ch中的数据无人接收，就无法再给通道传入其他数据：新的输入无法在通道非空的情况下传入。所以发送操作会等待 ch 再次变为可用状态：就是通道值被接收时（可以传入变量）。 2）对于同一个通道，接收操作是阻塞的（协程或函数中的），直到发送者可用：如果通道中没有数据，接收者就阻塞了。 以下程序验证了以上理论，一个协程在无限循环中给通道发送整数数据。不过因为没有接收者，只输出了一个数字 0。 123456789101112131415package mainimport "fmt"func main() &#123; ch1 := make(chan int) go pump(ch1) // pump hangs fmt.Println(&lt;-ch1) // prints only 0&#125;func pump(ch chan int) &#123; for i := 0; ; i++ &#123; ch &lt;- i &#125;&#125; 输出：10 pump() 函数为通道提供数值，也被叫做生产者。 为通道解除阻塞定义了 suck 函数来在无限循环中读取通道: 12345func suck(ch chan int) &#123; for &#123; fmt.Println(&lt;-ch) &#125;&#125; 在main() 中使用协程开始它：123go pump(ch1)go suck(ch1)time.Sleep(1e9) 给程序 1 秒的时间来运行：输出了上万个整数。 同步通道-使用带缓冲的通道一个无缓冲通道只能包含 1 个元素，有时显得很局限。我们给通道提供了一个缓存，可以在扩展的make命令中设置它的容量，如下：12buf := 100ch1 := make(chan string, buf) buf 是通道可以同时容纳的元素（这里是 string）个数 在缓冲满载（缓冲被全部使用）之前，给一个带缓冲的通道发送数据是不会阻塞的，而从通道读取数据也不会阻塞，直到缓冲空了。 缓冲容量和类型无关，所以可以（尽管可能导致危险）给一些通道设置不同的容量，只要他们拥有同样的元素类型。内置的 cap 函数可以返回缓冲区的容量。 如果容量大于 0，通道就是异步的了：缓冲满载（发送）或变空（接收）之前通信不会阻塞，元素会按照发送的顺序被接收。如果容量是0或者未设置，通信仅在收发双方准备好的情况下才可以成功。 同步：ch :=make(chan type, value) value == 0 -&gt; synchronous, unbuffered (阻塞） value &gt; 0 -&gt; asynchronous, buffered（非阻塞）取决于value元素 使用 select 切换协程从不同的并发执行的协程中获取值可以通过关键字select来完成，它和switch控制语句非常相似，也被称作通信开关；它的行为像是“你准备好了吗”的轮询机制；select监听进入通道的数据，也可以是用通道发送值的时候。 123456789select &#123;case u:= &lt;- ch1: ...case v:= &lt;- ch2: ... ...default: // no value ready to be received ...&#125; default 语句是可选的；fallthrough行为，和普通的 switch 相似，是不允许的。在任何一个 case中执行 break或者 return，select就结束了。 select 做的就是：选择处理列出的多个通信情况中的一个。 如果都阻塞了，会等待直到其中一个可以处理 如果多个可以处理，随机选择一个 如果没有通道操作可以处理并且写了 default 语句，它就会执行：default 永远是可运行的（这就是准备好了，可以执行）。 在 select 中使用发送操作并且有 default可以确保发送不被阻塞！如果没有 case，select 就会一直阻塞。 select 语句实现了一种监听模式，通常用在（无限）循环中；在某种情况下，通过 break 语句使循环退出。 以下程序中有 2 个通道ch1 和ch2，三个协程 pump1()、pump2() 和 suck()。这是一个典型的生产者消费者模式。在无限循环中，ch1 和 ch2 通过 pump1() 和 pump2() 填充整数；suck() 也是在无限循环中轮询输入的，通过 select 语句获取ch1 和 ch2 的整数并输出。选择哪一个case 取决于哪一个通道收到了信息。程序在 main执行 1 秒后结束。 12345678910111213141516171819202122232425262728293031323334353637383940package mainimport ( "fmt" "time")func main() &#123; ch1 := make(chan int) ch2 := make(chan int) go pump1(ch1) go pump2(ch2) go suck(ch1, ch2) time.Sleep(1e9)&#125;func pump1(ch chan int) &#123; for i := 0; ; i++ &#123; ch &lt;- i * 2 &#125;&#125;func pump2(ch chan int) &#123; for i := 0; ; i++ &#123; ch &lt;- i + 5 &#125;&#125;func suck(ch1, ch2 chan int) &#123; for &#123; select &#123; case v := &lt;-ch1: fmt.Printf("Received on channel 1: %d\n", v) case v := &lt;-ch2: fmt.Printf("Received on channel 2: %d\n", v) &#125; &#125;&#125; 输出：12345678910111213Received on channel 2: 5Received on channel 2: 6Received on channel 1: 0Received on channel 2: 7Received on channel 2: 8Received on channel 2: 9Received on channel 2: 10Received on channel 1: 2Received on channel 2: 11...Received on channel 2: 47404Received on channel 1: 94346Received on channel 1: 94348 新旧模型对比：任务和worker假设我们需要处理很多任务；一个worker处理一项任务。任务可以被定义为一个结构体 123type Task struct &#123; // some state&#125; 旧模式：使用共享内存进行同步 由各个任务组成的任务池共享内存；为了同步各个worker以及避免资源竞争，我们需要对任务池进行加锁保护： 1234type Pool struct &#123; Mu sync.Mutex Tasks []Task&#125; worker代码可能这样写： 1234567891011func Worker(pool *Pool) &#123; for &#123; pool.Mu.lock() // begin critical section: task := pool.Task[0] // take the first task pool.Tasks = pool.Task[1:] // update the pool of tasks // end critical section pool.Mu.Unlock() process(task) &#125;&#125; 这些worker有许多都可以并发执行；他们可以在go协程中启动。一个worker先将pool锁定，从pool获取第一项任务，再解锁和处理任务。加锁保证了同一时间只有一个go协程可以进入到pool中：一项任务有且只能被赋予一个worer。如果不加锁，则工作协程可能会在task:=pool.Task[0]发生切换，导致pool.Tasks=pool.Task[1:]结果异常：一些worker获取不到任务，而一些任务可能被多个worker得到。加锁实现同步的方式在工作协程比较少时可以工作的很好，但是当工作协程数量很大，任务量也很多时，处理效率将会因为频繁的加锁/解锁开销而降低。当工作协程数增加到一个阈值时，程序效率会急剧下降，这就成为了瓶颈。 新模式：使用通道使用通道进行同步：使用一个通道接受需要处理的任务，一个通道接受处理完成的任务（及其结果）。worker在协程中启动，其数量N应该根据任务数量进行调整。 主线程扮演着Master节点角色，可能写成如下形式： 12345678func main() &#123; pending, done := make(chan *Task), make(chan *Task) go sendWork(pending) // put tasks with work on the channel for i := 0; i &lt; N; i++ &#123; // start N goroutines to do work go Worker(pending, done) &#125; consumeWork(done) // continue with the processed tasks &#125; worker的逻辑比较简单：从pending通道拿任务，处理后将其放到done通道中： 1234567func Worker(in, out chan *Task) &#123; for &#123; t := &lt;-in process(t) out &lt;- t &#125;&#125; 这里并不使用锁：从通道得到新任务的过程没有任何竞争。随着任务数量增加，worker数量也应该相应增加，同时性能并不会像第一种方式那样下降明显。在pending通道中存在一份任务的拷贝，第一个worker从pending通道中获得第一个任务并进行处理，这里并不存在竞争。某一个任务会在哪一个worker中被执行是不可知的，反过来也是。worker数量的增多也会增加通信的开销，这会对性能有轻微的影响。 从这个简单的例子中可能很难看出第二种模式的优势，但含有复杂锁运用的程序不仅在编写上显得困难，也不容易编写正确，使用第二种模式的话，就无需考虑这么复杂的东西了。 因此，第二种模式对比第一种模式而言，不仅性能是一个主要优势，而且还有个更大的优势：代码显得更清晰、更优雅。 怎么选择是该使用锁还是通道？ 使用锁的情景： 1) 访问共享数据结构中的缓存信息 2) 保存应用程序上下文和状态信息数据 使用通道的情景： 1) 与异步操作的结果进行交互 2) 分发任务 3) 传递数据所有权 当你发现你的锁使用规则变得很复杂时，可以反省使用通道会不会使问题变得简单些。]]></content>
      <categories>
        <category>The Way to Go</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Way to Go（七）]]></title>
    <url>%2F2018%2F06%2F15%2FThe-Way-to-Go%EF%BC%88%E4%B8%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[错误处理与测试Go 没有像 Java 和 .NET 那样的 try/catch 异常机制：不能执行抛异常操作。但是有一套 defer-panic-and-recover 机制。 Go 的设计者觉得 try/catch 机制的使用太泛滥了，而且从底层向更高的层级抛异常太耗费资源。他们给 Go 设计的机制也可以 “捕捉” 异常，但是更轻量，并且只应该作为（处理错误的）最后的手段。 Go 检查和报告错误条件的惯有方式： 产生错误的函数会返回两个变量，一个值和一个错误码；如果后者是 nil 就是成功，非 nil就是发生了错误。 为了防止发生错误时正在执行的函数（如果有必要的话甚至会是整个程序）被中止，在调用函数后必须检查错误。 错误处理Go 有一个预先定义的 error 接口类型 123type error interface &#123; Error() string&#125; 错误值用来表示异常状态；errors 包中有一个errorString 结构体实现了 error 接口。当程序处于错误状态时可以用 os.Exit(1) 来中止运行。 定义错误任何时候当你需要一个新的错误类型，都可以用 errors（必须先 import）包的 errors.New 函数接收合适的错误信息来创建，像下面这样： 1err := errors.New(“math - square root of negative number”) 12345678910111213package mainimport ( "errors" "fmt")var errNotFound error = errors.New("Not found error")func main() &#123; fmt.Printf("error: %v", errNotFound)&#125;// error: Not found error 可以把它用于计算平方根函数的参数测试： 123456func Sqrt(f float64) (float64, error) &#123; if f &lt; 0 &#123; return 0, errors.New ("math - square root of negative number") &#125; // implementation of Sqrt&#125; 你可以像下面这样调用 Sqrt 函数： 123if f, err := Sqrt(-1); err != nil &#123; fmt.Printf("Error: %s\n", err)&#125; 用 fmt 创建错误对象通常你想要返回包含错误参数的更有信息量的字符串，例如：可以用 fmt.Errorf() 来实现：它和fmt.Printf() 完全一样，接收有一个或多个格式占位符的格式化字符串和相应数量的占位变量。和打印信息不同的是它用信息生成错误对象。 比如在前面的平方根例子中使用： 123if f &lt; 0 &#123; return 0, fmt.Errorf("math: square root of negative number %g", f)&#125; 运行时异常和 panic当发生像数组下标越界或类型断言失败这样的运行错误时，Go 运行时会触发运行时 panic，伴随着程序的崩溃抛出一个 runtime.Error 接口类型的值。这个错误值有个RuntimeError() 方法用于区别普通错误。 panic可以直接从代码初始化：当错误条件（我们所测试的代码）很严苛且不可恢复，程序不能继续运行时，可以使用 panic 函数产生一个中止程序的运行时错误。panic 接收一个做任意类型的参数，通常是字符串，在程序死亡时被打印出来。Go 运行时负责中止程序并给出调试信息。 从 panic 中恢复（Recover）正如名字一样，这个（recover）内建函数被用于从 panic 或 错误场景中恢复：让程序可以从 panicking 重新获得控制权，停止终止过程进而恢复正常执行。 recover 只能在 defer 修饰的函数中使用：用于取得panic 调用中传递过来的错误值，如果是正常执行，调用 recover会返回 nil，且没有其它效果。 总结：panic 会导致栈被展开直到 defer 修饰的 recover() 被调用或者程序中止。 下面例子中的 protect 函数调用函数参数 g 来保护调用者防止从 g 中抛出的运行时 panic，并展示 panic 中的信息：1234567891011func protect(g func()) &#123; defer func() &#123; log.Println("done") // Println executes normally even if there is a panic if err := recover(); err != nil &#123; log.Printf("run time panic: %v", err) &#125; &#125;() log.Println("start") g() // possible runtime-error&#125; defer-panic-recover在某种意义上也是一种像 if，for 这样的控制流机制。 Go 中的单元测试和基准测试首先所有的包都应该有一定的必要文档，然后同样重要的是对包的测试。 名为 testing 的包被专门用来进行自动化测试，日志和错误报告。并且还包含一些基准测试函数的功能。 对一个包做（单元）测试，需要写一些可以频繁（每次更新后）执行的小块测试单元来检查代码的正确性。于是我们必须写一些 Go 源文件来测试代码。测试程序必须属于被测试的包，并且文件名满足这种形式 *_test.go，所以测试代码和包中的业务代码是分开的。 _test 程序不会被普通的 Go 编译器编译，所以当放应用部署到生产环境时它们不会被部署；只有 gotest 会编译所有的程序：普通程序和测试程序。 测试文件中必须导入 “testing” 包，并写一些名字以TestZzz 打头的全局函数，这里的 Zzz是被测试函数的字母描述，如 TestFmtInterface，TestPayEmployees 等。 测试函数必须有这种形式的头部： 1func TestAbcde(t *testing.T) T 是传给测试函数的结构类型，用来管理测试状态，支持格式化测试日志，如 t.Log，t.Error，t.ErrorF 等。在函数的结尾把输出跟想要的结果对比，如果不等就打印一个错误。成功的测试则直接返回。 用下面这些函数来通知测试失败： 1) 标记测试函数为失败，然后继续执行（剩下的测试）。 1func (t *T) Fail() 2) 标记测试函数为失败并中止执行；文件中别的测试也被略过，继续执行下一个文件。 1func (t *T) FailNow() 3) args 被用默认的格式格式化并打印到错误日志中。 1func (t *T) Log(args ...interface&#123;&#125;) 4) 结合 先执行 3），然后执行 2）的效果。 1func (t *T) Fatal(args ...interface&#123;&#125;) 运行 go test来编译测试程序，并执行程序中所有的TestZZZ 函数。如果所有的测试都通过会打印出 PASS。 gotest 可以接收一个或多个函数程序作为参数，并指定一些选项。 结合 --chatty 或 -v 选项，每个执行的测试函数以及测试状态会被打印。 testing包中有一些类型和函数可以用来做简单的基准测试；测试代码中必须包含以 BenchmarkZzz打头的函数并接收一个 *testing.B类型的参数，比如： 123func BenchmarkReverse(b *testing.B) &#123; ...&#125; 命令 go test –test.bench=.* 会运行所有的基准测试函数；代码中的函数会被调用 N 次（N是非常大的数，如 N = 1000000），并展示 N 的值和函数执行的平均时间，单位为 ns（纳秒，ns/op）。如果是用 testing.Benchmark调用这些函数，直接运行程序即可。]]></content>
      <categories>
        <category>The Way to Go</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Way to Go（六）]]></title>
    <url>%2F2018%2F06%2F04%2FThe-Way-to-Go%EF%BC%88%E5%85%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[读写数据读取用户的输入从键盘和标准输入 os.Stdin 读取输入，最简单的办法是使用fmt 包提供的Scan 和Sscan 开头的函数。请看以下程序： 123456789101112131415161718192021// 从控制台读取输入:package mainimport "fmt"var ( firstName, lastName, s string i int f float32 input = "56.12 / 5212 / Go" format = "%f / %d / %s")func main() &#123; fmt.Println("Please enter your full name: ") fmt.Scanln(&amp;firstName, &amp;lastName) // fmt.Scanf("%s %s", &amp;firstName, &amp;lastName) fmt.Printf("Hi %s %s!\n", firstName, lastName) // Hi Chris Naegels fmt.Sscanf(input, format, &amp;f, &amp;i, &amp;s) fmt.Println("From the string we read: ", f, i, s) // 输出结果: From the string we read: 56.12 5212 Go&#125; Scanln扫描来自标准输入的文本，将空格分隔的值依次存放到后续的参数内，直到碰到换行。Scanf与其类似，除了 Scanf 的第一个参数用作格式字符串，用来决定如何读取。Sscan 和以 Sscan 开头的函数则是从字符串读取，除此之外，与 Scanf 相同。如果这些函数读取到的结果与您预想的不同，您可以检查成功读入数据的个数和返回的错误。 文件读写123456789101112131415161718192021222324252627package mainimport ( "bufio" "fmt" "io" "os")func main() &#123; inputFile, inputError := os.Open("input.dat") if inputError != nil &#123; fmt.Printf("An error occurred on opening the inputfile\n" + "Does the file exist?\n" + "Have you got acces to it?\n") return // exit the function on error &#125; defer inputFile.Close() inputReader := bufio.NewReader(inputFile) for &#123; inputString, readerError := inputReader.ReadString('\n') fmt.Printf("The input was: %s", inputString) if readerError == io.EOF &#123; return &#125; &#125;&#125; 变量 inputFile 是 *os.File 类型的。该类型是一个结构，表示一个打开文件的描述符（文件句柄）。然后，使用 os 包里的Open 函数来打开一个文件。该函数的参数是文件名，类型为 string。在上面的程序中，我们以只读模式打开input.dat 文件。 如果文件不存在或者程序没有足够的权限打开这个文件，Open函数会返回一个错误：inputFile, inputError = os.Open(&quot;input.dat&quot;)。如果文件打开正常，我们就使用defer inputFile.Close() 语句确保在程序退出前关闭该文件。然后，我们使用 bufio.NewReader来获得一个读取器变量。 通过使用 bufio包提供的读取器（写入器也类似），如上面程序所示，我们可以很方便的操作相对高层的 string 对象，而避免了去操作比较底层的字节。 接着，我们在一个无限循环中使用ReadString(&#39;\n&#39;) 或 ReadBytes(&#39;\n&#39;)将文件的内容逐行（行结束符 ‘\n’）读取出来。 一旦读取到文件末尾，变量readerError 的值将变成非空（事实上，常量io.EOF 的值是 true），我们就会执行 return语句从而退出循环。 其他类似函数：1) 将整个文件的内容读到一个字符串里： 如果您想这么做，可以使用 io/ioutil包里的 ioutil.ReadFile()方法，该方法第一个返回值的类型是 []byte，里面存放读取到的内容，第二个返回值是错误，如果没有错误发生，第二个返回值为 nil。类似的，函数 WriteFile() 可以将 []byte 的值写入文件。 123456789101112131415161718192021package mainimport ( "fmt" "io/ioutil" "os")func main() &#123; inputFile := "products.txt" outputFile := "products_copy.txt" buf, err := ioutil.ReadFile(inputFile) if err != nil &#123; fmt.Fprintf(os.Stderr, "File Error: %s\n", err) // panic(err.Error()) &#125; fmt.Printf("%s\n", string(buf)) err = ioutil.WriteFile(outputFile, buf, 0644) // oct, not hex if err != nil &#123; panic(err.Error()) &#125;&#125; 2) 带缓冲的读取 在很多情况下，文件的内容是不按行划分的，或者干脆就是一个二进制文件。在这种情况下，ReadString()就无法使用了，我们可以使用 bufio.Reader 的Read()，它只接收一个参数：1234buf := make([]byte, 1024)...n, err := inputReader.Read(buf)if (n == 0) &#123; break&#125; 变量 n 的值表示读取到的字节数. 3) 按列读取文件中的数据如果数据是按列排列并用空格分隔的，你可以使用 fmt包提供的以 FScan开头的一系列函数来读取他们。请看以下程序，我们将 3 列的数据分别读入变量 v1、v2 和 v3 内，然后分别把他们添加到切片的尾部。 123456789101112131415161718192021222324252627282930package mainimport ( "fmt" "os")func main() &#123; file, err := os.Open("products2.txt") if err != nil &#123; panic(err) &#125; defer file.Close() var col1, col2, col3 []string for &#123; var v1, v2, v3 string _, err := fmt.Fscanln(file, &amp;v1, &amp;v2, &amp;v3) // scans until newline if err != nil &#123; break &#125; col1 = append(col1, v1) col2 = append(col2, v2) col3 = append(col3, v3) &#125; fmt.Println(col1) fmt.Println(col2) fmt.Println(col3)&#125; 输出结果：123[ABC FUNC GO][40 56 45][150 280 356] 注意： path 包里包含一个子包叫 filepath，这个子包提供了跨平台的函数，用于处理文件名和路径。例如 Base()函数用于获得路径中的最后一个元素（不包含后面的分隔符）：12import "path/filepath"filename := filepath.Base(path) 12345678910111213141516171819202122232425262728package mainimport ( "os" "bufio" "fmt")func main () &#123; // var outputWriter *bufio.Writer // var outputFile *os.File // var outputError os.Error // var outputString string outputFile, outputError := os.OpenFile("output.dat", os.O_WRONLY|os.O_CREATE, 0666) if outputError != nil &#123; fmt.Printf("An error occurred with file opening or creation\n") return &#125; defer outputFile.Close() outputWriter := bufio.NewWriter(outputFile) outputString := "hello world!\n" for i:=0; i&lt;10; i++ &#123; outputWriter.WriteString(outputString) &#125; outputWriter.Flush()&#125; 除了文件句柄，我们还需要 bufio 的 Writer。我们以只写模式打开文件 output.dat，如果文件不存在则自动创建： 1outputFile, outputError := os.OpenFile(“output.dat”, os.O_WRONLY|os.O_CREATE, 0666) 可以看到，OpenFile 函数有三个参数：文件名、一个或多个标志（使用逻辑运算符“|”连接），使用的文件权限。 我们通常会用到以下标志： os.O_RDONLY：只读 os.O_WRONLY：只写 os.O_CREATE：创建：如果指定文件不存在，就创建该文件。 os.O_TRUNC：截断：如果指定文件已存在，就将该文件的长度截为0。 在读文件的时候，文件的权限是被忽略的，所以在使用 OpenFile 时传入的第三个参数可以用0。而在写文件时，不管是 Unix 还是 Windows，都需要使用 0666。 然后，我们创建一个写入器（缓冲区）对象： 1outputWriter := bufio.NewWriter(outputFile) 接着，使用一个 for 循环，将字符串写入缓冲区，写 10 次：outputWriter.WriteString(outputString) 缓冲区的内容紧接着被完全写入文件：outputWriter.Flush() 如果写入的东西很简单，我们可以使用 fmt.Fprintf(outputFile, “Some test data.\n”)直接将内容写入文件。fmt 包里的 F 开头的Print 函数可以直接写入任何io.Writer，包括文件 不使用 fmt.FPrintf 函数，使用其他函数如何写文件：12345678910package mainimport "os"func main() &#123; os.Stdout.WriteString("hello, world\n") f, _ := os.OpenFile("test", os.O_CREATE|os.O_WRONLY, 0) defer f.Close() f.WriteString("hello, world in a file\n")&#125; 使用 os.Stdout.WriteString(“hello, world\n”)，我们可以输出到屏幕。 我们以只写模式创建或打开文件“test”，并且忽略了可能发生的错误：f, _ := os.OpenFile(“test”, os.O_CREATE|os.O_WRONLY, 0) 我们不使用缓冲区，直接将内容写入文件：f.WriteString( ) 文件拷贝12345678910111213141516171819202122232425262728package mainimport ( "fmt" "io" "os")func main() &#123; CopyFile("target.txt", "source.txt") fmt.Println("Copy done!")&#125;func CopyFile(dstName, srcName string) (written int64, err error) &#123; src, err := os.Open(srcName) if err != nil &#123; return &#125; defer src.Close() dst, err := os.OpenFile(dstName, os.O_WRONLY|os.O_CREATE, 0644) if err != nil &#123; return &#125; defer dst.Close() return io.Copy(dst, src)&#125; 注意defer 的使用：当打开目标文件时发生了错误，那么 defer 仍然能够确保 src.Close() 执行。如果不这么做，文件会一直保持打开状态并占用资源。 从命令行读取参数os 包中有一个 string类型的切片变量 os.Args，用来处理一些基本的命令行参数，它在程序启动后读取命令行输入的参数。 123456789101112131415package mainimport ( "fmt" "os" "strings")func main() &#123; who := "Alice " if len(os.Args) &gt; 1 &#123; who += strings.Join(os.Args[1:], " ") &#125; fmt.Println("Good Morning", who)&#125; 我们在 IDE 或编辑器中直接运行这个程序输出：Good Morning Alice flag包flag 包有一个扩展功能用来解析命令行选项。但是通常被用来替换基本常量，例如，在某些情况下我们希望在命令行给常量一些不一样的值。 下面的程序模拟了 Unix 的 echo 功能： 1234567891011121314151617181920212223242526272829package mainimport ( "flag" // command line option parser "os")var NewLine = flag.Bool("n", false, "print newline") // echo -n flag, of type *boolconst ( Space = " " Newline = "\n")func main() &#123; flag.PrintDefaults() flag.Parse() // Scans the arg list and sets up flags var s string = "" for i := 0; i &lt; flag.NArg(); i++ &#123; if i &gt; 0 &#123; s += " " if *NewLine &#123; // -n is parsed, flag becomes true s += Newline &#125; &#125; s += flag.Arg(i) &#125; os.Stdout.WriteString(s)&#125; flag.Parse() 扫描参数列表（或者常量列表）并设置flag, flag.Arg(i)表示第i个参数。Parse() 之后flag.Arg(i) 全部可用，flag.Arg(0) 就是第一个真实的 flag，而不是像 os.Args(0)放置程序的名字。 flag.Narg()返回参数的数量。解析后 flag或常量就可用了。flag.Bool()定义了一个默认值是 false的 flag：当在命令行出现了第一个参数（这里是 “n”），flag 被设置成 true（NewLine 是 bool 类型）。flag被解引用到 `NewLine，所以当值是 true 时将添加一个 newline（”\n”）`。 flag.PrintDefaults()打印 flag 的使用帮助信息，本例中打印的是：1-n=false: print newline flag.VisitAll(fn func(*Flag)) 是另一个有用的功能：按照字典顺序遍历 flag，并且对每个标签调用 fn 用 buffer 读取文件1234567891011121314151617181920212223242526272829303132333435package mainimport ( "bufio" "flag" "fmt" "io" "os")func cat(r *bufio.Reader) &#123; for &#123; buf, err := r.ReadBytes('\n') if err == io.EOF &#123; break &#125; fmt.Fprintf(os.Stdout, "%s", buf) &#125; return&#125;func main() &#123; flag.Parse() if flag.NArg() == 0 &#123; cat(bufio.NewReader(os.Stdin)) &#125; for i := 0; i &lt; flag.NArg(); i++ &#123; f, err := os.Open(flag.Arg(i)) if err != nil &#123; fmt.Fprintf(os.Stderr, "%s:error reading from %s: %s\n", os.Args[0], flag.Arg(i), err.Error()) continue &#125; cat(bufio.NewReader(f)) &#125;&#125; JSON 数据格式数据结构要在网络中传输或保存到文件，就必须对其编码和解码；目前存在很多编码格式：JSON，XML，gob，Google 缓冲协议等等。Go 语言支持所有这些编码格式 通过把数据转换成纯文本，使用命名的字段来标注，让其具有可读性。这样的数据格式可以通过网络传输，而且是与平台无关的，任何类型的应用都能够读取和输出，不与操作系统和编程语言的类型相关。 序列化是在内存中把数据转换成指定格式（data -&gt; string），反之亦然（string -&gt; data structure） 尽管 XML 被广泛的应用，但是 JSON 更加简洁、轻量（占用更少的内存、磁盘及网络带宽）和更好的可读性，这也使它越来越受欢迎。 123456789101112131415161718192021222324252627282930313233343536373839package mainimport ( "encoding/json" "fmt" "log" "os")type Address struct &#123; Type string City string Country string&#125;type VCard struct &#123; FirstName string LastName string Addresses []*Address Remark string&#125;func main() &#123; pa := &amp;Address&#123;"private", "Aartselaar", "Belgium"&#125; wa := &amp;Address&#123;"work", "Boom", "Belgium"&#125; vc := VCard&#123;"Jan", "Kersschot", []*Address&#123;pa, wa&#125;, "none"&#125; // fmt.Printf("%v: \n", vc) // &#123;Jan Kersschot [0x126d2b80 0x126d2be0] none&#125;: // JSON format: js, _ := json.Marshal(vc) fmt.Printf("JSON format: %s", js) // using an encoder: file, _ := os.OpenFile("vcard.json", os.O_CREATE|os.O_WRONLY, 0666) defer file.Close() enc := json.NewEncoder(file) err := enc.Encode(vc) if err != nil &#123; log.Println("Error in encoding json") &#125;&#125; json.Marshal() 的函数签名是 func Marshal(v interface{}) ([]byte, error)，下面是数据编码后的 JSON 文本（实际上是一个 []byte）： 1234567891011121314&#123; "FirstName": "Jan", "LastName": "Kersschot", "Addresses": [&#123; "Type": "private", "City": "Aartselaar", "Country": "Belgium" &#125;, &#123; "Type": "work", "City": "Boom", "Country": "Belgium" &#125;], "Remark": "none"&#125; 出于安全考虑，在 web 应用中最好使用json.MarshalforHTML() 函数，其对数据执行HTML转码，所以文本可以被安全地嵌在 HTML &lt;script&gt; 标签中。 json.NewEncoder() 的函数签名是 func NewEncoder(w io.Writer) *Encoder，返回的Encoder类型的指针可调用方法 Encode(v interface{})，将数据对象v 的json编码写入 io.Writerw 中。 不是所有的数据都可以编码为 JSON 类型：只有验证通过的数据结构才能被编码： JSON 对象只支持字符串类型的 key；要编码一个 Go map 类型，map必须是 map[string]T（T是 json 包中支持的任何类型） Channel，复杂类型和函数类型不能被编码 不支持循环数据结构；它将引起序列化进入一个无限循环 指针可以被编码，实际上是对指针指向的值进行编码（或者指针是 nil） 反序列化： UnMarshal() 的函数签名是func Unmarshal(data []byte, v interface{}) error把 JSON 解码为数据结构。 解码任意的数据： json 包使用 map[string]interface{}和[]interface{} 储存任意的 JSON 对象和数组；其可以被反序列化为任何的 JSON blob 存储到接口值中。 来看这个 JSON 数据，被存储在变量 b 中： 1b := []byte(`&#123;"Name": "Wednesday", "Age": 6, "Parents": ["Gomez", "Morticia"]&#125;`) 不用理解这个数据的结构，我们可以直接使用 Unmarshal 把这个数据编码并保存在接口值中： 12var f interface&#123;&#125;err := json.Unmarshal(b, &amp;f) f 指向的值是一个map，key 是一个字符串，value 是自身存储作为空接口类型的值： 12345678map[string]interface&#123;&#125; &#123; "Name": "Wednesday", "Age": 6, "Parents": []interface&#123;&#125; &#123; "Gomez", "Morticia", &#125;,&#125; 要访问这个数据，我们可以使用类型断言 1m := f.(map[string]interface&#123;&#125;)]]></content>
      <categories>
        <category>The Way to Go</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Way to Go（五）]]></title>
    <url>%2F2018%2F06%2F04%2FThe-Way-to-Go%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[接口接口是什么Go 语言不是一种 “传统” 的面向对象编程语言：它里面没有类和继承的概念。 但是 Go 语言里有非常灵活的 接口 概念，通过它可以实现很多面向对象的特性。接口提供了一种方式来 说明 对象的行为：如果谁能搞定这件事，它就可以用在这儿。 接口定义了一组方法（方法集），但是这些方法不包含（实现）代码：它们没有被实现（它们是抽象的）。接口里也不能包含变量。 通过如下格式定义接口： 12345type Namer interface &#123; Method1(param_list) return_type Method2(param_list) return_type ...&#125; 上面的 Namer 是一个 接口类型。 按照约定，只包含一个方法的）接口的名字由方法名加 [e]r 后缀组成，例如 Printer、Reader、Writer、Logger、Converter 等等。还有一些不常用的方式（当后缀 er 不合适时），比如 Recoverable，此时接口名以 able 结尾，或者以 I 开头（像 .NET 或 Java 中那样）。 Go 语言中的接口都很简短，通常它们会包含 0 个、最多 3 个方法。 不像大多数面向对象编程语言，在 Go 语言中接口可以有值，一个接口类型的变量或一个 接口值 ：var ai Namer，ai 是一个多字（multiword）数据结构，它的值是 nil。它本质上是一个指针，虽然不完全是一回事。指向接口值的指针是非法的，它们不仅一点用也没有，还会导致代码错误。 类型不需要显式声明它实现了某个接口：接口被隐式地实现。多个类型可以实现同一个接口。 实现某个接口的类型（除了实现接口方法外）可以有其他的方法。 一个类型可以实现多个接口。 接口类型可以包含一个实例的引用， 该实例的类型实现了此接口（接口是动态类型）。 即使接口在类型之后才定义，二者处于不同的包中，被单独编译：只要类型实现了接口中的方法，它就实现了此接口。 12345678910111213141516171819202122232425262728package mainimport "fmt"type Shaper interface &#123; Area() float32&#125;type Square struct &#123; side float32&#125;func (sq *Square) Area() float32 &#123; return sq.side * sq.side&#125;func main() &#123; sq1 := new(Square) sq1.side = 5 var areaIntf Shaper areaIntf = sq1 // shorter,without separate declaration: // areaIntf := Shaper(sq1) // or even: // areaIntf := sq1 fmt.Printf("The square has area: %f\n", areaIntf.Area())&#125; 输出：1The square has area: 25.000000 上面的程序定义了一个结构体 Square 和一个接口 Shaper，接口有一个方法 Area()。 在 main() 方法中创建了一个Square 的实例。在主程序外边定义了一个接收者类型是 Square 方法的 Area()，用来计算正方形的面积：结构体 Square 实现了接口 Shaper 。 所以可以将一个 Square 类型的变量赋值给一个接口类型的变量：areaIntf = sq1。 现在接口变量包含一个指向 Square 变量的引用，通过它可以调用 Square 上的方法 Area()。当然也可以直接在 Square 的实例上调用此方法，但是在接口实例上调用此方法更令人兴奋，它使此方法更具有一般性。接口变量里包含了接收者实例的值和指向对应方法表的指针。 这是 多态 的 Go 版本，多态是面向对象编程中一个广为人知的概念：根据当前的类型选择正确的方法，或者说：同一种类型在不同的实例上似乎表现出不同的行为。 如果 Square 没有实现Area() 方法，编译器将会给出清晰的错误信息： 12cannot use sq1 (type *Square) as type Shaper in assignment:*Square does not implement Shaper (missing Area method) 如果 Shaper 有另外一个方法 Perimeter()，但是Square 没有实现它，即使没有人在 Square 实例上调用这个方法，编译器也会给出上面同样的错误。 类型断言：如何检测和转换接口变量的类型一个接口类型的变量 varI 中可以包含任何类型的值，必须有一种方式来检测它的 动态 类型，即运行时在变量中存储的值的实际类型。在执行过程中动态类型可能会有所不同，但是它总是可以分配给接口变量本身的类型。通常我们可以使用 类型断言 来测试在某个时刻 varI 是否包含类型 T 的值： 1v := varI.(T) // unchecked type assertion varI 必须是一个接口变量，否则编译器会报错：invalid type assertion: varI.(T) (non-interface type (type of varI) on left) 。 类型断言可能是无效的，虽然编译器会尽力检查转换是否有效，但是它不可能预见所有的可能性。如果转换在程序运行时失败会导致错误发生。更安全的方式是使用以下形式来进行类型断言：12345if v, ok := varI.(T); ok &#123; // checked type assertion Process(v) return&#125;// varI is not of type T 如果转换合法，v 是 varI 转换到类型 T的值，ok会是 true；否则v是类型 T 的零值，ok 是 false，也没有运行时错误发生。 多数情况下，我们可能只是想在if中测试一下ok 的值，此时使用以下的方法会是最方便的：123if _, ok := varI.(T); ok &#123; // ...&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport ( "fmt" "math")type Square struct &#123; side float32&#125;type Circle struct &#123; radius float32&#125;type Shaper interface &#123; Area() float32&#125;func main() &#123; var areaIntf Shaper sq1 := new(Square) sq1.side = 5 areaIntf = sq1 // Is Square the type of areaIntf? if t, ok := areaIntf.(*Square); ok &#123; fmt.Printf("The type of areaIntf is: %T\n", t) &#125; if u, ok := areaIntf.(*Circle); ok &#123; fmt.Printf("The type of areaIntf is: %T\n", u) &#125; else &#123; fmt.Println("areaIntf does not contain a variable of type Circle") &#125;&#125;func (sq *Square) Area() float32 &#123; return sq.side * sq.side&#125;func (ci *Circle) Area() float32 &#123; return ci.radius * ci.radius * math.Pi&#125; 输出：123The type of areaIntf is: *main.SquareareaIntf does not contain a variable of type Circle 程序行中定义了一个新类型 Circle，它也实现了 Shaper 接口。 t, ok := areaIntf.(*Square); ok 测试areaIntf 里是否一个包含 ‘Square’ 类型的变量，结果是确定的；然后我们测试它是否包含一个 ‘Circle’ 类型的变量，结果是否定的。 备注 如果忽略 areaIntf.(*Square)中的* 号，会导致编译错误：impossible type assertion: Square does not implement Shaper (Area method has pointer receiver)。 接口变量的类型也可以使用一种特殊形式的 switch 来检测：type-switch12345678910switch t := areaIntf.(type) &#123;case *Square: fmt.Printf("Type Square %T with value %v\n", t, t)case *Circle: fmt.Printf("Type Circle %T with value %v\n", t, t)case nil: fmt.Printf("nil value: nothing to check?\n")default: fmt.Printf("Unexpected type %T\n", t)&#125; 输出：1Type Square *main.Square with value &amp;&#123;5&#125; 变量 t 得到了areaIntf的值和类型， 所有case 语句中列举的类型（nil 除外）都必须实现对应的接口（在上例中即 Shaper），如果被检测类型没有在 case 语句列举的类型中，就会执行 default 语句。 可以用 type-switch 进行运行时类型分析，但是在 type-switch 不允许有fallthrough 。 如果仅仅是测试变量的类型，不用它的值，那么就可以不需要赋值语句，比如：123456789switch areaIntf.(type) &#123;case *Square: // TODOcase *Circle: // TODO...default: // TODO&#125; 使用方法集与接口作用于变量上的方法实际上是不区分变量到底是指针还是值的。当碰到接口类型值时，这会变得有点复杂，原因是接口变量中存储的具体值是不可寻址的，幸运的是，如果使用不当编译器会给出错误。考虑下面的程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package mainimport ( "fmt")type List []intfunc (l List) Len() int &#123; return len(l)&#125;func (l *List) Append(val int) &#123; *l = append(*l, val)&#125;type Appender interface &#123; Append(int)&#125;func CountInto(a Appender, start, end int) &#123; for i := start; i &lt;= end; i++ &#123; a.Append(i) &#125;&#125;type Lener interface &#123; Len() int&#125;func LongEnough(l Lener) bool &#123; return l.Len()*10 &gt; 42&#125;func main() &#123; // A bare value var lst List // compiler error: // cannot use lst (type List) as type Appender in argument to CountInto: // List does not implement Appender (Append method has pointer receiver) // CountInto(lst, 1, 10) if LongEnough(lst) &#123; // VALID:Identical receiver type fmt.Printf("- lst is long enough\n") &#125; // A pointer value plst := new(List) CountInto(plst, 1, 10) //VALID:Identical receiver type if LongEnough(plst) &#123; // VALID: a *List can be dereferenced for the receiver fmt.Printf("- plst is long enough\n") &#125;&#125; 讨论 在 lst 上调用 CountInto 时会导致一个编译器错误，因为 CountInto 需要一个Appender，而它的方法Append 只定义在指针上。 在 lst上调用LongEnough是可以的因为 ‘Len’ 定义在值上。 在plst 上调用CountInto是可以的，因为CountInto 需要一个 Appender，并且它的方法 Append 定义在指针上。 在 plst上调用 LongEnough 也是可以的，因为指针会被自动解引用。 总结 在接口上调用方法时，必须有和方法定义时相同的接收者类型或者是可以从具体类型 P 直接可以辨识的： 指针方法可以通过指针调用 值方法可以通过值调用 接收者是值的方法可以通过指针调用，因为指针会首先被解引用 接收者是指针的方法不可以通过值调用，因为存储在接口中的值没有地址 将一个值赋值给一个接口时，编译器会确保所有可能的接口方法都可以在此值上被调用，因此不正确的赋值在编译期就会失败。 反射反射是用程序检查其所拥有的结构，尤其是类型的一种能力；这是元编程的一种形式。反射可以在运行时检查类型和变量，例如它的大小、方法和 动态 变量的最基本信息就是类型和值：反射包的 Type用来表示一个 Go 类型，反射包的 Value 为 Go 值提供了反射接口。 两个简单的函数，reflect.TypeOf 和 reflect.ValueOf，返回被检查对象的类型和值。例如，x 被定义为：var x float64 = 3.4，那么 reflect.TypeOf(x)返回 float64，reflect.ValueOf(x) 返回 &lt;float64 Value&gt; 1234567891011121314151617181920package mainimport ( "fmt" "reflect")func main() &#123; var x float64 = 3.4 fmt.Println("type:", reflect.TypeOf(x)) v := reflect.ValueOf(x) fmt.Println("value:", v) fmt.Println("type:", v.Type()) fmt.Println("kind:", v.Kind()) fmt.Println("value:", v.Float()) fmt.Println(v.Interface()) fmt.Printf("value is %5.2e\n", v.Interface()) y := v.Interface().(float64) fmt.Println(y)&#125; 输出：12345678type: float64value: 3.4type: float64kind: float64value: 3.43.4value is 3.40e+003.4 x 是一个 float64 类型的值，reflect.ValueOf(x).Float() 返回这个 float64 类型的实际值；同样的适用于 Int(), Bool(), Complex(), String() 反射结构有些时候需要反射一个结构类型。NumField() 方法返回结构内的字段数量；通过一个 for 循环用索引取得每个字段的值 Field(i)。 我们同样能够调用签名在结构上的方法，例如，使用索引 n 来调用：Method(n).Call(nil)。]]></content>
      <categories>
        <category>The Way to Go</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Way to Go（四）]]></title>
    <url>%2F2018%2F05%2F27%2FThe-Way-to-Go%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[结构和方法结构体定义Go 通过类型别名（alias types）和结构体的形式支持用户自定义类型，或者叫定制类型。 组成结构体类型的那些数据称为 字段（fields）。每个字段都有一个类型和一个名字；在一个结构体中，字段名字必须是唯一的。 结构体是值类型，因此可以通过new 函数来创建。 结构体定义的一般方式如下： 12345type identifier struct &#123; field1 type1 field2 type2 ...&#125; type T struct {a, b int} 也是合法的语法，它更适用于简单的结构体。 结构体的字段可以是任何类型，甚至是结构体本身 ，也可以是函数或者接口 。可以声明结构体类型的一个变量，然后像下面这样给它的字段赋值： 123var s Ts.a = 5s.b = 8 使用 new使用 new 函数给一个新的结构体变量分配内存，它返回指向已分配内存的指针：var t *T = new(T)，如果需要可以把这条语句放在不同的行（比如定义是包范围的，但是分配却没有必要在开始就做）。 12var t *Tt = new(T) 写这条语句的惯用方法是：t := new(T)，变量 t 是一个指向 T的指针，此时结构体字段的值是它们所属类型的零值。 声明 var t T 也会给 t 分配内存，并零值化内存，但是这个时候 t 是类型T。在这两种方式中，t 通常被称做类型 T 的一个实例（instance）或对象（object）。 1234567891011121314151617181920package mainimport "fmt"type struct1 struct &#123; i1 int f1 float32 str string&#125;func main() &#123; ms := new(struct1) ms.i1 = 10 ms.f1 = 15.5 ms.str= "Chris" fmt.Printf("The int is: %d\n", ms.i1) fmt.Printf("The float is: %f\n", ms.f1) fmt.Printf("The string is: %s\n", ms.str) fmt.Println(ms)&#125; 输出：1234The int is: 10The float is: 15.500000The string is: Chris&amp;&#123;10 15.5 Chris&#125; 无论变量是一个结构体类型还是一个结构体类型指针，都使用同样的 选择器符（selector-notation）点号符 来引用结构体的字段： 12345type myStruct struct &#123; i int &#125;var v myStruct // v是结构体类型变量var p *myStruct // p是指向一个结构体类型变量的指针v.ip.i 初始化一个结构体实例（一个结构体字面量：struct-literal）的更简短和惯用的方式如下： 12ms := &amp;struct1&#123;10, 15.5, "Chris"&#125;// 此时ms的类型是 *struct1 或者12var ms struct1ms = struct1&#123;10, 15.5, "Chris"&#125; 混合字面量语法（composite literal syntax）&amp;struct1{a, b, c} 是一种简写，底层仍然会调用new ()，这里值的顺序必须按照字段顺序来写。 表达式 new(Type) 和 &amp;Type{} 是等价的。 使用结构体的一个典型例子：1234type Interval struct &#123; start int end int&#125; 初始化方式：123intr := Interval&#123;0, 3&#125; (A)intr := Interval&#123;end:5, start:1&#125; (B)intr := Interval&#123;end:5&#125; (C) 在（A）中，值必须以字段在结构体定义时的顺序给出，&amp; 不是必须的。（B）显示了另一种方式，字段名加一个冒号放在值的前面，这种情况下值的顺序不必一致，并且某些字段还可以被忽略掉，就像（C）中那样。 下图说明了结构体类型实例和一个指向它的指针的内存布局：1type Point struct &#123; x, y int &#125; 使用 new 初始化： 作为结构体字面量初始化： 下面的例子显示了一个结构体 Person，一个方法，方法有一个类型为 *Person 的参数（因此对象本身是可以被改变的），以及三种调用这个方法的不同方式： 12345678910111213141516171819202122232425262728293031323334353637package mainimport ( "fmt" "strings")type Person struct &#123; firstName string lastName string&#125;func upPerson(p *Person) &#123; p.firstName = strings.ToUpper(p.firstName) p.lastName = strings.ToUpper(p.lastName)&#125;func main() &#123; // 1-struct as a value type: var pers1 Person pers1.firstName = "Chris" pers1.lastName = "Woodward" upPerson(&amp;pers1) fmt.Printf("The name of the person is %s %s\n", pers1.firstName, pers1.lastName) // 2—struct as a pointer: pers2 := new(Person) pers2.firstName = "Chris" pers2.lastName = "Woodward" (*pers2).lastName = "Woodward" // 这是合法的 upPerson(pers2) fmt.Printf("The name of the person is %s %s\n", pers2.firstName, pers2.lastName) // 3—struct as a literal: pers3 := &amp;Person&#123;"Chris","Woodward"&#125; upPerson(pers3) fmt.Printf("The name of the person is %s %s\n", pers3.firstName, pers3.lastName)&#125; 输出：123The name of the person is CHRIS WOODWARDThe name of the person is CHRIS WOODWARDThe name of the person is CHRIS WOODWARD 在上面例子的第二种情况中，可以直接通过指针，像 pers2.lastName=&quot;Woodward&quot; 这样给结构体字段赋值，没有像 C++ 中那样需要使用 -&gt; 操作符，Go 会自动做这样的转换。 注意也可以通过解指针的方式来设置值：(*pers2).lastName = &quot;Woodward&quot; 结构体的内存布局12type Rect1 struct &#123;Min, Max Point &#125;type Rect2 struct &#123;Min, Max *Point &#125; 结构体转换Go 中的类型转换遵循严格的规则。当为结构体定义了一个 alias 类型时，此结构体类型和它的 alias 类型都有相同的底层类型，同时需要注意其中非法赋值或转换引起的编译错误。 12345678910111213141516171819package mainimport "fmt"type number struct &#123; f float32&#125;type nr number // alias typefunc main() &#123; a := number&#123;5.0&#125; b := nr&#123;5.0&#125; // var i float32 = b // compile-error: cannot use b (type nr) as type float32 in assignment // var i = float32(b) // compile-error: cannot convert b (type nr) to type float32 // var c number = b // compile-error: cannot use b (type nr) as type number in assignment // needs a conversion: var c = number(b) fmt.Println(a, b, c)&#125; 输出：1&#123;5&#125; &#123;5&#125; &#123;5&#125; 使用自定义包中的结构体下面的例子中，main.go 使用了一个结构体，它来自 struct_pack 下的包 structPack。 1234567# structPack.gopackage structPacktype ExpStruct struct &#123; Mi1 int Mf1 float32&#125; 12345678910111213141516# main.go：package mainimport ( "fmt" "./struct_pack/structPack")func main() &#123; struct1 := new(structPack.ExpStruct) struct1.Mi1 = 10 struct1.Mf1 = 16. fmt.Printf("Mi1 = %d\n", struct1.Mi1) fmt.Printf("Mf1 = %f\n", struct1.Mf1)&#125; 输出：12Mi1 = 10Mf1 = 16.000000 带标签的结构体结构体中的字段除了有名字和类型外，还可以有一个可选的标签（tag）：它是一个附属于字段的字符串，可以是文档或其他的重要标记。 标签的内容不可以在一般的编程中使用，只有包 reflect 能获取它。它可以在运行时自省类型、属性和方法，比如：在一个变量上调用 reflect.TypeOf() 可以获取变量的正确类型，如果变量是一个结构体类型，就可以通过 Field 来索引结构体的字段，然后就可以使用 Tag 属性。 12345678910111213141516171819202122232425package mainimport ( "fmt" "reflect")type TagType struct &#123; // tags field1 bool "An important answer" field2 string "The name of the thing" field3 int "How much there are"&#125;func main() &#123; tt := TagType&#123;true, "Barak Obama", 1&#125; for i := 0; i &lt; 3; i++ &#123; refTag(tt, i) &#125;&#125;func refTag(tt TagType, ix int) &#123; ttType := reflect.TypeOf(tt) ixField := ttType.Field(ix) fmt.Printf("%v\n", ixField.Tag)&#125; 输出：123An important answerThe name of the thingHow much there are 匿名字段和内嵌结构体结构体可以包含一个或多个 匿名（或内嵌）字段，即这些字段没有显式的名字，只有字段的类型是必须的，此时类型就是字段的名字。匿名字段本身可以是一个结构体类型，即 结构体可以包含内嵌结构体。 可以粗略地将这个和面向对象语言中的继承概念相比较，随后将会看到它被用来模拟类似继承的行为。Go 语言中的继承是通过内嵌或组合来实现的，所以可以说，在 Go 语言中，相比较于继承，组合更受青睐。 内层结构体被简单的插入或者内嵌进外层结构体。这个简单的“继承”机制提供了一种方式，使得可以从另外一个或一些类型继承部分或全部实现。 123456789101112131415161718package mainimport "fmt"type A struct &#123; ax, ay int&#125;type B struct &#123; A bx, by float32&#125;func main() &#123; b := B&#123;A&#123;1, 2&#125;, 3.0, 4.0&#125; fmt.Println(b.ax, b.ay, b.bx, b.by) fmt.Println(b.A)&#125; 输出： 121 2 3 4&#123;1 2&#125; 方法什么是方法在 Go 语言中，结构体就像是类的一种简化形式，Go 方法是作用在接收者（receiver）上的一个函数，接收者是某种类型的变量。因此方法是一种特殊类型的函数。 接收者类型可以是（几乎）任何类型，不仅仅是结构体类型：任何类型都可以有方法，甚至可以是函数类型，可以是 int、bool、string 或数组的别名类型。但是接收者不能是一个接口类型，因为接口是一个抽象定义。 最后接收者不能是一个指针类型，但是它可以是任何其他允许类型的指针。 一个类型加上它的方法等价于面向对象中的一个类。一个重要的区别是：在 Go 中，类型的代码和绑定在它上面的方法的代码可以不放置在一起，它们可以存在在不同的源文件，唯一的要求是：它们必须是同一个包的。 类型 T（或 *T）上的所有方法的集合叫做类型 T（或 *T）的方法集。 定义方法的一般格式如下： 1func (recv receiver_type) methodName(parameter_list) (return_value_list) &#123; ... &#125; 在方法名之前，func 关键字之后的括号中指定 receiver。 如果 recv 是 receiver 的实例，Method1 是它的方法名，那么方法调用遵循传统的 object.name 选择器符号：recv.Method1()。 如果 recv 一个指针，Go 会自动解引用。 如果方法不需要使用 recv 的值，可以用 _ 替换它，比如： 1func (_ receiver_type) methodName(parameter_list) (return_value_list) &#123; ... &#125; recv 就像是面向对象语言中的 this 或 self，但是 Go 中并没有这两个关键字。随个人喜好，你可以使用 this 或 self 作为 receiver 的名字。 下面是一个结构体上的简单方法的例子： 12345678910111213141516171819202122232425262728package mainimport "fmt"type TwoInts struct &#123; a int b int&#125;func main() &#123; two1 := new(TwoInts) two1.a = 12 two1.b = 10 fmt.Printf("The sum is: %d\n", two1.AddThem()) fmt.Printf("Add them to the param: %d\n", two1.AddToParam(20)) two2 := TwoInts&#123;3, 4&#125; fmt.Printf("The sum is: %d\n", two2.AddThem())&#125;func (tn *TwoInts) AddThem() int &#123; return tn.a + tn.b&#125;func (tn *TwoInts) AddToParam(param int) int &#123; return tn.a + tn.b + param&#125; 输出：123The sum is: 22Add them to the param: 42The sum is: 7 下面是非结构体类型上方法的例子： 12345678910111213141516package mainimport "fmt"type IntVector []intfunc (v IntVector) Sum() (s int) &#123; for _, x := range v &#123; s += x &#125; return&#125;func main() &#123; fmt.Println(IntVector&#123;1, 2, 3&#125;.Sum()) // 输出是6&#125; 函数个方法的区别函数将变量作为参数：Function1(recv) 方法在变量上被调用：recv.Method1() 在接收者是指针时，方法可以改变接收者的值（或状态），这点函数也可以做到（当参数作为指针传递，即通过引用调用时，函数也可以改变参数的状态）。 接收者必须有一个显式的名字，这个名字必须在方法中被使用。 receiver_type 叫做 （接收者）基本类型，这个类型必须在和方法同样的包中被声明。 在 Go 中，（接收者）类型关联的方法不写在类型结构里面，就像类那样；耦合更加宽松；类型和方法之间的关联由接收者来建立。 方法没有和数据定义（结构体）混在一起：它们是正交的类型；表示（数据）和行为（方法）是独立的。 指针或值作为接收者鉴于性能的原因，recv 最常见的是一个指向 receiver_type 的指针（因为我们不想要一个实例的拷贝，如果按值调用的话就会是这样），特别是在 receiver 类型是结构体时，就更是如此了。 如果想要方法改变接收者的数据，就在接收者的指针类型上定义该方法。否则，就在普通的值类型上定义方法。 下面的例子中，change()接受一个指向 B 的指针，并改变它内部的成员；write() 接受通过拷贝接受 B 的值并只输出B的内容。注意 Go 为我们做了探测工作，我们自己并没有指出是否在指针上调用方法，Go 替我们做了这些事情。b1 是值而b2 是指针，方法都支持运行了。 12345678910111213141516171819202122232425262728package mainimport ( "fmt")type B struct &#123; thing int&#125;func (b *B) change() &#123; b.thing = 1 &#125;func (b B) write() string &#123; return fmt.Sprint(b) &#125;func main() &#123; var b1 B // b1是值 b1.change() fmt.Println(b1.write()) b2 := new(B) // b2是指针 b2.change() fmt.Println(b2.write())&#125;/* 输出：&#123;1&#125;&#123;1&#125;*/ 试着在write() 中改变接收者b的值：将会看到它可以正常编译，但是开始的 b 没有被改变。 我们知道方法将指针作为接收者不是必须的，如下面的例子，我们只是需要 Point3 的值来做计算： 12345type Point3 struct &#123; x, y, z float64 &#125;// A method on Point3func (p Point3) Abs() float64 &#123; return math.Sqrt(p.x*p.x + p.y*p.y + p.z*p.z)&#125; 这样做稍微有点昂贵，因为 Point3 是作为值传递给方法的，因此传递的是它的拷贝，这在 Go 中合法的。也可以在指向这个类型的指针上调用此方法（会自动解引用）。 假设 p3 定义为一个指针：p3 := &amp;Point{ 3, 4, 5}。 可以使用 p3.Abs() 来替代 (*p3).Abs()。 在值和指针上调用方法： 可以有连接到类型的方法，也可以有连接到类型指针的方法。 但是这没关系：对于类型 T，如果在 *T 上存在方法 Meth()，并且 t 是这个类型的变量，那么 t.Meth() 会被自动转换为 (&amp;t).Meth()。 指针方法和值方法都可以在指针或非指针上被调用，如下面程序所示，类型 List 在值上有一个方法 Len()，在指针上有一个方法 Append()，但是可以看到两个方法都可以在两种类型的变量上被调用。 12345678910111213141516171819202122package mainimport ( "fmt")type List []intfunc (l List) Len() int &#123; return len(l) &#125;func (l *List) Append(val int) &#123; *l = append(*l, val) &#125;func main() &#123; // 值 var lst List lst.Append(1) fmt.Printf("%v (len: %d)", lst, lst.Len()) // [1] (len: 1) // 指针 plst := new(List) plst.Append(2) fmt.Printf("%v (len: %d)", plst, plst.Len()) // &amp;[2] (len: 1)&#125;]]></content>
      <categories>
        <category>The Way to Go</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Way to Go（三）]]></title>
    <url>%2F2018%2F05%2F27%2FThe-Way-to-Go%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数组与切片 数组 数组是具有相同 唯一类型 的一组已编号且长度固定的数据项序列（这是一种同构的数据结构）；这种类型可以是任意的原始类型例如整型、字符串或者自定义类型。数组长度必须是一个常量表达式，并且必须是一个非负整数。数组长度也是数组类型的一部分，所以[5]int和[10]int是属于不同类型的。 1var identifier [len]type 切片声明切片的格式是： 1var identifier []type //不需要说明长度 注意不要用指针指向 slice。切片本身已经是一个引用类型，所以它本身就是一个指针。 new() 和 make() 的区别看起来二者没有什么区别，都在堆上分配内存，但是它们的行为不同，适用于不同的类型。 new(T) 为每个新的类型T分配一片内存，初始化为 0 并且返回类型为*T的内存地址：这种方法 返回一个指向类型为 T，值为 0 的地址的指针，它适用于值类型如数组和结构体；它相当于 &amp;T{}。 make(T) 返回一个类型为 T 的初始值，它只适用于3种内建的引用类型：切片、map 和 channel 换言之，new 函数分配内存，make 函数初始化。 字符串、数组和切片的应用 从字符串生成字节切片 假设 s 是一个字符串（本质上是一个字节数组），那么就可以直接通过 c := []byte(s) 来获取一个字节的切片 c。另外，还可以通过 copy 函数来达到相同的目的：copy(dst []byte, src string)。 同样的，还可以使用 for-range 来获得每个元素。 修改字符串中的某个字符 Go 语言中的字符串是不可变的，也就是说 str[index] 这样的表达式是不可以被放在等号左侧的。如果尝试运行 str[i] = &#39;D&#39;会得到错误：cannot assign to str[i]。 因此，必须先将字符串转换成字节数组，然后再通过修改数组中的元素值来达到修改字符串的目的，最后将字节数组转换回字符串格式。 例如，将字符串 &quot;hello&quot; 转换为 &quot;cello&quot;： 1234s := "hello"c := []byte(s)c[0] = 'c's2 := string(c) // s2 == "cello" 所以，可以通过操作切片来完成对字符串的操作。 搜索及排序切片和数组 标准库提供了 sort 包来实现常见的搜索和排序操作。您可以使用 sort 包中的函数 func Ints(a []int) 来实现对 int 类型的切片排序。例如 sort.Ints(arri)，其中变量 arri 就是需要被升序排序的数组或切片。为了检查某个数组是否已经被排序，可以通过函数 IntsAreSorted(a []int) bool来检查，如果返回 true 则表示已经被排序。 类似的，可以使用函数 func Float64s(a []float64) 来排序 float64 的元素，或使用函数 func Strings(a []string) 排序字符串元素。 想要在数组或切片中搜索一个元素，该数组或切片必须先被排序（因为标准库的搜索算法使用的是二分法）。然后，您就可以使用函数func SearchInts(a []int, n int) int 进行搜索，并返回对应结果的索引值。 append 函数常见操作 将切片 b 的元素追加到切片 a 之后：a = append(a, b...) 复制切片 a 的元素到新的切片 b 上： 12b = make([]T, len(a))copy(b, a) 删除位于索引 i 的元素：a = append(a[:i], a[i+1:]...) 切除切片 a 中从索引 i 至 j 位置的元素：a = append(a[:i], a[j:]...) 为切片 a 扩展 j 个元素长度：a = append(a, make([]T, j)...) 在索引 i 的位置插入元素 x：a = append(a[:i], append([]T{x}, a[i:]...)...) 在索引 i 的位置插入长度为 j 的新切片：a = append(a[:i], append(make([]T, j), a[i:]...)...) 在索引 i 的位置插入切片 b 的所有元素：a = append(a[:i], append(b, a[i:]...)...) 取出位于切片 a 最末尾的元素 x：x, a = a[len(a)-1], a[:len(a)-1] 将元素 x 追加到切片 a：a = append(a, x) 因此，您可以使用切片和 append 操作来表示任意可变长度的序列。 mapmap 是引用类型，可以使用如下声明： 12var map1 map[keytype]valuetypevar map1 map[string]int 在声明的时候不需要知道 map 的长度，map 是可以动态增长的。 未初始化的 map 的值是nil。 key 可以是任意可以用 == 或者 != 操作符比较的类型，比如 string、int、float。所以数组、切片和结构体不能作为 key，但是指针和接口类型可以。 value 可以是任意类型的；通过使用空接口类型，我们可以存储任意值，但是使用这种类型作为值时需要先做一次类型断言。 map 是 引用类型 的： 内存用 make 方法来分配。 map 的初始化：var map1 = make(map[keytype]valuetype)。 或者简写为：map1 := make(map[keytype]valuetype)。 测试键值对是否存在及删除元素使用 val1 = map1[key1] 的方法获取 key1 对应的值 val1。如果map 中不存在key1，val1 就是一个值类型的空值。 这就会给我们带来困惑了：现在我们没法区分到底是key1 不存在还是它对应的 value 就是空值。 为了解决这个问题，我们可以这么用：val1, isPresent = map1[key1] 如果你只是想判断某个 key 是否存在而不关心它对应的值到底是多少，你可以这么做： 1_, ok := map1[key1] // 如果key1存在则ok == true，否则ok为false 或者和 if 混合使用： 123if _, ok := map1[key1]; ok &#123; // ...&#125; 从 map1 中删除 key1： 直接 delete(map1, key1)就可以。 如果key1 不存在，该操作不会产生错误。 map 类型的切片假设我们想获取一个 map 类型的切片，我们必须使用两次 make() 函数，第一次分配切片，第二次分配 切片中每个 map 元素 1234567891011121314151617181920package mainimport "fmt"func main() &#123; // Version A: items := make([]map[int]int, 5) for i:= range items &#123; items[i] = make(map[int]int, 1) items[i][1] = 2 &#125; fmt.Printf("Version A: Value of items: %v\n", items) // Version B: NOT GOOD! items2 := make([]map[int]int, 5) for _, item := range items2 &#123; item = make(map[int]int, 1) // item is only a copy of the slice element. item[1] = 2 // This 'item' will be lost on the next iteration. &#125; fmt.Printf("Version B: Value of items: %v\n", items2)&#125; 输出结果：12Version A: Value of items: [map[1:2] map[1:2] map[1:2] map[1:2] map[1:2]]Version B: Value of items: [map[] map[] map[] map[] map[]] 需要注意的是，应当像 A 版本那样通过索引使用切片的 map 元素。在 B 版本中获得的项只是 map 值的一个拷贝而已，所以真正的 map 元素没有得到初始化。 将 map 的键值对调这里对调是指调换 key 和 value。如果 map 的值类型可以作为 key 且所有的 value 是唯一的，那么通过下面的方法可以简单的做到键值对调。 12345678910111213141516171819202122package mainimport ( "fmt")var ( barVal = map[string]int&#123;"alpha": 34, "bravo": 56, "charlie": 23, "delta": 87, "echo": 56, "foxtrot": 12, "golf": 34, "hotel": 16, "indio": 87, "juliet": 65, "kili": 43, "lima": 98&#125;)func main() &#123; invMap := make(map[int]string, len(barVal)) for k, v := range barVal &#123; invMap[v] = k &#125; fmt.Println("inverted:") for k, v := range invMap &#123; fmt.Printf("Key: %v, Value: %v / ", k, v) &#125;&#125; 包像 fmt、os 等这样具有常用功能的内置包在 Go 语言中有 150 个以上，它们被称为标准库，大部分(一些底层的除外)内置于 Go 本身。 unsafe: 包含了一些打破 Go 语言“类型安全”的命令，一般的程序中不会被使用，可用在 C/C++ 程序的调用中。 syscall-os-os/exec: os: 提供给我们一个平台无关性的操作系统功能接口，采用类Unix设计，隐藏了不同操作系统间差异，让不同的文件系统和操作系统对象表现一致。 os/exec: 提供我们运行外部操作系统命令和程序的方式。 syscall: 底层的外部包，提供了操作系统底层调用的基本接口。 archive/tar 和 /zip-compress：压缩(解压缩)文件功能。 fmt-io-bufio-path/filepath-flag: fmt: 提供了格式化输入输出功能。 io: 提供了基本输入输出功能，大多数是围绕系统功能的封装。 bufio: 缓冲输入输出功能的封装。 path/filepath: 用来操作在当前系统中的目标文件名路径。 flag: 对命令行参数的操作。 strings-strconv-unicode-regexp-bytes: strings: 提供对字符串的操作。 strconv: 提供将字符串转换为基础类型的功能。 unicode: 为 unicode 型的字符串提供特殊的功能。 regexp: 正则表达式功能。 bytes: 提供对字符型分片的操作。 index/suffixarray: 子字符串快速查询。 math-math/cmath-math/big-math/rand-sort: math: 基本的数学函数。 math/cmath: 对复数的操作。 math/rand: 伪随机数生成。 sort: 为数组排序和自定义集合。 math/big: 大数的实现和计算。 container-/list-ring-heap: 实现对集合的操作。 list: 双链表。 ring: 环形链表。 time-log: time: 日期和时间的基本操作。 log: 记录程序运行时产生的日志,我们将在后面的章节使用它。 encoding/json-encoding/xml-text/template: encoding/json: 读取并解码和写入并编码 JSON 数据。 encoding/xml:简单的 XML1.0 解析器,有关 JSON 和 XML 的实例请查阅第 12.9/10 章节。 text/template:生成像 HTML 一样的数据与文本混合的数据驱动模板（参见第 15.7 节）。 net-net/http-html:（参见第 15 章） net: 网络数据的基本操作。 http: 提供了一个可扩展的 HTTP 服务器和基础客户端，解析 HTTP 请求和回复。 html: HTML5 解析器。 runtime: Go 程序运行时的交互操作，例如垃圾回收和协程创建。 reflect: 实现通过程序运行时反射，让程序操作任意类型的变量。 exp 包中有许多将被编译为新包的实验性的包。它们将成为独立的包在下次稳定版本发布的时候。如果前一个版本已经存在了，它们将被作为过时的包被回收。然而 Go1.0 发布的时候并不包含过时或者实验性的包。 regexp 包在下面的程序里，我们将在字符串中对正则表达式进行匹配。 如果是简单模式，使用 Match 方法便可： 1ok, _ := regexp.Match(pat, []byte(searchIn)) 变量 ok 将返回 true 或者 false,我们也可以使用 MatchString： 1ok, _ := regexp.MatchString(pat, searchIn) 锁和 sync 包在一些复杂的程序中，通常通过不同线程执行不同应用来实现程序的并发。当不同线程要使用同一个变量时，经常会出现一个问题：无法预知变量被不同线程修改的顺序！(这通常被称为资源竞争,指不同线程对同一变量使用的竞争) 经典的做法是一次只能让一个线程对共享变量进行操作。当变量被一个线程改变时(临界区)，我们为它上锁，直到这个线程执行完成并解锁后，其他线程才能访问它。 在 Go 语言中这种锁的机制是通过 sync 包中Mutex 来实现的。sync 来源于 “synchronized” 一词，这意味着线程将有序的对同一变量进行访问。 sync.Mutex 是一个互斥锁，它的作用是守护在临界区入口来确保同一时间只能有一个线程进入临界区。 假设 info 是一个需要上锁的放在共享内存中的变量。通过包含 Mutex来实现的一个典型例子如下： 123456import "sync"type Info struct &#123; mu sync.Mutex // ... other fields, e.g.: Str string&#125; 如果一个函数想要改变这个变量可以这样写: 1234567func Update(info *Info) &#123; info.mu.Lock() // critical section: info.Str = // new value // end critical section info.mu.Unlock()&#125; 还有一个很有用的例子是通过 Mutex 来实现一个可以上锁的共享缓冲器: 1234type SyncedBuffer struct &#123; lock sync.Mutex buffer bytes.Buffer&#125;]]></content>
      <categories>
        <category>The Way to Go</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Way to Go（二）]]></title>
    <url>%2F2018%2F05%2F24%2FThe-Way-to-Go%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[控制结构Go 提供了下面这些条件结构和分支结构： if-else 结构 switch 结构 select 结构，用于 channel 的选择 可以使用迭代或循环结构来重复执行一次或多次某段代码（任务）： for (range) 结构 一些如 break 和 continue 这样的关键字可以用于中途改变循环的状态。 此外，你还可以使用 return 来结束某个函数的执行，或使用 goto 和标签来调整程序的执行位置。 if-elseif可以包含一个初始化语句（如：给一个变量赋值）。这种写法具有固定的格式（在初始化语句后方必须加上分号）： 123if initialization; condition &#123; // do something&#125; 例如:1234val := 10if val &gt; max &#123; // do something&#125; 你也可以这样写:123if val := 10; val &gt; max &#123; // do something&#125; 测试多返回值函数的错误Go 语言的函数经常使用两个返回值来表示执行是否成功。这样一来，就很明显需要用一个 if 语句来测试执行结果；由于其符号的原因，这样的形式又称之为 comma,ok 模式（pattern）。 switch 结构12345678switch var1 &#123; case val1: ... case val2: ... default: ...&#125; 一旦成功地匹配到某个分支，在执行完相应代码后就会退出整个 switch 代码块，也就是说不需要特别使用 break 语句来表示结束。 如果在执行完每个分支的代码后，还希望继续执行后续分支的代码，可以使用 fallthrough 关键字来达到目的。 同样可以使用 return 语句来提前结束代码块的执行。 可选的 default 分支可以出现在任何顺序，但最好将它放在最后。它的作用类似于 if-else语句中的 else，表示不符合任何已给出条件时，执行相关语句。 switch 语句的第二种形式是不提供任何被判断的值（实际上默认为判断是否为 true），然后在每个 case 分支中进行测试不同的条件。 switch 语句的第三种形式是包含一个初始化语句： 12345678switch result := calculate(); &#123; case result &lt; 0: ... case result &gt; 0: ... default: // 0&#125; for 结构1for 初始化语句; 条件语句; 修饰语句 &#123;&#125; 不需要括号 () 将它们括起来。例如：for (i = 0; i &lt; 10; i++) { }，这是无效的代码。 for 结构的第二种形式是没有头部的条件判断迭代（类似其它语言中的 while 循环），基本形式为： 1for 条件语句 &#123;&#125; 如果 for 循环的头部没有条件语句，那么就会认为条件永远为 true。for true { }，但一般情况下都会直接写 for { }。无限循环的经典应用是服务器，用于不断等待和接受新的请求。 for-range 结构语法上很类似其它语言中 foreach 语句，它可以迭代任何一个集合（包括数组和 map，）可以获得每次迭代所对应的索引。 1for ix, val := range coll &#123; &#125; 标签与 gotofor、switch 或 select 语句都可以配合标签（label）形式的标识符使用，即某一行第一个以冒号（:）结尾的单词。标签的名称是大小写敏感的，为了提升可读性，一般建议使用全部大写字母。 使用标签和 goto 语句是不被鼓励的：它们会很快导致非常糟糕的程序设计，而且总有更加可读的替代方案来实现相同的需求。 如果必须使用goto，应当只使用正序的标签（标签位于 goto 语句之后），但注意标签和goto 语句之间不能出现定义新变量的语句，否则会导致编译失败。 函数Go是编译型语言，所以函数编写的顺序是无关紧要的；鉴于可读性的需求，最好把 main() 函数写在文件的前面，其他函数按照一定逻辑顺序进行编写（例如函数被调用的顺序）。 Go 里面有三种类型的函数： 普通的带有名字的函数 匿名函数或者lambda函数 方法（Methods） 函数被调用的基本格式如下： 1pack1.Function(arg1, arg2, …, argn) Function 是 pack1 包里面的一个函数，括号里的是被调用函数的实参（argument）：这些值被传递给被调用函数的形参（parameter）。 函数重载（function overloading）指的是可以编写多个同名函数，只要它们拥有不同的形参与/或者不同的返回值，在 Go 里面函数重载是不被允许的。 目前 Go 没有泛型（generic）的概念，也就是说它不支持那种支持多种类型的函数。不过在大部分情况下可以通过接口（interface），特别是空接口与类型选择（type switch）与/或者通过使用反射（reflection）来实现相似的功能。使用这些技术将导致代码更为复杂、性能更为低下，所以在非常注意性能的的场合，最好是为每一个类型单独创建一个函数，而且代码可读性更强。 函数参数与返回值通过 return 关键字返回一组值。事实上，任何一个有返回值（单个或多个）的函数都必须以 return 或 panic结尾。 按值传递（call by value） 按引用传递（call by reference） Go 默认使用按值传递来传递参数，也就是传递参数的副本。函数接收参数副本之后，在使用变量的过程中可能对副本的值进行更改，但不会影响到原来的变量，比如 Function(arg1)。 如果你希望函数可以直接修改参数的值，而不是对参数的副本进行操作，你需要将参数的地址（变量名前面添加&amp;符号，比如 &amp;variable）传递给函数，这就是按引用传递，比如 Function(&amp;arg1)，此时传递给函数的是一个指针。如果传递给函数的是一个指针，指针的值（一个地址）会被复制，但指针的值所指向的地址上的值不会被复制；我们可以通过这个指针的值来修改这个值所指向的地址上的值。 几乎在任何情况下，传递指针（一个32位或者64位的值）的消耗都比传递副本来得少。 在函数调用时，像切片（slice）、字典（map）、接口（interface）、通道（channel）这样的引用类型都是默认使用引用传递（即使没有显式的指出指针）。 如果一个函数需要返回四到五个值，我们可以传递一个切片给函数（如果返回值具有相同类型）或者是传递一个结构体（如果返回值具有不同的类型）。因为传递一个指针允许直接修改变量的值，消耗也更少。 传递变长参数如果函数的最后一个参数是采用 ...type 的形式，那么这个函数就可以处理一个变长的参数，这个长度可以为 0，这样的函数称为变参函数。 1func myFunc(a, b, arg ...int) &#123;&#125; 如果参数被存储在一个 slice 类型的变量 slice 中，则可以通过 slice... 的形式来传递参数调用变参函数。 但是如果变长参数的类型并不是都相同的呢？使用 5 个参数来进行传递并不是很明智的选择，有 2 种方案可以解决这个问题： 使用结构定义一个结构类型，假设它叫 Options，用以存储所有可能的参数：12345type Options struct &#123; par1 type1, par2 type2, ...&#125; 函数 F1 可以使用正常的参数 a 和 b，以及一个没有任何初始化的 Options 结构： F1(a, b, Options {})。如果需要对选项进行初始化，则可以使用F1(a, b, Options {par1:val1, par2:val2})。 使用空接口如果一个变长参数的类型没有被指定，则可以使用默认的空接口 interface{}，这样就可以接受任何类型的参数。该方案不仅可以用于长度未知的参数，还可以用于任何不确定类型的参数。一般而言我们会使用一个 for-range 循环以及 switch 结构对每个参数的类型进行判断： 1234567891011func typecheck(..,..,values … interface&#123;&#125;) &#123; for _, value := range values &#123; switch v := value.(type) &#123; case int: … case float: … case string: … case bool: … default: … &#125; &#125;&#125; defer 和追踪关键字 defer允许我们推迟到函数返回之前（或任意位置执行 return 语句之后）一刻才执行某个语句或函数（为什么要在返回之后才执行这些语句？因为return 语句同样可以包含一些操作，而不是单纯地返回某个值）。 当有多个 defer行为被注册时，它们会以逆序执行（类似栈，即后进先出） 关键字 defer 允许我们进行一些函数执行完成后的收尾工作，例如： 关闭文件流 12// open a file defer file.Close() 解锁一个加锁的资源 12mu.Lock() defer mu.Unlock() 打印最终报告 12printHeader() defer printFooter() 关闭数据库连接 12// open a database connection defer disconnectFromDB() 内置函数 名称 说明 close 用于管道通信 len、cap len 用于返回某个类型的长度或数量（字符串、数组、切片、map 和管道）；cap是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map） new、make new 和 make 均是用于分配内存：new 用于值类型和用户定义的类型，如自定义结构，make 用于内置引用类型（切片、map 和管道）。它们的用法就像是函数，但是将类型作为参数：new(type)、make(type)。new(T) 分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针。它也可以被用于基本类型：v := new(int)。make(T) 返回类型 T 的初始化之后的值，因此它比 new 进行更多的工作 copy、append 用于复制和连接切片 panic、recover 两者均用于错误处理机制 print、println 底层打印函数，在部署环境中建议使用 fmt 包 complex、real imag 用于创建和操作复数 使用闭包调试当在分析和调试复杂的程序时，无数个函数在不同的代码文件中相互调用，如果这时候能够准确地知道哪个文件中的具体哪个函数正在执行，对于调试是十分有帮助的。您可以使用 runtime 或 log 包中的特殊函数来实现这样的功能。包 runtime 中的函数 Caller() 提供了相应的信息，因此可以在需要的时候实现一个 where() 闭包函数来打印函数执行的位置： 123456789where := func() &#123; _, file, line, _ := runtime.Caller(1) log.Printf("%s:%d", file, line)&#125;where()// some codewhere()// some more codewhere() 也可以设置 log 包中的 flag 参数来实现： 12log.SetFlags(log.Llongfile)log.Print("") 或使用一个更加简短版本的 where 函数： 12345678var where = log.Printfunc func1() &#123;where()... some codewhere()... some codewhere()&#125;]]></content>
      <categories>
        <category>The Way to Go</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Way to Go（一）]]></title>
    <url>%2F2018%2F05%2F23%2FThe-Way-to-Go%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[开始调试器&amp;格式化说明符 在 fmt.Printf 中使用下面的说明符来打印有关变量的相关信息： %+v 打印包括字段在内的实例的完整信息 %#v 打印包括字段和限定类型名称在内的实例的完整信息 %T 打印某个类型的完整说明 %d 用于格式化整数（%x 和 %X 用于格式化 16 进制表示的数字） %g 用于格式化浮点型（%f 输出浮点数，%e 输出科学计数表示法 使用 panic 语句来获取栈跟踪信息（直到 panic 时所有被调用函数的列表）。 使用关键字 defer 来跟踪代码执行过程 类型转换由于 Go语言不存在隐式类型转换，因此所有的转换都必须显式说明 类型 B 的值 = 类型 B(类型 A 的值)12345valueOfTypeB = typeB(valueOfTypeA)例：a := 5.0b := int(a) 数字类型int 和 uint 在 32 位操作系统上，它们均使用 32 位（4 个字节），在 64 位操作系统上，它们均使用 64 位（8 个字节）。 Go 语言中没有 float 类型。float32 精确到小数点后 7 位，float64 精确到小数点后 15 位。 1234567与操作系统架构无关的类型都有固定的大小，并在类型的名称中就可以看出来整数：int8（-128 -&gt; 127）int16（-32768 -&gt; 32767）int32（-2,147,483,648 -&gt; 2,147,483,647）int64（-9,223,372,036,854,775,808 -&gt; 9,223,372,036,854,775,807） 123456无符号整数：uint8（0 -&gt; 255）uint16（0 -&gt; 65,535）uint32（0 -&gt; 4,294,967,295）uint64（0 -&gt; 18,446,744,073,709,551,615） 1234浮点型（IEEE-754 标准）：float32（+- 1e-45 -&gt; +- 3.4 * 1e38）float64（+- 5 1e-324 -&gt; 107 1e308） strings 和 strconv 包Go 中使用 strings 包来完成对字符串的主要操作。 前缀和后缀HasPrefix 判断字符串 s 是否以 prefix 开头： 1strings.HasPrefix(s, prefix string) bool HasSuffix 判断字符串 s 是否以 suffix 结尾：1strings.HasSuffix(s, suffix string) bool 字符串包含关系Contains 判断字符串 s 是否包含 substr： 1strings.Contains(s, substr string) bool 判断子字符串或字符在父字符串中出现的位置（索引）Index 返回字符串 str 在字符串 s 中的索引（str 的第一个字符的索引），-1 表示字符串 s 不包含字符串 str： 1strings.Index(s, str string) int LastIndex 返回字符串 str 在字符串 s 中最后出现位置的索引（str 的第一个字符的索引），-1 表示字符串 s 不包含字符串 str：1strings.LastIndex(s, str string) int 字符串替换Replace 用于将字符串 str 中的前 n个字符串 old 替换为字符串 new，并返回一个新的字符串，如果 n = -1 则替换所有字符串 old 为字符串 new：1strings.Replace(str, old, new, n) string 统计字符串出现次数Count 用于计算字符串 str 在字符串 s 中出现的非重叠次数： 1strings.Count(s, str string) int 重复字符串Repeat 用于重复 count次字符串 s 并返回一个新的字符串： 1strings.Repeat(s, count int) string 修改字符串大小写ToLower 将字符串中的 Unicode 字符全部转换为相应的小写字符： 1strings.ToLower(s) string ToUpper 将字符串中的 Unicode 字符全部转换为相应的大写字符： 1strings.ToUpper(s) string 修剪字符串可以使用 strings.TrimSpace(s) 来剔除字符串开头和结尾的空白符号；如果你想要剔除指定字符，则可以使用 strings.Trim(s, &quot;cut&quot;) 来将开头和结尾的 cut 去除掉。该函数的第二个参数可以包含任何字符，如果你只想剔除开头或者结尾的字符串，则可以使用 TrimLeft 或者 TrimRight 来实现。 分割字符串strings.Fields(s) 将会利用 1 个或多个空白符号来作为动态长度的分隔符将字符串分割成若干小块，并返回一个slice，如果字符串只包含空白符号，则返回一个长度为 0 的slice。 strings.Split(s, sep) 用于自定义分割符号来对指定字符串进行分割，同样返回 slice。 因为这 2 个函数都会返回 slice，所以习惯使用 for-range 循环来对其进行处理 拼接 slice 到字符串Join 用于将元素类型为 string 的 slice 使用分割符号来拼接组成一个字符串：1strings.Join(sl []string, sep string) string 从字符串中读取内容函数 strings.NewReader(str) 用于生成一个 Reader 并读取字符串中的内容，然后返回指向该 Reader 的指针，从其它类型读取内容的函数还有： Read() 从 []byte 中读取内容。 ReadByte() 和 ReadRune() 从字符串中读取下一个 byte 或者 rune。 字符串与其它类型的转换与字符串相关的类型转换都是通过 strconv 包实现的。 该包包含了一些变量用于获取程序运行的操作系统平台下 int 类型所占的位数，如：strconv.IntSize。 任何类型 T 转换为字符串总是成功的。 针对从数字类型转换到字符串，Go 提供了以下函数： strconv.Itoa(i int) string 返回数字 i 所表示的字符串类型的十进制数。 strconv.FormatFloat(f float64, fmt byte, prec int, bitSize int) string 将 64 位浮点型的数字转换为字符串，其中 fmt 表示格式（其值可以是 &#39;b&#39;、&#39;e&#39;、&#39;f&#39; 或 &#39;g&#39;），prec 表示精度，bitSize 则使用 32 表示 float32，用 64 表示 float64。 将字符串转换为其它类型 tp 并不总是可能的，可能会在运行时抛出错误 parsing &quot;…&quot;: invalid argument。 针对从字符串类型转换为数字类型，Go 提供了以下函数： strconv.Atoi(s string) (i int, err error) 将字符串转换为 int 型。 strconv.ParseFloat(s string, bitSize int) (f float64, err error) 将字符串转换为 float64 型。 利用多返回值的特性，这些函数会返回 2 个值，第 1 个是转换后的结果（如果转换成功），第 2 个是可能出现的错误，因此，我们一般使用以下形式来进行从字符串到其它类型的转换： 1val, err = strconv.Atoi(s) 时间和日期time 包为我们提供了一个数据类型 time.Time（作为值使用）以及显示和测量时间和日期的功能函数。 当前时间可以使用 time.Now() 获取，或者使用 t.Day()、t.Minute() 等等来获取时间的一部分；甚至可以自定义时间格式化字符串 例如： fmt.Printf(&quot;%02d.%02d.%4d\n&quot;, t.Day(), t.Month(), t.Year()) 将会输出 21.07.2011。 Duration 类型表示两个连续时刻所相差的纳秒数，类型为 int64。Location 类型映射某个时区的时间，UTC 表示通用协调世界时间。 如果你需要在应用程序在经过一定时间或周期执行某项任务（事件处理的特例），则可以使用 time.After 或者 time.Ticker time.Sleep（Duration d） 可以实现对某个进程（实质上是 goroutine）时长为 d 的暂停。 指针程序在内存中存储它的值，每个内存块（或字）有一个地址，通常用十六进制数表示，如：0x6b0820 或 0xf84001d7f0。 Go 语言的取地址符是 &amp;，放到一个变量前使用就会返回相应变量的内存地址。]]></content>
      <categories>
        <category>The Way to Go</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议及发展历史]]></title>
    <url>%2F2018%2F05%2F20%2FHTTP%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2%2F</url>
    <content type="text"><![CDATA[经典五层模型 HTTP协议发展历史一、HTTP/0.9（1991年发布）HTTP 是基于 TCP/IP 协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。 只有一个 GET 命令 没有 header 等描述数据的信息，服务器只能回应 HTML 格式的字符串 123&lt;html&gt; &lt;body&gt;Hello World&lt;/body&gt;&lt;/html&gt; 服务器发送完毕，就关闭 TCP 连接 二、HTTP/1.0（1996.05发布） 增加了很多命令 任何格式的内容都可以发送，新增 POST 和 HEAD 等命令。 增加status code 和 HTTP header 每次通信必须包括头部信息（HTTP header），来描述元数据。 新增状态码（status code）、权限（authorization）、缓存（cache）、多部分发送（multi-part type）、内容编码（content encoding） 三、HTTP/1.1（1997.01发布） 持久连接 管道机制（pipeline），即在同一个TCP连接里面，客户端可以同时发送多个请求。 增加host和其他动词方法：PUT、PATCH、HEAD、 OPTIONS、DELETE。 四、HTTP/2（2015发布）下一个新版本将是 HTTP/3 所有数据以二进制传输 同一个连接里面发送多个请求不再需要按照顺序来 头信息压缩以及推送等提高效率的功能 参考连接：HTTP 协议发展历史 HTTP协议三次握手参考连接：TCP三次握手 URI、URL 和 URN URI：Uniform Resource Identifier/统一资源标识符 URL：Uniform Resource Locators/统一资源定位器 URN：Uniform Resource Names/永久统一资源定位符]]></content>
      <categories>
        <category>零碎笔记</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Redux]]></title>
    <url>%2F2017%2F11%2F18%2FReact-Redux%2F</url>
    <content type="text"><![CDATA[React-Redux老赵（redux）能力用起来很麻烦，为了方便管理，使用魏和尚来负责连接 npm instal --save react-redux 忘记subscribe，记住reducer、action和dispatch即可 react-redux提供Provider和connect两个接口来连接 react-redux具体使用 Provider组件在应用最外层，传入store即可，只用一次 connect负责从外部获取组件需要的参数 connect可以用装饰器的方式来写 index.js文件：123456789101112131415import &#123;Provider&#125; from 'react-redux';// function render()&#123;// ReactDom.render(&lt;App store=&#123;store&#125; /&gt;,document.getElementById('root')) // &#125;// render();// store.subscribe(render);ReactDom.render( (&lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt;, &lt;/Provider&gt;) document.getElementById('root') ) App.js文件 1234567891011121314151617181920212223242526import React from 'react';import &#123;addGUN,removeGUN,addGunAsync&#125; from './index.redux';import &#123;connect&#125; from 'react-redux';class App extends React.Component&#123; render()&#123; return ( &lt;div&gt; &lt;h1&gt;现在有机枪&#123;this.props.num&#125;把&lt;/h1&gt; &lt;button onClick=&#123;this.props.addGUN&#125;&gt;申请武器&lt;/button&gt; &lt;button onClick=&#123;this.props.removeGUN&#125;&gt;上交武器&lt;/button&gt; &lt;button onClick=&#123;this.props.addGunAsync&#125;&gt;拖两天申请武器&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;//数据。参数是状态const mapStateProps = (state) =&gt;&#123; return &#123;num:state&#125;&#125;const actionCreators = &#123;addGUN,removeGUN,addGunAsync&#125;//属性和方法分别给到组件App = connect(mapStateProps,actionCreators)(App);export default App; 使用装饰器优化connect代码 npm install --save-dev babel-plugin-transform-decorators-legacy 增加配置`”plugins”:[ &quot;transform-decorators-legacy&quot; ]` 12345678910111213141516//数据。参数是状态// const mapStateProps = (state) =&gt;&#123;// return &#123;num:state&#125;// &#125;// const actionCreators = &#123;addGUN,removeGUN,addGunAsync&#125;//属性和方法分别给到组// App = connect(mapStateProps,actionCreators)(App);@connect( //你要state里什么属性放到props里 state=&gt;(&#123;num:state&#125;), //你要什么方法，放到props里，自动dispatch &#123;addGUN,removeGUN,addGunAsync&#125; )]]></content>
      <categories>
        <category>从0到1</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Redux基础]]></title>
    <url>%2F2017%2F11%2F18%2FRedux%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Redux 基础redux 是什么 专注于状态管理，和react解耦 单一状态，单向数据流 核心概念：store、state、action、reducer 独立团项目：独立团逐渐发展，老李发现管不过来了 人少的时候，无论是兵器和人员的变更，都是setState 发展为千人大团后，老李决定，军事生活分开 所有的状态归赵政委（redux）管理，自己只打仗（view）显示 老赵（redux）主要功能： 老赵有一个保险箱（store），所有人的状态，在那里都有记录（state） 需要改变的时候，要告诉专员（dispatch）要干什么（action） 处理变化的人（reducer）拿到state和action，生成新的state 老赵（redux）的使用方法 首先通过reducer新建store，随时随地通过store.getState获取状态 需要状态变更，store.dispatch（action）来修改状态 reducer函数接受state和action，返回新的state，可以用store.subscribe监听每次修改 123456789101112131415161718192021import &#123; createStore &#125; from 'redux';//1.新建store，通过reducer建立//根据老的state和action，生成新的state，state默认为0function counter(state=0,action)&#123; switch (action.type) &#123; case '加机关枪': return state+1 case '减机关枪': return state-1 default: return 10; &#125;&#125;//1.新建storeconst store = createStore(counter);//获取状态const init = store.getState();console.log(init);//10 完整的redux实现12345678910111213141516171819202122232425262728293031323334import &#123; createStore &#125; from 'redux';//1.新建store，通过reducer建立//根据老的state和action，生成新的state，state默认为0function counter(state=0,action)&#123; switch (action.type) &#123; case '加机关枪': return state+1 case '减机关枪': return state-1 default: return 10; &#125;&#125;//1.新建storeconst store = createStore(counter);//获取状态const init = store.getState();console.log(init);//10//监听function listener()&#123; const current = store.getState() console.log(`现在有机关枪$&#123;current&#125;把`)&#125;store.subscribe(listener); //派发事件，传递actionstore.dispatch(&#123;type:'加机关枪'&#125;);store.dispatch(&#123;type:'加机关枪'&#125;);store.dispatch(&#123;type:'减机关枪'&#125;); 老赵（redux）怎么管理独立团 把store.dispatch方法传递给组件，内部可以调用修改状态 subscribe订阅render函数，每次修改都重新渲染 redux相关内容，移到单独的文件index.redux.js（action和reducer）单独管理 index.js文件 123456789101112131415import React from 'react';import ReactDom from 'react-dom';import &#123;createStore&#125; from 'redux';import App from './App'import &#123;counter&#125; from './index.redux'//建立storeconst store = createStore(counter);function render()&#123; ReactDom.render(&lt;App store=&#123;store&#125; /&gt;,document.getElementById('root')) &#125;render();store.subscribe(render); index.redux.js文件 123456789101112131415161718192021222324//action和reducerconst ADD_GUN = '加机关枪';const REMOVE_GUN = '减机关枪';//reducerexport function counter(state=0,action)&#123; switch (action.type) &#123; case ADD_GUN: return state+1 case REMOVE_GUN: return state-1 default: return 10; &#125;&#125;//action creatorexport function addGUN()&#123; return &#123;type:ADD_GUN&#125;&#125;export function removeGUN()&#123; return &#123;type:REMOVE_GUN&#125;&#125; App.js文件 1234567891011121314151617import React from 'react';import &#123;addGUN&#125; from './index.redux'class App extends React.Component&#123; render()&#123; const store = this.props.store; const num = store.getState() return ( &lt;div&gt; &lt;h1&gt;现在有机枪&#123;num&#125;把&lt;/h1&gt; &lt;button onClick=&#123;()=&gt;store.dispatch(addGUN())&#125;&gt;申请武器&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export default App; 更进一步处理异步、调试工具、更优雅的和react结合 redux处理异步，需要redux-thunk插件 redux默认只处理同步，异步任务需要redux-thunk中间件。npm install redux-thunk --save 使用applyMiddleware开启thunk中间件（在index页面开启）； 1234import &#123;applyMiddleware&#125; from 'redux';import thunk from 'redux-thunk';const store = createStore(counter,applyMiddleware(thunk)); action可以返回函数，使用dispatch提交action npm install redux-devtools-extension并且开启 使用react-redux优雅的连接react和redux]]></content>
      <categories>
        <category>从0到1</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[React基础知识]]></title>
    <url>%2F2017%2F11%2F17%2FReact%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[react基础知识123456789101112131415161718192021222324import React from 'react';//定义一个 MyApp 组件class MyApp extends React.Component&#123; render()&#123; const boss = '校长' return ( &lt;div&gt; &lt;h2&gt;学校，&#123;boss&#125;&lt;/h2&gt; &lt;MyApp2&gt;&lt;/MyApp2&gt; &lt;/div&gt; ) &#125;&#125;//定义 MyApp2 组件给MyApp使用class MyApp2 extends React.Component&#123; render()&#123; const boss = '主任' return &lt;h3&gt;办公室，&#123;boss&#125;&lt;/h3&gt; &#125;&#125;export default MyApp; 组件之间传递数据 props传递数据：使用&lt;组件 数据=“值”&gt;的形式传递 组件内部使用 this.props获取值 如果组件只有render函数，还可以用函数的形式写组件 12345678910111213141516171819202122//定义一个 MyApp 组件class MyApp extends React.Component&#123; render()&#123; const boss = '校长' return ( &lt;div&gt; &lt;h2&gt;学校，&#123;boss&#125;&lt;/h2&gt; &lt;MyApp2 boss="主任"&gt;&lt;/MyApp2&gt; &lt;/div&gt; ) &#125;&#125;//定义 MyApp2 组件给MyApp使用class MyApp2 extends React.Component&#123; render()&#123; // const boss = '主任' return &lt;h3&gt;办公室，&#123;this.props.boss&#125;&lt;/h3&gt; &#125;&#125;export default MyApp; 组件内部state 组件内部通过state管理状态 JSX本质是js，所以直接用数组.map渲染列表 Constructor设置初始状态，记得执行super(props) state就是一个不可变的对象，使用this.state获取 1234567891011121314151617181920212223242526272829303132333435363738import React from 'react';//定义一个 MyApp 组件class MyApp extends React.Component&#123; render()&#123; const boss = '校长' return ( &lt;div&gt; &lt;h2&gt;学校，&#123;boss&#125;&lt;/h2&gt; &lt;MyApp2 boss="主任"&gt;&lt;/MyApp2&gt; &lt;/div&gt; ) &#125;&#125;//定义 MyApp2 组件给MyApp使用class MyApp2 extends React.Component&#123; constructor(props)&#123; super(props) this.state = &#123; staff:['甲','乙','丙','丁'] &#125; &#125; render()&#123; return ( &lt;div&gt; &lt;h3&gt;办公室，&#123;this.props.boss&#125;&lt;/h3&gt; &lt;ul&gt; &#123;this.state.staff.map(v=&gt;&#123; return &lt;li key=&#123;v&#125;&gt;&#123;v&#125;&lt;/li&gt; &#125;)&#125; &lt;/ul&gt; &lt;/div&gt; ) &#125;&#125;export default MyApp; 事件 onClick点击事件 JSX里使用onClick={()=&gt;this.函数名()}来绑定事件 this引用的问题，需要在构造函数里用bind绑定this this.setState修改state，记得返回新的state，而不是修改 1234567891011121314151617181920212223242526272829//定义 MyApp2 组件给MyApp使用class MyApp2 extends React.Component&#123; constructor(props)&#123; super(props) this.state = &#123; staff:['甲','乙','丙','丁'] &#125; &#125; addStaff()&#123; this.setState(&#123; staff:[...this.state.staff,"新员工"+Math.random()] &#125;) &#125; render()&#123; return ( &lt;div&gt; &lt;h3&gt;办公室，&#123;this.props.boss&#125;&lt;/h3&gt; &lt;button onClick=&#123;()=&gt;this.addStaff()&#125;&gt;新员工加入&lt;/button&gt; &lt;ul&gt; &#123;this.state.staff.map(v=&gt;&#123; return &lt;li key=&#123;v&#125;&gt;&#123;v&#125;&lt;/li&gt; &#125;)&#125; &lt;/ul&gt; &lt;/div&gt; ) &#125;&#125;export default MyApp; 生命周期react组件内部有若干钩子函数，在组件不同的状态执行 初始化周期（页面组件第一次渲染所要执行的所有函数） 组件重新渲染（更新）生命周期（props、state变化导致页面状态发生变化时执行的函数） 组件卸载生命周期（比如某个组件离开这个页面）]]></content>
      <categories>
        <category>从0到1</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Express+MongoDB]]></title>
    <url>%2F2017%2F11%2F17%2FExpress-MongoDB%2F</url>
    <content type="text"><![CDATA[express 的使用12#安装 expressnpm install --save express 123456789101112131415const express = require('express');const app = express();//第一个参数是路径app.get('/',function(req,res)&#123; res.send('Hello world')&#125;)// 大多数情况返回给前台的是JSON数据app.get('/data',function(req,res)&#123; res.json(&#123;name:'Beme',age:'22'&#125;)&#125;)app.listen(3000,function()&#123; console.log("ok")&#125;) app.get、app.post分别开发get和post接口 app.use使用模块 res.send、res.json、ressendFile响应不同的内容 MongoDB1npm install --save mongoose 1234567//连接数据库,并且使用ceshi这个集合，没有的话会自动新建const mongoose = require('mongoose');const DB_URL = 'mongodb://localhost:27017/ceshi';mongoose.connect(DB_URL);mongoose.connection.on('connected',function()&#123; console.log('mongo connected')&#125;) mongoose使用 connect连接数据库 定义文档类型，schema和model新建模型 一个数据库文档对应一个模型，通过模型对数据库进行操作 12345//类似于MySQL的表，mongo里有文档、字段的概念const User = mongoose.model('user',new mongoose.Schema(&#123; user:&#123;type:String,require:true&#125;, age:&#123;type:Number,require:true&#125;&#125;)) mongoose文档 String、Number等数据结构 create、remove、update用来增、删、改的操作 find和findOne用来查数据 增 1234567891011//create新增数据User.create(&#123; user:'Beme', age:22&#125;,function(err,doc)&#123; if (!err) &#123; console.log(doc) &#125;else &#123; console.log(err) &#125;&#125;) 删 1234//删除数据User.remove(&#123;age:20&#125;,function(err,doc)&#123; console.log(doc)&#125;) 改 1234//更新数据,user:过滤条件User.update(&#123;'user':'Beme'&#125;,&#123;'$set':&#123;age:18&#125;&#125;,function(err,doc)&#123; console.log(doc)&#125;) 后续进阶 mongodb独立工具函数 express使用body-parser支持post函数 使用cookie-parser存储登录信息cookie]]></content>
      <categories>
        <category>从0到1</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ES6 相关]]></title>
    <url>%2F2017%2F11%2F17%2FES6-%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[ES6 是什么ES6 是新的 JavaScript 语法标准，于2015年6月发布，使用 babel 语法转换器可以支持低端的浏览器。流行的库基本都基于 ES6 构建，React 默认使用 ES6 新语法开发。 ES6语法概览 块级作用域、字符串、函数 对象扩展、解构 类、模块化等 作用域ES6 之前只有全局作用域和函数作用域，ES6 增加了块级作用域。 12345678910111213141516171819//ES6之前&#123; var str="Hello";&#125;console.log(str); //Hello// ES6&#123; let str="Hello";&#125;console.log(str); //ReferenceError: str is not defined//const 定义常量，无法修改const str = "Hello";str = "world";console.log(str);//TypeError: Assignment to constant variable. 字符串 使用反引号，直接写变量 多行字符串 告别 + 拼接字符串 1234567891011let name = 'Beme', str = 'ES6';console.log('Hello ' + name + ' ,this is ' +str );console.log(`Hello $&#123;name&#125;,this is $&#123;str&#125;`); //ES6console.log(` 多行字符串 `); 函数扩展 箭头函数 参数默认值 展开运算符 1234567891011121314151617181920//箭头函数const fun2 = () =&gt; &#123; console.log('ES6')&#125;fun2();//ES6//参数默认值const fun = (name='World') =&gt;&#123; console.log(`Hello $&#123;name&#125;`);&#125;;fun(); //不传值，默认输出Hello Worldfun('ES6'); //传值，输出 Hello ES6//展开运算符const fun = (name,sex) =&gt;&#123; console.log(name,sex)&#125;;let arr = ["Beme","man"];fun.apply(null,arr);//Beme manfun(...arr);//Beme man 对象扩展 Object.keys、values、entries 对象方法简写，计算属性 展开运算符（不是ES6标准，但是Babel也支持 12345678910111213141516const obj = &#123;name:"Beme",age:"22"&#125;console.log(Object.keys(obj));//[ 'name', 'age' ]console.log(Object.values(obj));//[ 'Beme', '22' ]console.log(Object.entries(obj));//[ [ 'name', 'Beme' ], [ 'age', '22' ] ]//对象方法简写const obj = &#123; fun1:function()&#123;&#125;, fun2()&#123;&#125;&#125;;//展开运算符const obj1 = &#123;a:"aa",b:"bb"&#125;const obj2 = &#123;c:"cc",d:"dd"&#125;console.log(&#123;...obj1,...obj2,e:"ee"&#125;);//&#123; a: 'aa', b: 'bb', c: 'cc', d: 'dd', e: 'ee' &#125; 解构赋值 数组解构 对象解构 类 prototype的语法糖 Extends 继承 Constructor 构造函数 1234567891011class MyApp&#123; constructor()&#123; this.name = 'Beme' &#125; sayHello()&#123; console.log(`Hello $&#123;this.name&#125;`) &#125;&#125;const app = new MyApp();app.sayHello();//Hello Beme 新的数据结构 Set，元素不可重合 Map Symbol 模块化ES6 中自带了模块化机制，告别 seajs 和 requirejs import，import{} export，export default Node现在还不支持，需要用require来加载文件 12345通过export暴露的组件，引入时要加&#123;&#125;；通过export default 暴露的组件，引入时不需要&#123;&#125;；import * as mod from './'* 表示以mod的名称全部引入 其他特性 Promise 迭代器和生成器 代理Proxy 常用代码片段数组 对象]]></content>
      <categories>
        <category>从0到1</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[脚手架&工具]]></title>
    <url>%2F2017%2F11%2F17%2F%E8%84%9A%E6%89%8B%E6%9E%B6-%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[官方脚手架1npm install -g create-react-app 之后在开发目录下使用命令1create-react-app demo 即可创建好开发所需的脚手架。 123cd demo npm start 执行项目。 使用create-react-app npm install redux --save安装第三方库 npm run eject弹出配置文件，可以自定义配置webpack 扩展package.json里的script字段，扩展npm run命令 工具在node环境下监听路由和响应内容，使用nodemon自动重启 123npm install -g nodemon#使用 nodemon 文件名 执行]]></content>
      <categories>
        <category>从0到1</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ES6相关]]></title>
    <url>%2F2017%2F11%2F17%2FES6%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[ES6 是什么ES6 是新的 JavaScript 语法标准，于2015年6月发布，使用 babel 语法转换器可以支持低端的浏览器。流行的库基本都基于 ES6 构建，React 默认使用 ES6 新语法开发。 ES6语法概览 块级作用域、字符串、函数 对象扩展、解构 类、模块化等 作用域ES6 之前只有全局作用域和函数作用域，ES6 增加了块级作用域。 12345678910111213141516171819//ES6之前&#123; var str="Hello";&#125;console.log(str); //Hello// ES6&#123; let str="Hello";&#125;console.log(str); //ReferenceError: str is not defined//const 定义常量，无法修改const str = "Hello";str = "world";console.log(str);//TypeError: Assignment to constant variable. 字符串 使用反引号，直接写变量 多行字符串 告别 + 拼接字符串 1234567891011let name = 'Beme', str = 'ES6';console.log('Hello ' + name + ' ,this is ' +str );console.log(`Hello $&#123;name&#125;,this is $&#123;str&#125;`); //ES6console.log(` 多行字符串 `); 函数扩展 箭头函数 参数默认值 展开运算符 1234567891011121314151617181920//箭头函数const fun2 = () =&gt; &#123; console.log('ES6')&#125;fun2();//ES6//参数默认值const fun = (name='World') =&gt;&#123; console.log(`Hello $&#123;name&#125;`);&#125;;fun(); //不传值，默认输出Hello Worldfun('ES6'); //传值，输出 Hello ES6//展开运算符const fun = (name,sex) =&gt;&#123; console.log(name,sex)&#125;;let arr = ["Beme","man"];fun.apply(null,arr);//Beme manfun(...arr);//Beme man 对象扩展 Object.keys、values、entries 对象方法简写，计算属性 展开运算符（不是ES6标准，但是Babel也支持 12345678910111213141516const obj = &#123;name:"Beme",age:"22"&#125;console.log(Object.keys(obj));//[ 'name', 'age' ]console.log(Object.values(obj));//[ 'Beme', '22' ]console.log(Object.entries(obj));//[ [ 'name', 'Beme' ], [ 'age', '22' ] ]//对象方法简写const obj = &#123; fun1:function()&#123;&#125;, fun2()&#123;&#125;&#125;;//展开运算符const obj1 = &#123;a:"aa",b:"bb"&#125;const obj2 = &#123;c:"cc",d:"dd"&#125;console.log(&#123;...obj1,...obj2,e:"ee"&#125;);//&#123; a: 'aa', b: 'bb', c: 'cc', d: 'dd', e: 'ee' &#125; 解构赋值 数组解构 对象解构 类 prototype的语法糖 Extends 继承 Constructor 构造函数 1234567891011class MyApp&#123; constructor()&#123; this.name = 'Beme' &#125; sayHello()&#123; console.log(`Hello $&#123;this.name&#125;`) &#125;&#125;const app = new MyApp();app.sayHello();//Hello Beme 新的数据结构 Set，元素不可重合 Map Symbol 模块化ES6 中自带了模块化机制，告别 seajs 和 requirejs import，import{} export，export default Node现在还不支持，需要用require来加载文件 12345通过export暴露的组件，引入时要加&#123;&#125;；通过export default 暴露的组件，引入时不需要&#123;&#125;；import * as mod from './'* 表示以mod的名称全部引入 其他特性 Promise 迭代器和生成器 代理Proxy 常用代码片段数组 对象]]></content>
      <categories>
        <category>JavaScript学习总结</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识梳理]]></title>
    <url>%2F2017%2F11%2F15%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"><![CDATA[HTMLHTML5 的新特性语义化更好的标签（header、nav、footer、aside、article、section） 音频、视频 API （audio、video） 画布（canvas）和 SVG 地理定位 拖拽释放 本地离线存储 表单控件：calendar、date、email、url、search、range。 xhtml和html的区别XHTML 是更严格更纯净的 HTML 代码（xhtml比html更加规范）。 最主要的不同： XHTML 元素必须被正确的嵌套。 XHTML 元素必须被关闭。 标签名必须用小写。 XHTML 文档必须有根元素。 &lt;meta&gt; 标签&lt;meta&gt; 标签永远位于 head 元素内部。 &lt;meta&gt; 标签用来描述一个HTML网页文档的属性。 &lt;meta&gt; 对搜索引擎的作用：最重要的是对Keywords和description的设置，提高页面的搜索点击率。如： 12&lt;meta name="keywords" content="政治,经济, 科技,文化, 卫生, 情感，心灵，娱乐，生活，社会，企业，交通"&gt;&lt;meta name="description" content="政治,经济, 科技,文化, 卫生, 情感，心灵，娱乐，生活，社会，企业，交通"&gt; 什么是 Canvas？是一个在 HTML5 页面添加了 canvas 元素的一个矩形区域的画布。 canvas 元素使用 JavaScript 在网页上绘制图形。 canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。 css js文件放置位置和原因css 和 js 的正确摆放均是为了提高页面的加载效率。 css应该放置在head中，用 style 标签引入。因为页面渲染时，只有相应的 DOM Tree 完成后才开始之后的布局（layout）并将页面显示。 js 则应该放在 body 标签内的尾部。因为 js 会阻塞其后内容的加载和呈现。为避免 js 阻塞其后内容，可根据具体要求设置参数 async（HTML 5） 和 defer。 CSS盒模型，box-sizingCSS 盒模型包括标准模型和 IE 模型，区别在于 IE 盒模型的 content 包括 border 和 padding 。 1box-sizing: border-box || content-box(default) 当使用 border-box 时，页面将采用 IE 模式计算分析。 当采用 content-box（默认） 时，页面采用标准模式计算分析。 CSS 3 新特性过渡（transition） 动画（animation） 形状转换（transform） 选择器、多背景、rgba 盒子阴影（box-shadow） 边框（border-radius 和 border-image） 弹性布局（Flex） 媒体查询 用 CSS 隐藏页面的5种方法123456789opacity:从 0.0 （完全透明）到 1.0（完全不透明）。visibility:hidden （会占据页面上的空间）。display:none （不会占据页面空间）。position:absolute; top:-9999px; left:-9999px;将元素移出可视区。clip-path: polygon(0px 0px,0px 0px,0px 0px,0px 0px); 水平居中和垂直居中 水平居中： 1231. textalign:center;2. margin:0 auto;（元素要有固定宽度值） 垂直居中 https://www.w3cplus.com/css/vertically-center-content-with-css 11. line-height:/元素高度的值/; Flex 布局 12345.box &#123; display: flex; justify-content: center;（横轴居中） align-items: center;（纵轴居中）&#125; 浮动引起的问题和解决办法问题： 父元素无法被撑开，影响与父级元素同级的元素； 与浮动元素同级的非浮动元素会紧随其后； 如果该浮动元素不是同级第一个浮动的元素，则它之前的元素也应该浮动。 清除浮动： 使用 css 样式中的 clear:both;来解决上述的 2 和 3； 浮动外部元素； 设置 overflow 为 hidden 或者 auto； CSS引入的方法有哪些1234567外链式&lt;link href="1.css" type="text/css" rel="stylesheet" /&gt;内嵌式&lt;style type="text/css"&gt;&lt;/style&gt;导入式&lt;style&gt;@import url(1.css)&lt;/style&gt;行内式&lt;div style="width:200px;background:red;"&gt;&lt;/div&gt; 外链式方便多个网页同时使用一个样式表。 内嵌式速度快，但是改版麻烦，可以减少HTTP请求。 导入式不好用，因为页面首先加载，然后导入样式表，页面在 1s~2s 内会有没有样式表的情况，然后突然有了样式。因为link引用CSS时，在页面加载时同步加载；而@import在页面加载完后才开始对对应CSS进行加载。 行内式通常用于开发时候的临时测试，语义不清晰，不能使用。 行内元素和块级元素行内元素不能设置宽度、高度，但是能并排显示，浏览器视行内元素为“文本流元素”。span、a、em、b、u、i。 块级元素能设置宽度和高度，但不能并排显示。div、h1~h6、ul、li、p、section、header BFCBFC 浅析 JS基本类型和引用类型基本类型 JavaScript 中有 6 中基本数据类型：Null、Undefined、Boolean、String、Number、Symbol 基本类型的值不可变 基本类型的比较是他们值的比较 基本类型存放在栈内存里的 引用类型 引用数据类型：Object 、Array 、Function 、Date 、RegExp。以上统称为 Object 类型。 引用类型的值可变 引用类型的比较是引用的比较 12345var obj1 = &#123;&#125;; var obj2 = &#123;&#125;; console.log(obj1 == obj2); // falseconsole.log(obj1 === obj2); // false因为 obj1 和 obj2 分别引用的是存放在堆内存中的2个不同的对象，故变量 obj1 和 obj2 的值（引用地址）也是不一样的。 引用类型的值是保存在堆内存（Heap）中的对象 DOM 事件类DOM 事件类 闭包闭包： 能够读取其他函数内部变量的函数。由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。 所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 闭包的用途： 一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 学习 JavaScript 闭包 详解 JS 闭包 下列JavaScript代码执行后，依次alert的结果是：1234567(function test( )&#123; var a=b=5; alert(typeof a); //number alert(typeof b); //number&#125;)()alert(typeof a); //undefined 有var 的声明alert(typeof b) //number 没有var声明 JS 中的 this在 Java 等面向对象的语言中，无论哪种情况，this 关键字的含义是明确且具体的，即代指当前对象。 但是在 JavaScript 中，this 的含义要丰富的多，它可以是全局对象、当前对象或者任意对象，这完全取决于函数的调用方式。 详解 JS 中的 this 关键字 原型相关 原型链 当从一个对象那里调用属性或方法时，如果对象自身不存在这样的属性或方法，就回去关联自己的prototype对象那里寻找，直到查找到顶级对象，如果还没有，就会返回undefined。 prototype 每个函数都有一个prototype属性。 _proto_ 这是每一个JavaScript对象(除了 null )都具有的一个属性，叫proto，这个属性会指向该对象的原型。 12345function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ === Person.prototype); // true 每个原型都有一个 constructor 属性指向关联的构造函数。 图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MongoDB教程]]></title>
    <url>%2F2017%2F11%2F13%2FMongoDB%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[概述结构型数据库传统的数据库MySQL、SQL Server、Oracle、Access都是SQL结构型数据库。 优点：查找快、有主键的概念、从键、主从查找、映射等等的高级数据库的概念。 缺点：如果今后需要增加字段，之前的所有的条目，也要一起增加。特别耗费时间，也就是说灵活性不够。 非关系型数据库MongoDB(文档型数据库)、Redis(K-V对型数据库)，他们都是NoSQL。 非关系型数据库现在已经广泛的应用于：社交平台、APP通信记录、银行流水、电信通话详单等等。任何只需要保存，但是不需要精确查找的使用场景，都可以用非关系型数据库。 MongoDB 安装下载地址：https://www.mongodb.com/download-center#community 下载完成会安装一个bin文件夹，bin文件夹中提供的 exe文件，不要双击运行，而是应该在 cmd中运行，他们是 CLI 程序。此时如果用cd命令切换进来，不方便，所以我们要把这个bin文件夹设置为环境变量，此时就能够在系统的任何一个位置，使用MongoDB的CLI命令。 总结：数据库根本不需要安装，我们仅仅下载了一个rar文件，解压缩之后，把bin路径设置为环境变量，数据库就配置好了。 数据库的开机在C盘根目录创建一个 MongoDBdata文件夹。 开启数据库： 1mongod --dbpath C:\MongoDBdata 使用mongod这个CLI来进行开机，需要配置一个参数--dbpath，表示数据库存在哪里。 使用数据库的时候，不能关闭这个CMD窗口，关闭了，数据库也关闭了。 数据库的使用 新建一个CMD窗口，用mongo命令管理数据库。 1mongo 执行上述命令会进入 mongo 内部光标。 创建一个数据库： 1use student use表示使用一个数据库，如果数据库不存在，就自动创建一个。 创建一个集合，并且插入数据 1db.banji.insert(&#123;"name":"小明","age":12,"sex":"男"&#125;); 当你使用use之后，永远用db来表示当前数据库。 db打点表示集合，现在创建了一个集合叫做banji。使用insert来插入文档，文档就是JSON。 查找全部数据 1db.banji.find(&#123;&#125;) 查询所有男生： 1db.banji.find(&#123;"sex":"男"&#125;) 查看当前数据库（就是你use的那个数据库）中有多少个集合： 1show collections 查看一共有多少数据库： 1show dbs 可视化管理工具CMD太难用了，但是以后你部署到Linux中，常用的还是CLI管理数据库。 MongoDB的可视化管理工具，最好用的就是MongoBooster，自己安装即可。 导入和导出数据 1mongoimport --db student --collection banji0910 --drop --file C:\Users\Danny\Desktop\1.json mongoimport命令负责导入数据，--db表示选择数据库，--collection表示选择集合，--drop表示删除之前的数据--file表示文件地址，注意路径可以相对，可以绝对。 当然，最简单的还是直接从可视化工具中的import按钮直接导入。 MongoDB 的 CRUD 操作CRUD就是增删改查的意思。我们先学习在shell中的操作，然后用nodejs操作Mongo。 MongoDB可以被PHP、Java、.net链接，也能被node链接，所以有很多版本。我们现在学习shell版本，在控制台中操作数据库。 1. 查找数据1db.banji.find(JSON条件) 寻找具体姓名的条目： 1db.banji.find(&#123;"name":"小明"&#125;) 且逻辑，就是JSON中多几个项目就可以了： 1db.banji0910.find(&#123;"sex":"男","age" : &#123;$gt : 11&#125;&#125;) 常见的符号$gt大于，$lt小于，$ne不等于，$in区间。 如果结构比较复杂，可以用连续打点语法。 或逻辑，寻找女生或者小于12岁的男生： 1db.banji.find(&#123;$or : [&#123;"sex" : "女"&#125;,&#123;"age" : &#123;$lt : 13&#125;&#125;]&#125;); 排序结果，用sort。 1db.banji.find(&#123;$or : [&#123;"sex" : "女"&#125;,&#123;"age" : &#123;$lt : 13&#125;&#125;]&#125;).sort(&#123;"age":-1&#125;); 1表示正序，-1表示倒序。 2. 增加数据1db.banji.insert(&#123;"name":"小丹尼","age":32,"sex":"男"&#125;) 3. 更改数据一定记住用$set引导。两个JSON，分别是更改谁、改为什么：1db.banji.update(&#123;"name":"小红"&#125;,&#123;$set:&#123;"sex" : "男"&#125;&#125;) 更改多个条目： 1db.banji0910.update(&#123;"sex":"男"&#125;,&#123;$set : &#123;"sex" : "女"&#125;&#125;,&#123; multi: true&#125;) 4. 删除条目仅仅删除一条： 1db.restaurants.remove( &#123; "borough": "Queens" &#125;, &#123; justOne: true &#125; ) 如果不写{justOne:true}就会删除所有匹配的。 删除所有年龄大于12岁的： 1db.banji.remove(&#123;"age" : &#123;$gt : 12&#125;&#125;) NodeJS 下使用 MongoDB文档 首先npm上下载一个mongodb的模块， 1npm install mongodb --save 标准DEMO： 123456789101112131415161718//得到mongo客户端var MongoClient = require('mongodb').MongoClient;//数据库地址，最后的斜杠是数据库的名字var dburl = 'mongodb://localhost:27017/student';//链接数据库MongoClient.connect(dburl, function(err, db) &#123; if(err)&#123; console.log("链接失败"); return; &#125; console.log("链接成功"); //检索banji0910集合中的所有文档 db.collection("banji0910").find(&#123;&#125;).toArray(function(err,results)&#123; console.log(results); &#125;); db.close();&#125;); 所有的CRUD操作都应该在链接数据库的回调函数里面。 插入数据： 12345678910db.collection("banji0910").insertOne(&#123;"name":"小明","age":12,"sex":"男"&#125;,function(err,r)&#123; console.log("成功插入" + r + "条数据");&#125;); 修改数据： 1234567db.collection("banji0910").updateMany( &#123;"name":"小明"&#125;, &#123;$set : &#123;"sex" : "女"&#125;&#125;, function(err,r)&#123; console.log("成功修改" + r + "条数据"); &#125; ); 删除数据，删除所有条目： 123456db.collection("banji0910").removeMany( &#123;&#125;, function(err,r)&#123; console.log("成功删除" + r + "条数据"); &#125; ); 复杂查找： 12345db.collection("banji0910").find(&#123;$or : [&#123;"sex":"女"&#125;,&#123;"age" : &#123;$lt : 13&#125;&#125;]&#125;).toArray(function(err,arr)&#123; console.log(arr); &#125;); 表单提交 HTML表单页： 12345678910111213&lt;form action="http://127.0.0.1:3000/form_post" method="post"&gt; &lt;p&gt; 姓名：&lt;input type="text" name="name"&gt; &lt;/p&gt; &lt;p&gt; 年龄：&lt;input type="text" name="age"&gt; &lt;/p&gt; &lt;p&gt; 性别：&lt;label&gt;&lt;input type="radio" name="sex" value="男"&gt;男&lt;/label&gt; &lt;label&gt;&lt;input type="radio" name="sex" value="女"&gt;女&lt;/label&gt; &lt;/p&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt; 数据库开机： 1mongod --dbpath c:\MongoDBdata 进入可视化工具使用数据库 表单处理.js 123456789101112131415var express = require("express");var formidable = require("formidable");var app = express();//当表单来了要做的事app.post('/form_post',function(req,res)&#123; //识别表单，使用 formidable 的API var form = new formidable.IncomingForm(); form.parse(req,function(err,fields,files)&#123; console.log(fields); //&#123; name: 'Beme', age: '22', sex: '男' &#125; &#125;);&#125;);app.listen(3000); 当HTML表单页做出提交时：控制台输出：1&#123; name: 'Beme', age: '22', sex: '男' &#125; 提交到 MongoDB 数据库 1234567891011121314151617181920212223242526272829var express = require("express");var formidable = require("formidable");var MongoClient = require("mongodb").MongoClient;var app = express();var dburl = "mongodb://localhost:27017/student";//当表单来了要做的事app.post('/form_post',function(req,res)&#123; //识别表单，使用 formidable 的API var form = new formidable.IncomingForm(); form.parse(req,function(err,fields,files)&#123; //连接数据库 MongoClient.connect(dburl,function(err,db)&#123; if (err) &#123; console.log("数据库连接失败"); return; &#125; //插入数据 db.collection("banji").insertOne(fields,function(err,r)&#123; res.send("成功插入"+ r + "条数据"); &#125;); db.close(); &#125;); &#125;);&#125;);app.listen(3000);]]></content>
      <categories>
        <category>Node 相关</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Koa 框架入门]]></title>
    <url>%2F2017%2F11%2F13%2FKoa-%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Koa 就是一种简单好用的 Web 框架。它的特点是优雅、简洁、表达力强、自由度高。本身代码只有1000多行，所有功能都通过插件实现，很符合 Unix 哲学。 起步：准备工作Koa 必须使用 7.6 以上的版本。如果你的版本低于这个要求，就要先升级 Node。 然后，克隆本文的配套示例库。 1$ git clone https://github.com/ruanyf/koa-demos.git 接着，进入示例库，安装依赖。 12$ cd koa-demos$ npm install 一、基本用法1.1 架设 HTTP 服务只要三行代码，就可以用 Koa 架设一个 HTTP 服务。 1234const Koa = require('koa');const app = new Koa();app.listen(3000); 运行这个脚本。打开浏览器，访问 http://127.0.0.1:3000 。你会看到页面显示”Not Found”，表示没有发现任何内容。这是因为我们并没有告诉 Koa 应该显示什么内容。 1.2 Context 对象Koa 提供一个 Context 对象，表示一次对话的上下文（包括 HTTP 请求和 HTTP 回复）。通过加工这个对象，就可以控制返回给用户的内容。 Context.response.body属性就是发送给用户的内容。 123456789const Koa = require('koa');const app = new Koa();const main = ctx =&gt; &#123; ctx.response.body = 'Hello World';&#125;;app.use(main);app.listen(3000); 上面代码中，main函数用来设置ctx.response.body。然后，使用app.use方法加载main函数。你可能已经猜到了，ctx.response代表 HTTP Response。同样地，ctx.request代表 HTTP Request。 访问 http://127.0.0.1:3000 ，现在就可以看到”Hello World”了。 1.3 HTTP Response 的类型Koa 默认的返回类型是text/plain，如果想返回其他类型的内容，可以先用ctx.request.accepts判断一下，客户端希望接受什么数据（根据 HTTP Request 的Accept字段），然后使用ctx.response.type指定返回类型。 123456789101112131415const main = ctx =&gt; &#123; if (ctx.request.accepts('xml')) &#123; ctx.response.type = 'xml'; ctx.response.body = '&lt;data&gt;Hello World&lt;/data&gt;'; &#125; else if (ctx.request.accepts('json')) &#123; ctx.response.type = 'json'; ctx.response.body = &#123; data: 'Hello World' &#125;; &#125; else if (ctx.request.accepts('html')) &#123; ctx.response.type = 'html'; ctx.response.body = '&lt;p&gt;Hello World&lt;/p&gt;'; &#125; else &#123; ctx.response.type = 'text'; ctx.response.body = 'Hello World'; &#125;&#125;; 1.4 网页模板实际开发中，返回给用户的网页往往都写成模板文件。我们可以让 Koa 先读取模板文件，然后将这个模板返回给用户。 123456const fs = require('fs');const main = ctx =&gt; &#123; ctx.response.type = 'html'; ctx.response.body = fs.createReadStream('./demos/template.html');&#125;; 二、路由2.1 原生路由网站一般都有多个页面。通过ctx.request.path可以获取用户请求的路径，由此实现简单的路由。 123456789// demos/05.jsconst main = ctx =&gt; &#123; if (ctx.request.path !== '/') &#123; ctx.response.type = 'html'; ctx.response.body = '&lt;a href="/"&gt;Index Page&lt;/a&gt;'; &#125; else &#123; ctx.response.body = 'Hello World'; &#125;&#125;; 运行这个 demo。访问 http://127.0.0.1:3000/about ，可以看到一个链接，点击后就跳到首页。 2.2 koa-route 模块原生路由用起来不太方便，我们可以使用封装好的koa-route模块。 1234567891011121314// demos/06.jsconst route = require('koa-route');const about = ctx =&gt; &#123; ctx.response.type = 'html'; ctx.response.body = '&lt;a href="/"&gt;Index Page&lt;/a&gt;';&#125;;const main = ctx =&gt; &#123; ctx.response.body = 'Hello World';&#125;;app.use(route.get('/', main));app.use(route.get('/about', about)); 上面代码中，根路径/的处理函数是main，/about路径的处理函数是about。运行这个 demo。访问 http://127.0.0.1:3000/about ，效果与上一个例子完全相同。 2.3 静态资源如果网站提供静态资源（图片、字体、样式表、脚本……），为它们一个个写路由就很麻烦，也没必要。koa-static模块封装了这部分的请求。 123456// demos/12.jsconst path = require('path');const serve = require('koa-static');const main = serve(path.join(__dirname));app.use(main); 运行这个 Demo，访问 http://127.0.0.1:3000/12.js ，在浏览器里就可以看到这个脚本的内容。 2.4 重定向有些场合，服务器需要重定向（redirect）访问请求。比如，用户登陆以后，将他重定向到登陆前的页面。ctx.response.redirect()方法可以发出一个302跳转，将用户导向另一个路由。 1234567// demos/13.jsconst redirect = ctx =&gt; &#123; ctx.response.redirect('/'); ctx.response.body = '&lt;a href="/"&gt;Index Page&lt;/a&gt;';&#125;;app.use(route.get('/redirect', redirect)); 访问 http://127.0.0.1:3000/redirect ，浏览器会将用户导向根路由。 三、中间件3.1 Logger 功能Koa 的最大特色，也是最重要的一个设计，就是中间件（middleware）。为了理解中间件，我们先看一下 Logger （打印日志）功能的实现。最简单的写法就是在main函数里面增加一行。 12345// demos/07.jsconst main = ctx =&gt; &#123; console.log(`$&#123;Date.now()&#125; $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;`); ctx.response.body = 'Hello World';&#125;; 运行并访问 http://127.0.0.1:3000 ，命令行就会输出日志。 11502144902843 GET / 3.2 中间件的概念上一个例子里面的 Logger 功能，可以拆分成一个独立函数。 123456// demos/08.jsconst logger = (ctx, next) =&gt; &#123; console.log(`$&#123;Date.now()&#125; $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;`); next();&#125;app.use(logger); 像上面代码中的logger函数就叫做”中间件”（middleware），因为它处在 HTTP Request 和 HTTP Response 中间，用来实现某种中间功能。app.use()用来加载中间件。 基本上，Koa 所有的功能都是通过中间件实现的，前面例子里面的main也是中间件。每个中间件默认接受两个参数，第一个参数是 Context 对象，第二个参数是next函数。只要调用next函数，就可以把执行权转交给下一个中间件。 运行这个 demo。访问 http://127.0.0.1:3000 ，命令行窗口会显示与上一个例子相同的日志输出。 3.3 中间件栈多个中间件会形成一个栈结构（middle stack），以”先进后出”（first-in-last-out）的顺序执行。 12345678910111213最外层的中间件首先执行。调用next函数，把执行权交给下一个中间件。...最内层的中间件最后执行。执行结束后，把执行权交回上一层的中间件。...最外层的中间件收回执行权之后，执行next函数后面的代码。 12345678910111213141516171819202122// demos/09.jsconst one = (ctx, next) =&gt; &#123; console.log('&gt;&gt; one'); next(); console.log('&lt;&lt; one');&#125;const two = (ctx, next) =&gt; &#123; console.log('&gt;&gt; two'); next(); console.log('&lt;&lt; two');&#125;const three = (ctx, next) =&gt; &#123; console.log('&gt;&gt; three'); next(); console.log('&lt;&lt; three');&#125;app.use(one);app.use(two);app.use(three); 执行结果： 123456&gt;&gt; one&gt;&gt; two&gt;&gt; three&lt;&lt; three&lt;&lt; two&lt;&lt; one 如果中间件内部没有调用next函数，那么执行权就不会传递下去。 3.4 异步中间件迄今为止，所有例子的中间件都是同步的，不包含异步操作。如果有异步操作（比如读取数据库），中间件就必须写成 async 函数。 123456789101112// demos/10.jsconst fs = require('fs.promised');const Koa = require('koa');const app = new Koa();const main = async function (ctx, next) &#123; ctx.response.type = 'html'; ctx.response.body = await fs.readFile('./demos/template.html', 'utf8');&#125;;app.use(main);app.listen(3000); 上面代码中，fs.readFile是一个异步操作，必须写成await fs.readFile()，然后中间件必须写成 async 函数。 http://127.0.0.1:3000 ，就可以看到模板文件的内容。 3.5 中间件的合成koa-compose 模块可以将多个中间件合成为一个。 1234567891011121314// demos/11.jsconst compose = require('koa-compose');const logger = (ctx, next) =&gt; &#123; console.log(`$&#123;Date.now()&#125; $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;`); next();&#125;const main = ctx =&gt; &#123; ctx.response.body = 'Hello World';&#125;;const middlewares = compose([logger, main]);app.use(middlewares); 四、错误处理4.1 500 错误如果代码运行过程中发生错误，我们需要把错误信息返回给用户。HTTP 协定约定这时要返回500状态码。Koa 提供了ctx.throw()方法，用来抛出错误，ctx.throw(500)就是抛出500错误。 1234// demos/14.jsconst main = ctx =&gt; &#123; ctx.throw(500);&#125;; 访问 http://127.0.0.1:3000，你会看到一个500错误页&quot;Internal Server Error”。 4.2 404错误如果将ctx.response.status设置成404，就相当于ctx.throw(404)，返回404错误。 12345// demos/15.jsconst main = ctx =&gt; &#123; ctx.response.status = 404; ctx.response.body = 'Page Not Found';&#125;; 访问 http://127.0.0.1:3000 ，你就看到一个404页面”Page Not Found”。 4.3 处理错误的中间件为了方便处理错误，最好使用try...catch将其捕获。但是，为每个中间件都写try...catch太麻烦，我们可以让最外层的中间件，负责所有中间件的错误处理。 123456789101112131415161718// demos/16.jsconst handler = async (ctx, next) =&gt; &#123; try &#123; await next(); &#125; catch (err) &#123; ctx.response.status = err.statusCode || err.status || 500; ctx.response.body = &#123; message: err.message &#125;; &#125;&#125;;const main = ctx =&gt; &#123; ctx.throw(500);&#125;;app.use(handler);app.use(main); 访问 http://127.0.0.1:3000 ，你会看到一个500页，里面有报错提示 {&quot;message&quot;:&quot;Internal Server Error&quot;}。 4.4 error 事件的监听运行过程中一旦出错，Koa 会触发一个error事件。监听这个事件，也可以处理错误。 12345678// demos/17.jsconst main = ctx =&gt; &#123; ctx.throw(500);&#125;;app.on('error', (err, ctx) =&gt; console.error('server error', err);); 访问 http://127.0.0.1:3000 ，你会在命令行窗口看到”server error xxx”。 4.5 释放 error 事件需要注意的是，如果错误被try...catch捕获，就不会触发error事件。这时，必须调用ctx.app.emit()，手动释放error事件，才能让监听函数生效。 1234567891011121314151617181920// demos/18.js`const handler = async (ctx, next) =&gt; &#123; try &#123; await next(); &#125; catch (err) &#123; ctx.response.status = err.statusCode || err.status || 500; ctx.response.type = 'html'; ctx.response.body = '&lt;p&gt;Something wrong, please contact administrator.&lt;/p&gt;'; ctx.app.emit('error', err, ctx); &#125;&#125;;const main = ctx =&gt; &#123; ctx.throw(500);&#125;;app.on('error', function(err) &#123; console.log('logging error ', err.message); console.log(err);&#125;); 上面代码中，main函数抛出错误，被handler函数捕获。catch代码块里面使用ctx.app.emit()手动释放error事件，才能让监听函数监听到。 访问 http://127.0.0.1:3000 ，你会在命令行窗口看到logging error。 五、Web App 的功能5.1 Cookiesctx.cookies用来读写 Cookie。 123456// demos/19.jsconst main = function(ctx) &#123; const n = Number(ctx.cookies.get('view') || 0) + 1; ctx.cookies.set('view', n); ctx.response.body = n + ' views';&#125; 访问 http://127.0.0.1:3000 ，你会看到1 views。刷新一次页面，就变成了2 views。再刷新，每次都会计数增加1。 5.2 表单Web 应用离不开处理表单。本质上，表单就是 POST 方法发送到服务器的键值对。koa-body模块可以用来从 POST 请求的数据体里面提取键值对。 12345678910// demos/20.jsconst koaBody = require('koa-body');const main = async function(ctx) &#123; const body = ctx.request.body; if (!body.name) ctx.throw(400, '.name required'); ctx.body = &#123; name: body.name &#125;;&#125;;app.use(koaBody()); 打开另一个命令行窗口，运行下面的命令。 12345$ curl -X POST --data "name=Jack" 127.0.0.1:3000&#123;"name":"Jack"&#125;$ curl -X POST --data "name" 127.0.0.1:3000name required 上面代码使用 POST 方法向服务器发送一个键值对，会被正确解析。如果发送的数据不正确，就会收到错误提示。 5.3 文件上传koa-body模块还可以用来处理文件上传。 123456789101112131415161718192021222324// demos/21.jsconst os = require('os');const path = require('path');const koaBody = require('koa-body');const main = async function(ctx) &#123; const tmpdir = os.tmpdir(); const filePaths = []; const files = ctx.request.body.files || &#123;&#125;; for (let key in files) &#123; const file = files[key]; const filePath = path.join(tmpdir, file.name); const reader = fs.createReadStream(file.path); const writer = fs.createWriteStream(filePath); reader.pipe(writer); filePaths.push(filePath); &#125; ctx.body = filePaths;&#125;;app.use(koaBody(&#123; multipart: true &#125;)); 打开另一个命令行窗口，运行下面的命令，上传一个文件。注意，/path/to/file要更换为真实的文件路径。 12$ curl --form upload=@/path/to/file http://127.0.0.1:3000["/tmp/file"] 文章来源：阮一峰：Koa 框架教程]]></content>
      <categories>
        <category>Node 相关</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块化React和Redux]]></title>
    <url>%2F2017%2F11%2F10%2F%E6%A8%A1%E5%9D%97%E5%8C%96React%E5%92%8CRedux%2F</url>
    <content type="text"><![CDATA[代码文件的组织方式1.按角色组织受 MVC “按角色组织”代码文件的影响，在Redux应用的构建中，我们把 controllers、models、views目录换成reducers、actions、components和containers。 reducers 目录包含所有Redux的reducer； actions 目录包含所有action构造函数； components 目录包含所有的傻瓜组件； containers 目录包含所有的容器组件。 虽然“按照角色组织”的方式看起来不错，但是实际上非常不利于应用的扩展。 2. 按功能组织Redux 应用适合于“按功能组织”，也就是把完成同一应用功能的代码放在一个目录下，一个应用功能包含多个角色的代码。在Redux中，不同的角色就是 reducers、actions和视图，而应用功能对应的就是用户界面上的交互模块。 拿Todo 应用为例子，这个应用的两个基本功能就是TodoList和Filter，所以代码可以这样组织： 12345678910111213141516todoList/ actions.js actionTypes.js index.js reducer.js views/ component.js container.jsfilter/ actions.js actionTypes.js index.js reducer.js views/ component.js container.js actionTypes.js 定义action类型； actions.js 定义action构造函数，决定了这个功能模块可以接受的动作； reducer.js 定义这个功能模块如何响应actions.js中定义的动作； views 目录，包含这个功能模块中所有的React组件，包括傻瓜组件和容器组件； index.js 把所有的角色导入，然后统一导出。]]></content>
      <categories>
        <category>《深入浅出React和Redux》</category>
      </categories>
      <tags>
        <tag>React学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux]]></title>
    <url>%2F2017%2F11%2F09%2FRedux%2F</url>
    <content type="text"><![CDATA[Redux实例来看一个最基本的Redux实现，首先看关于action对象的定义，和Flux 一样 Redux 应用习惯上把 action 类型和action 构造函数分成两个文件定义，其中定义 action 类型的 src/ActionTyp.js和 Flux版本没有任何差别，但是 src/Actions.js 文件就不大一样了，代码如下： 123456789101112131415import * as ActionTypes from './ActionTypes.js';export const increment = (counterCaption) =&gt; &#123; return &#123; type: ActionTypes.INCREMENT, counterCaption: counterCaption &#125;;&#125;;export const decrement = (counterCaption) =&gt; &#123; return &#123; type: ActionTypes.DECREMENT, counterCaption: counterCaption &#125;;&#125;; Redux 中每个 action 构造函数都返回一个action 对象，而 Flux 版本中 action 构造函数并不返回什么，而是把构造的动作函数立刻通过调用 Dispatcher 的dispatch 函数派发出去。 我们创造一个 src/Store.js 文件，这个文件输出全局唯一的那个 Store ，代码如下： 123456789101112import &#123;createStore&#125; from 'redux';import reducer from './Reducer.js';const initValues = &#123; 'First': 0, 'Second': 10, 'Third': 20&#125;;const store = createStore(reducer, initValues);export default store; 在这里，我们接触到了 Redux 库提供的 create Store 函数，这个函数第一个参数代表更新状态的 reducer ，第二个参数是状态的初始值，第三个参数可选。 接下来看 src/Reducer.js 中定义的 reducer 函数，代码如下： 1234567891011121314import * as ActionTypes from './ActionTypes.js';export default (state, action) =&gt; &#123; const &#123;counterCaption&#125; = action; switch (action.type) &#123; case ActionTypes.INCREMENT: return &#123;...state, [counterCaption]: state[counterCaption] + 1&#125;; case ActionTypes.DECREMENT: return &#123;...state, [counterCaption]: state[counterCaption] - 1&#125;; default: return state &#125;&#125; 代码中使用了三个句点组成的扩展操作符（spread operator），这表示把 state 中所有宇段扩展开，而后 面对 counterCaption 值对应的字段会赋上新值 像下面这样的代码这样： 1return &#123;...state, [counterCaption]: state[counterCaption] + 1&#125;; 上面的代码逻辑上等同于下面的代码： 12345const newState = Object.assign(&#123;&#125;,state);newState[counterCaption] ++;return newState; React-Redux]]></content>
      <categories>
        <category>《深入浅出React和Redux》</category>
      </categories>
      <tags>
        <tag>React学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flux框架]]></title>
    <url>%2F2017%2F11%2F09%2FFlux%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[Flux 简介在Flux的理念里，如果要改变界面，必须改变 Store 中的状态，如果要改变 Store的状态，必须派发一个 action 对象，这就是规矩。 Facebook 用 Flux 框架代替原有的 MVC 框架，他们提出的 Flux 框架大致结构如下： 一个 Flux 应用包含四个部分，我们先粗略了解一下： Dispatcher，处理动作分发，维持 Store之间的依赖关系； Store ，负责存储数据和处理数据相关逻辑； Action ，驱动 Dispatcher 的 JavaScript 对象； View ，视图部分，负责显示用户界面。 如果非要把 Flux 和 MVC 做一个结构对比，那么， Flux的 Dispatcher 相当于 MVC的Controller, Flux的 Store 相当于 MVC 的 Model, Flux的 View 当然就对应 MVC 的View了，至于多出来的这个 Action ，可以理解为对应给 MVC 框架的用户请求。 Flux 应用为了使用 Flux，首先通过命令行在项目目录下安装 Flux： 1npm install --save flux 1. Dispatcher几乎所有应用都只需要拥有一个Dispatcher，在src/AppDispatcher.js 中，我们创造这个唯Dispatcher 对象，代码如下： 123import &#123;Dispatcher&#125; from 'flux';export default new Dispatcher(); 在其他代码中，将会引用这个全局唯一的 Dispatcher 对象。Dispatcher 存在的作用，就是用来派发 action ，接下来我们就来定义应用中涉及的 action。 2. Actionaction 顾名思义代表一个“动作”，不过这个动作只是一个普通的 JavaScript 对象，代表一个动作的纯数据，类似于 DOMAPI 中的事件（ event）。 定义 action 通常需要两个文件，一个定义 action 的类型，一个定义 action 的构造函数。 分成两个文件的主要原因是在 Store 中会根据 action 类型做不同操作，也就有单独导入 action 类型的需要。 在src/ActionTypes.js中，我们定义action的类型，代码如下： 123export const INCREMENT = 'increment';export const DECREMENT = 'decrement'; 在这个例子中，用户只能做两个动作，一个是点击“＋”按钮， 一个是点击“-”按钮，所以我们只有两个 action 类型INCREMENT和 DECREMENT。 现在我们在src/Action.js 文件中定义 action 构造函数： 12345678910111213141516import * as ActionTypes from './ActionTypes.js';import AppDispatcher from './AppDispatcher.js';export const increment = (counterCaption) =&gt; &#123; AppDispatcher.dispatch(&#123; type: ActionTypes.INCREMENT, counterCaption: counterCaption &#125;);&#125;;export const decrement = (counterCaption) =&gt; &#123; AppDispatcher.dispatch(&#123; type: ActionTypes.DECREMENT, counterCaption: counterCaption &#125;);&#125;; 3. Store一个 Store 也是一个对象，这个对象存储应用状态，同时还要接受 Dispatcher 派发的动作，根据动作来决定是否要更新应用状态。 我们创造两个 Store ，一个是为 Counter 组件服务的 CounterStore ，另一个就是为总数服务的 SummaryStore 我们首先添加CounterStore，放在src/stores/CounterStore.js文件中： 12345678910111213141516171819202122232425const counterValues = &#123; 'First': 0, 'Second': 10, 'Third': 30&#125;;const CounterStore = Object.assign(&#123;&#125;, EventEmitter.prototype, &#123; getCounterValues: function() &#123; return counterValues; &#125;, emitChange: function() &#123; this.emit(CHANGE_EVENT); &#125;, addChangeListener: function(callback) &#123; this.on(CHANGE_EVENT, callback); &#125;, removeChangeListener: function(callback) &#123; this.removeListener(CHANGE_EVENT, callback); &#125;&#125;); 当Store 的状态发生变化的时候， 需要通知应用的其他部分做必要的响应，而做出响应的部分当然就是 View 部分，我们用消息的方式建立 Store 和 View 的联系。 emit 函数，可以广播一个特定 件，第一个参数是字符串类型的事件名称； on 函数，可以增加一个挂在这个EventEmitter对象特定事件上的处理函数，第一个参数是字符串类型的 事件名称，第二个参数是处理函数； removeListener 函数，和on 函数做的事情相反， 删除挂在这个 Eve ntEmitter 对象特定事件上的处理函数。 CounterStore 函数还提供一个 getCounterValues 函数，用于让应用中其他模块可以读取当前的计数值，当前的计数值存储在文件模块级的变量 counterValues中。 上面实现的 Store 只有注册到 Dispatcher实例上才能真 正发挥作用，所以还需要增下列代码： 12345678910import AppDispatcher from '../AppDispatcher.js';CounterStore.dispatchToken = AppDispatcher.register((action) =&gt; &#123; if (action.type === ActionTypes.INCREMENT) &#123; counterValues[action.counterCaption] ++; CounterStore.emitChange(); &#125; else if (action.type === ActionTypes.DECREMENT) &#123; counterValues[action.counterCaption] --; CounterStore.emitChange(); &#125;&#125;); 这是最重要的一个步骤，要把CounterStore注册到全局唯一的Dispatcher上去。 接下来，我们再来看看另一个 Store ，也就是代表所有计数器计数值总和的 Store ，在src/stores/SummaryStore.js中。这几个函数的代码和 CounterStore 中完全重复，不同点是对获取状态函数的定义，SummaryStore在 Dispatcher 上注册的回调函数也和 CounterStore 很不一样。 4. View存在于 Flux 框架中的 React 组件需要实现以下几个功能： 创建时要读取 Store 上的状态来初始化组件内部状态； 当Store上状态发生变化时，组件要立刻同步更新内部状态保持一致； View 如果要改变 Store 状态，必须而且只能派发 action。]]></content>
      <categories>
        <category>《深入浅出React和Redux》</category>
      </categories>
      <tags>
        <tag>React学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React组件的数据]]></title>
    <url>%2F2017%2F11%2F09%2FReact%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[React组件的数据React 组件的数据分为两种， prop 和state ，无论 prop 或者 state 的改变，都可能引发组件的重新渲染。prop 是组件的对外接口， state 是组件的内部状态，对外用prop ，内部用 state。 React 的 prop在React 中， prop ( property 的简写）是从外部传递给组件的数据， 一个 React 组件通过定义自己能够接受的 prop 就定义了自己的对外公共接口。 每个 React 组件都是独立存在的模块，组件之外的一切都是外部世界，外部世界就是通过 prop 来和组件对话的。 1. 给 prop 赋值我们先从外部世界来看， prop 是如何使用的，在下面的 JSX 代码片段中，就使用了 prop: 1234&lt;SampleButtonid="sample" borderWidth=&#123;2&#125; onClick=&#123;onButtonClick&#125;style=&#123;&#123;color :"red"&#125;&#125;/&gt; 在上面的例子中，创建了名为 SampleButton 的组件实例，使用了名字分别为 id、 borderWidth 、onClick 和style的 prop。当 prop 的类型不是字符串类型时，在 JSX 中必须用花括号｛｝把 prop 值包住，所以 style 的值有两层花括号，外层花括号代表是 JSX语法，内层的花括号代表这是一个对象常量。 2. 读取 prop 值如果一个组件需要定义自己的构造函数，一定要记得在构造函数的第一行通过 super调用父类也就是 React.Component 的构造函数 如果在构造函数中没有调用 super(props),那么组件实例被构造之后，类实例的所有成员函数就无法通过 this.props 访问到父组件传递过来的 props 值。很明显，给 this.props 赋值是 React. Component 构造函数的工作之一。 在构造函数的最后，我们可以看到读取传入 prop 的方法，在构造函数中可以通过参数props 获得传入 prop 值，在其他函数中则可以通过 this.props 访问传入 prop 的值，比如在 Counter 组件的 render 函数中，我们就是通过 this.props 获得传入的 caption。 React 的 state驱动组件渲染过程的除了 prop ，还有 state, state 代表组件的内部状态。 1. 初始化 state通常在组件类的构造函数结尾处初始化 state ，在 Counter 构造函数中，通过对 this.state 的赋值完成了对组件 state 的初始化。 2. 读取和更新 state在代码中，通过 this.state 可以读取到组件的当前 state。 值得注意的是，我们改变组件state 必须要使用 this.setState 函数，而不能直接去修改 this.state。 this.setState （）函数所做的事情，首先是改变 this.state 的值，然后驱动组件经历更新过程，这样才有机会让 this.state 里新的值出现在界面。 3. prop 和 state 的对比 prop 用于定义外部接口， state 用于记录内部状态； prop 的赋值在外部世界使用组件时， state 的赋值在组件内部； 组件不应该改变 prop 的值，而 state 存在的目的就是让组件来改变的。 组件的 state ，就相当于组件的记忆，其存在意义就是被修改，每一次通过 this.setState函数修改 state 就改变了组件的状态，然后通过渲染过程把这种变化体现出来。 组件的生命周期React 严格定义了组件的生命周期，生命周期可能会经历如下三个过程： 装载过程（Mount ），也就是把组件第一次在 DOM 树中渲染的过程； 更新过程（Update ），当组件被重新渲染的过程； 卸载过程（Unmount ），组件从 DOM 中删除的过程。 三种不同的过程， React 库会依次调用组件的一些成员函数，这些函数称为生命周期函数。 装载过程当组件第一次被渲染的时候，依次调用的函数是如下这些： constructor getlnitialState getDefaultProps componentWillMount render componentDidMount 1. constructor我们先来看第一个 constructor ，也就是 ES6 中每个类的构造函数，要创造一个组件类的实例，当然会调用对应的构造函数。 要注意，并不是每个组件都需要定义自己的构造函数。在后面的章节我们可以看到，无状态的 React 组件往往就不需要定义构造函数，一个 React 组件需要构造函数，往往是为了下面的目的： 初始化 state ，因为组件生命周期中任何函数都可能要访问 state ，那么整个生命周期中第一个被调用的构造函数自然是初始化 state 最理想的地方； 绑定成员函数的 this 环境。 在ES6 语法下，类的每个成员函数在执行时的 this 并不是和类实例自动绑定的。而在构造函数中， this 就是当前组件实例，所以，为了方便将来的调用，往往在构造函数中将这个实例的特定函数绑定 this 为当前实例。 以Counter 组件为例，我们的构造函数有这样如下的代码： 12this.onClickIncrementButton = this.onClickIncrementButton.bind(this);this.onClickDecrementButton = this.onClickDecrementButton.bind(this); 这两条语句的作用，就是通过 bind 方法让当前实例中 onClicklncrementButton和onClickDecrementButton 函数被调用时， this 始终是指向当前组件实例。 2. getlnitialState 和 getDefaultPropsgetlnitialState 这个函数的返回值会用来初始化组件的 this.state ，但是，这个方法只有用 React. createClass 方法创造的组件类才会发生作用。 总之， getlnitialState和getDefaultProps 两个方法在 ES6 的方法定义的 React 组件中根本不会用到。 3. renderrender函数是 React组件中最重要的函数，render 函数并不做实际的渲染动作，它只是返回一个 JSX 描述的结构，最终由 React 来操作渲染过程。 在 render 函数中去调用 this.setState 毫无疑问是错误的，因为一个纯函数不应该引起状态的改变。 4. componentWillMount 和 componentDidMount在装载过程中， componentWillMount 会在调用 render 函数之前被调用， componentDidMount会在调用 render 函数之后被调用，这两个函数就像是 render 函数的前哨和后卫，一前一后，把 render 函数夹住，正好分别做 render 前后必要的工作。 更新过程当组件被装载到 DOM 树上之后，用户在网页上可以看到组件的第一印象，但是要提供更好的交互体验，就要让该组件可以随着用户操作改变展现的内容，当 props 或者state 被修改的时候，就会引发组件的更新过程。 更新过程会依次调用下面的生命周期函数，其中 render 函数和装载过程一样，没有差别。 componentWillReceiveProps shouldComponentUpdate componentWillUpdate render componentDidUpdate 卸载过程React 组件的卸载过程只涉及一个函数componentWillUnmount ，当React 组件要从DOM 树上删除掉之前，对应的 componentWillUnmount 函数会被调用，所以这个函数适合做一些清理性的工作。]]></content>
      <categories>
        <category>《深入浅出React和Redux》</category>
      </categories>
      <tags>
        <tag>React学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编写易于维护的组件]]></title>
    <url>%2F2017%2F11%2F09%2F%E7%BC%96%E5%86%99%E6%98%93%E4%BA%8E%E7%BB%B4%E6%8A%A4%E7%9A%84%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[作为软件设计的通则，组件的划分要满足高内聚（High Cohesion）和低搞合（LowCoupling）的原则。 高内聚指的是把逻辑紧密相关的内容放在一个组件中。用户界面无外乎内容 交互行为和样式 传统上，内容由 HTML 表示，交互行放在 JavaScript 代码文件中，样式放css 文件中定义 这虽然满足一个功能模块的需要，却要放在三个不同的文件中，这其实不满足高内聚的原则 React 却不是这样，展示内容的 JSX 、定义行为的 JavaScript代码，甚至定义样式的 css ，都可以放在一个 JavaScript 文件中，因为它们本来就是为了实现 个目的而存在的，所以说 React 天生具有高内聚的特点。 低辑合指的是不同组件之间的依赖关系要尽量弱化，也就是每个组件要尽量独立保持整个系统的低搞合度，需要对系统中的功能有充分的认识，然后根据功能点划分模块，让不同的组件去实现不同的功能，这个功夫还在开发者身上，不过， React 组件的对外接口非常规范，方便开发者设计低祸合的系统。]]></content>
      <categories>
        <category>《深入浅出React和Redux》</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React思维方式]]></title>
    <url>%2F2017%2F11%2F09%2FReact%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[环境搭建初始化在默认已有 node 环境下，先安装脚手架： 1npm install create-react-app -g 我们在命令行中执行下面的命令： 1create-react-app first_react_app 这个命令会在当前目录下创建一个名为 first_react_app 的目录，在这个目录中会自动添加一个应用的框架，随后我们只需要在这个框架的基础上修改文件就可以开发 React应用，避免了大量的手工配置工作： 12cd first_react_appnpm start 启动项目。 第一个组件在 first-react-app 目录下包含如下文件和目录： 12345src/public/README.mdpackage.jsonnode modules/ 在开发过程中，我们主要关注 src 目录中的内容，这个目录中是所有的源代码。create-react-app 所创建的应用的入口是 src/index,js 文件，代码如下： 12345678import React from 'react';import ReactDOM from 'react-dom';import './index.css';import App from './App';import registerServiceWorker from './registerServiceWorker';ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));registerServiceWorker(); 我们要定义一个新的能够计算点击数组件，名叫 ClickCounter ，所以我们修改 indexjs 文件如下： 12345678import React from 'react';import ReactDOM from 'react-dom';import './index.css';import ClickCounter from './ClickCounter';import registerServiceWorker from './registerServiceWorker';ReactDOM.render(&lt;ClickCounter /&gt;, document.getElementById('root'));registerServiceWorker(); 在 src 目录下增加一个新的代码文件 ClickCounter.js，代码如下： 123456789101112131415161718192021222324import React,&#123;Component&#125; from 'react';class ClickCounter extends Component&#123; constructor(props)&#123; super(props); this.onClickButton=this.onClickButton.bind(this); this.state=&#123;count:0&#125;; &#125; onClickButton()&#123; this.setState(&#123;count:this.state.count+1&#125;); &#125; render()&#123; return( &lt;div&gt; &lt;button onClick=&#123;this.onClickButton&#125;&gt;Click Me&lt;/button&gt; &lt;div&gt; Click Count:&#123;this.state.count&#125; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default ClickCounter; Component 作为所有组件的基类，提供了很多组件共有的功能，下面这行代码，使用的是 ES6 语法来创建一个叫 ClickCounter 的组件类， ClickCounter 的父类就是 Component: 1class ClickCounter extends Component&#123; 除了在组件中定义交互行为，我们还可以在 React 组件中定义样式，我们可以修改ClickCounter.js 中的 render 函数，代码如下： 1234567891011121314render()&#123; const counterStyle=&#123; margin:'16px', color:'red' &#125; return( &lt;div style=&#123;counterStyle&#125;&gt; &lt;button onClick=&#123;this.onClickButton&#125;&gt;Click Me&lt;/button&gt; &lt;div&gt; Click Count:&#123;this.state.count&#125; &lt;/div&gt; &lt;/div&gt; ); &#125; 分解 React 应用我们启动 React 应用的命令是 npm start ，看一看 package.json 中对 start 脚本的定义，如下所示： 123456"scripts": &#123; "start": "react-scripts start", "build": "react-scripts build", "test": "react-scripts test --env=jsdom", "eject": "react-scripts eject" &#125; 其中 build 可以创建生产环境优化代码，test 用于单元测试，这个 eject （弹射）命令做的事情，就是把潜藏在 react-scripts 中的一系列技术找配置都“弹射”到应用的顶层，然后我们就可以研究这些配置细节了，而且可以更灵活地定制应用的配置。]]></content>
      <categories>
        <category>《深入浅出React和Redux》</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Redux的用法]]></title>
    <url>%2F2017%2F08%2F30%2FReact-Redux%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、UI 组件React-Redux 将所有组件分成两大类：UI 组件和容器组件。UI 组件有以下特征：1234567只负责 UI 的呈现，不带有任何业务逻辑没有状态（即不使用 this.state 这个变量）所有数据都由参数（this.props）提供不使用任何 Redux 的 API 下面就是一个 UI 组件的例子。 12const Title = value =&gt; &lt;h1&gt;&#123;value&#125;&lt;/h1&gt;; 因为不含有状态，UI 组件又称为”纯组件”，即它纯函数一样，纯粹由参数决定它的值。 二、容器组件容器组件的特诊恰恰相反：12345负责管理数据和业务逻辑，不负责 UI 的呈现带有内部状态使用 Redux 的 API 如果一个组件既有 UI 又有业务逻辑，那么将它拆分成下面的结构：外面是一个容器组件，里面包了一个UI 组件。前者负责与外部的通信，将数据传给后者，由后者渲染出视图。 React-Redux 规定，所有的 UI 组件都由用户提供，容器组件则是由 React-Redux 自动生成。也就是说，用户负责视觉层，状态管理则是全部交给它。 三、connect()React-Redux 提供 connect 方法，用于从 UI 组件生成容器组件。connect 的意思，就是将这两种组件连起来。 12import &#123; connect &#125; from 'react-redux'const VisibleTodoList = connect()(TodoList); 上面代码中，TodoList是 UI 组件，VisibleTodoList就是由 React-Redux 通过connect方法自动生成的容器组件。 但是，因为没有定义业务逻辑，上面这个容器组件毫无意义，只是 UI 组件的一个单纯的包装层。为了定义业务逻辑，需要给出下面两方面的信息。 12（1）输入逻辑：外部的数据（即state对象）如何转换为 UI 组件的参数（2）输出逻辑：用户发出的动作如何变为 Action 对象，从 UI 组件传出去。 因此，connect方法的完整 API 如下。 123456import &#123; connect &#125; from 'react-redux'const VisibleTodoList = connect( mapStateToProps, mapDispatchToProps)(TodoList) 上面代码中，connect方法接受两个参数：mapStateToProps和mapDispatchToProps。它们定义了 UI 组件的业务逻辑。前者负责输入逻辑，即将state映射到 UI 组件的参数（props），后者负责输出逻辑，即将用户对 UI 组件的操作映射成 Action。 四、mapStateToProps()mapStateToProps是一个函数。它的作用就是像它的名字那样，建立一个从（外部的）state对象到（UI 组件的）props对象的映射关系。作为函数，mapStateToProps执行后应该返回一个对象，里面的每一个键值对就是一个映射。请看下面的例子。 12345const mapStateToProps = (state) =&gt; &#123; return &#123; todos: getVisibleTodos(state.todos, state.visibilityFilter) &#125;&#125; 上面代码中，mapStateToProps是一个函数，它接受state作为参数，返回一个对象。这个对象有一个todos属性，代表 UI 组件的同名参数，后面的getVisibleTodos也是一个函数，可以从state算出todos的值。 下面就是getVisibleTodos的一个例子，用来算出todos。 123456789101112const getVisibleTodos = (todos, filter) =&gt; &#123; switch (filter) &#123; case 'SHOW_ALL': return todos case 'SHOW_COMPLETED': return todos.filter(t =&gt; t.completed) case 'SHOW_ACTIVE': return todos.filter(t =&gt; !t.completed) default: throw new Error('Unknown filter: ' + filter) &#125;&#125; mapStateToProps会订阅 Store，每当state更新的时候，就会自动执行，重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染。 mapStateToProps的第一个参数总是state对象，还可以使用第二个参数，代表容器组件的props对象。 12345678910// 容器组件的代码// &lt;FilterLink filter="SHOW_ALL"&gt;// All// &lt;/FilterLink&gt;const mapStateToProps = (state, ownProps) =&gt; &#123; return &#123; active: ownProps.filter === state.visibilityFilter &#125;&#125; 使用ownProps作为参数后，如果容器组件的参数发生变化，也会引发 UI 组件重新渲染。 connect方法可以省略mapStateToProps参数，那样的话，UI 组件就不会订阅Store，就是说 Store 的更新不会引起 UI 组件的更新。 五、mapDispatchToProps()mapDispatchToProps是connect函数的第二个参数，用来建立 UI 组件的参数到store.dispatch方法的映射。也就是说，它定义了哪些用户的操作应该当作 Action，传给 Store。它可以是一个函数，也可以是一个对象。如果mapDispatchToProps是一个函数，会得到dispatch和ownProps（容器组件的props对象）两个参数。 12345678910111213const mapDispatchToProps = ( dispatch, ownProps) =&gt; &#123; return &#123; onClick: () =&gt; &#123; dispatch(&#123; type: 'SET_VISIBILITY_FILTER', filter: ownProps.filter &#125;); &#125; &#125;;&#125; 从上面代码可以看到，mapDispatchToProps作为函数，应该返回一个对象，该对象的每个键值对都是一个映射，定义了 UI 组件的参数怎样发出 Action。 如果mapDispatchToProps是一个对象，它的每个键名也是对应 UI 组件的同名参数，键值应该是一个函数，会被当作 Action creator ，返回的 Action 会由 Redux 自动发出。举例来说，上面的mapDispatchToProps写成对象就是下面这样。 123456const mapDispatchToProps = &#123; onClick: (filter) =&gt; &#123; type: 'SET_VISIBILITY_FILTER', filter: filter &#125;;&#125; 六、 组件connect方法生成容器组件以后，需要让容器组件拿到state对象，才能生成 UI 组件的参数。 一种解决方法是将state对象作为参数，传入容器组件。但是，这样做比较麻烦，尤其是容器组件可能在很深的层级，一级级将state传下去就很麻烦。 React-Redux 提供Provider组件，可以让容器组件拿到state。 12345678910111213import &#123; Provider &#125; from 'react-redux'import &#123; createStore &#125; from 'redux'import todoApp from './reducers'import App from './components/App'let store = createStore(todoApp);render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root')) 上面代码中，Provider在根组件外面包了一层，这样一来，App的所有子组件就默认都可以拿到state了。它的原理是React组件的context属性，请看源码。 1234567891011121314class Provider extends Component &#123; getChildContext() &#123; return &#123; store: this.props.store &#125;; &#125; render() &#123; return this.props.children; &#125;&#125;Provider.childContextTypes = &#123; store: React.PropTypes.object&#125; 上面代码中，store放在了上下文对象context上面。然后，子组件就可以从context拿到store，代码大致如下。 12345678910111213141516171819class VisibleTodoList extends Component &#123; componentDidMount() &#123; const &#123; store &#125; = this.context; this.unsubscribe = store.subscribe(() =&gt; this.forceUpdate() ); &#125; render() &#123; const props = this.props; const &#123; store &#125; = this.context; const state = store.getState(); // ... &#125;&#125;VisibleTodoList.contextTypes = &#123; store: React.PropTypes.object&#125; React-Redux自动生成的容器组件的代码，就类似上面这样，从而拿到store。 七、实例：计数器下面是一个计数器组件，它是一个纯的 UI 组件。 1234567891011class Counter extends Component &#123; render() &#123; const &#123; value, onIncreaseClick &#125; = this.props return ( &lt;div&gt; &lt;span&gt;&#123;value&#125;&lt;/span&gt; &lt;button onClick=&#123;onIncreaseClick&#125;&gt;Increase&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 上面代码中，这个 UI 组件有两个参数：value和onIncreaseClick。前者需要从state计算得到，后者需要向外发出 Action。 接着，定义value到state的映射，以及onIncreaseClick到dispatch的映射。 1234567891011121314function mapStateToProps(state) &#123; return &#123; value: state.count &#125;&#125;function mapDispatchToProps(dispatch) &#123; return &#123; onIncreaseClick: () =&gt; dispatch(increaseAction) &#125;&#125;// Action Creatorconst increaseAction = &#123; type: 'increase' &#125; 然后，使用connect方法生成容器组件。 1234const App = connect( mapStateToProps, mapDispatchToProps)(Counter) 然后，定义这个组件的 Reducer。 12345678910// Reducerfunction counter(state = &#123; count: 0 &#125;, action) &#123; const count = state.count switch (action.type) &#123; case 'increase': return &#123; count: count + 1 &#125; default: return state &#125;&#125; 最后，生成store对象，并使用Provider在根组件外面包一层。 1234567891011121314151617181920import &#123; loadState, saveState &#125; from './localStorage';const persistedState = loadState();const store = createStore( todoApp, persistedState);store.subscribe(throttle(() =&gt; &#123; saveState(&#123; todos: store.getState().todos, &#125;)&#125;, 1000))ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root')); 完整的代码看这里。 八、React-Router 路由库使用React-Router的项目，与其他项目没有不同之处，也是使用Provider在Router外面包一层，毕竟Provider的唯一功能就是传入store对象。 1234567const Root = (&#123; store &#125;) =&gt; ( &lt;Provider store=&#123;store&#125;&gt; &lt;Router&gt; &lt;Route path="/" component=&#123;App&#125; /&gt; &lt;/Router&gt; &lt;/Provider&gt;);]]></content>
      <categories>
        <category>React学习</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux入门（一）]]></title>
    <url>%2F2017%2F08%2F27%2FRedux%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、设计思想Redux 的设计思想很简单，就两句话。 123（1）Web 应用是一个状态机，视图与状态是一一对应的。（2）所有的状态，保存在一个对象里面。 下面就是详细解释。 二、基本概念和 API2.1 StoreStore 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。Redux 提供 createStore这个函数，用来生成 Store。12import &#123; createStore &#125; from 'redux';const store = createStore(fn); 上面代码中，createStore函数接受另一个函数作为参数，返回新生成的 Store 对象。 2.2 StateStore对象包含所有数据。如果想得到某个时点的数据，就要对 Store 生成快照。这种时点的数据集合，就叫做 State。 当前时刻的 State，可以通过store.getState()拿到。 1234import &#123; createStore &#125; from 'redux';const store = createStore(fn);const state = store.getState(); Redux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然。 2.3 ActionState 的变化，会导致 View 的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了。 Action 是一个对象。其中的type属性是必须的，表示 Action 的名称。其他属性可以自由设置，社区有一个规范可以参考。 1234const action = &#123; type: 'ADD_TODO', payload: 'Learn Redux'&#125;; 上面代码中，Action 的名称是ADD_TODO，它携带的信息是字符串Learn Redux。 可以这样理解，Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store。 2.4 Action CreatorView 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦。可以定义一个函数来生成 Action，这个函数就叫 Action Creator。 12345678910const ADD_TODO = '添加 TODO';function addTodo(text) &#123; return &#123; type: ADD_TODO, text &#125;&#125;const action = addTodo('Learn Redux'); 上面代码中，addTodo函数就是一个 Action Creator。 2.5 store.dispatch()store.dispatch()是 View 发出 Action 的唯一方法。 1234567import &#123; createStore &#125; from 'redux';const store = createStore(fn);store.dispatch(&#123; type: 'ADD_TODO', payload: 'Learn Redux'&#125;); 上面代码中，store.dispatch接受一个 Action 对象作为参数，将它发送出去。 结合 Action Creator，这段代码可以改写如下。 1store.dispatch(addTodo('Learn Redux')); 2.6 ReducerStore 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。 Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。 1234const reducer = function (state, action) &#123; // ... return new_state;&#125;; 整个应用的初始状态，可以作为 State 的默认值。下面是一个实际的例子。 1234567891011121314const defaultState = 0;const reducer = (state = defaultState, action) =&gt; &#123; switch (action.type) &#123; case 'ADD': return state + action.payload; default: return state; &#125;&#125;;const state = reducer(1, &#123; type: 'ADD', payload: 2&#125;); 上面代码中，reducer函数收到名为ADD的 Action 以后，就返回一个新的 State，作为加法的计算结果。其他运算的逻辑（比如减法），也可以根据 Action 的不同来实现。 实际应用中，Reducer 函数不用像上面这样手动调用，store.dispatch方法会触发 Reducer 的自动执行。为此，Store 需要知道 Reducer 函数，做法就是在生成 Store 的时候，将 Reducer 传入createStore方法。 12import &#123; createStore &#125; from 'redux';const store = createStore(reducer); 上面代码中，createStore接受 Reducer 作为参数，生成一个新的 Store。以后每当store.dispatch发送过来一个新的 Action，就会自动调用 Reducer，得到新的 State。 为什么这个函数叫做 Reducer 呢？因为它可以作为数组的reduce方法的参数。请看下面的例子，一系列 Action 对象按照顺序作为一个数组。 1234567const actions = [ &#123; type: 'ADD', payload: 0 &#125;, &#123; type: 'ADD', payload: 1 &#125;, &#123; type: 'ADD', payload: 2 &#125;];const total = actions.reduce(reducer, 0); // 3 上面代码中，数组actions表示依次有三个 Action，分别是加0、加1和加2。数组的reduce方法接受 Reducer 函数作为参数，就可以直接得到最终的状态3。 2.7 纯函数Reducer 函数最重要的特征是，它是一个纯函数。也就是说，只要是同样的输入，必定得到同样的输出。纯函数是函数式编程的概念，必须遵守以下一些约束。 12345不得改写参数不能调用系统 I/O 的API不能调用Date.now()或者Math.random()等不纯的方法，因为每次会得到不一样的结果 由于 Reducer 是纯函数，就可以保证同样的State，必定得到同样的 View。但也正因为这一点，Reducer 函数里面不能改变 State，必须返回一个全新的对象，请参考下面的写法。 1234567891011// State 是一个对象function reducer(state, action) &#123; return Object.assign(&#123;&#125;, state, &#123; thingToChange &#125;); // 或者 return &#123; ...state, ...newState &#125;;&#125;// State 是一个数组function reducer(state, action) &#123; return [...state, newItem];&#125; 最好把 State 对象设成只读。你没法改变它，要得到新的 State，唯一办法就是生成一个新对象。这样的好处是，任何时候，与某个 View 对应的 State 总是一个不变的对象。 2.8 store.subscribe()Store 允许使用store.subscribe方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。 1234import &#123; createStore &#125; from 'redux';const store = createStore(reducer);store.subscribe(listener); 显然，只要把 View 的更新函数（对于 React 项目，就是组件的render方法或setState方法）放入listen，就会实现 View 的自动渲染。 store.subscribe方法返回一个函数，调用这个函数就可以解除监听。 12345let unsubscribe = store.subscribe(() =&gt; console.log(store.getState()));unsubscribe(); 三、Store的实现上一节介绍了 Redux 涉及的基本概念，可以发现 Store 提供了三个方法。 12345store.getState()store.dispatch()store.subscribe() 123import &#123; createStore &#125; from 'redux';let &#123; subscribe, dispatch, getState &#125; = createStore(reducer); createStore方法还可以接受第二个参数，表示 State 的最初状态。这通常是服务器给出的。 1let store = createStore(todoApp, window.STATE_FROM_SERVER) 上面代码中，window.STATE_FROM_SERVER就是整个应用的状态初始值。注意，如果提供了这个参数，它会覆盖 Reducer 函数的默认初始值。 下面是createStore方法的一个简单实现，可以了解一下 Store 是怎么生成的。 1234567891011121314151617181920212223const createStore = (reducer) =&gt; &#123; let state; let listeners = []; const getState = () =&gt; state; const dispatch = (action) =&gt; &#123; state = reducer(state, action); listeners.forEach(listener =&gt; listener()); &#125;; const subscribe = (listener) =&gt; &#123; listeners.push(listener); return () =&gt; &#123; listeners = listeners.filter(l =&gt; l !== listener); &#125; &#125;; dispatch(&#123;&#125;); return &#123; getState, dispatch, subscribe &#125;;&#125;; 四、Reducer 的拆分Reducer 函数负责生成 State。由于整个应用只有一个 State 对象，包含所有数据，对于大型应用来说，这个 State 必然十分庞大，导致 Reducer 函数也十分庞大。 请看下面的例子。 123456789101112131415161718const chatReducer = (state = defaultState, action = &#123;&#125;) =&gt; &#123; const &#123; type, payload &#125; = action; switch (type) &#123; case ADD_CHAT: return Object.assign(&#123;&#125;, state, &#123; chatLog: state.chatLog.concat(payload) &#125;); case CHANGE_STATUS: return Object.assign(&#123;&#125;, state, &#123; statusMessage: payload &#125;); case CHANGE_USERNAME: return Object.assign(&#123;&#125;, state, &#123; userName: payload &#125;); default: return state; &#125;&#125;; 上面代码中，三种 Action 分别改变 State 的三个属性。 12345ADD_CHAT：chatLog属性CHANGE_STATUS：statusMessage属性CHANGE_USERNAME：userName属性 这三个属性之间没有联系，这提示我们可以把 Reducer 函数拆分。不同的函数负责处理不同属性，最终把它们合并成一个大的 Reducer 即可。 1234567const chatReducer = (state = defaultState, action = &#123;&#125;) =&gt; &#123; return &#123; chatLog: chatLog(state.chatLog, action), statusMessage: statusMessage(state.statusMessage, action), userName: userName(state.userName, action) &#125;&#125;; 上面代码中，Reducer 函数被拆成了三个小函数，每一个负责生成对应的属性。 这样一拆，Reducer 就易读易写多了。而且，这种拆分与 React 应用的结构相吻合：一个 React 根组件由很多子组件构成。这就是说，子组件与子 Reducer 完全可以对应。 Redux 提供了一个combineReducers方法，用于 Reducer 的拆分。你只要定义各个子 Reducer 函数，然后用这个方法，将它们合成一个大的 Reducer。 123456789import &#123; combineReducers &#125; from 'redux';const chatReducer = combineReducers(&#123; chatLog, statusMessage, userName&#125;)export default todoApp; 上面的代码通过combineReducers方法将三个子 Reducer 合并成一个大的函数。 这种写法有一个前提，就是 State 的属性名必须与子 Reducer 同名。如果不同名，就要采用下面的写法。 1234567891011121314const reducer = combineReducers(&#123; a: doSomethingWithA, b: processB, c: c&#125;)// 等同于function reducer(state = &#123;&#125;, action) &#123; return &#123; a: doSomethingWithA(state.a, action), b: processB(state.b, action), c: c(state.c, action) &#125;&#125; 总之，combineReducers()做的就是产生一个整体的 Reducer 函数。该函数根据 State 的 key 去执行相应的子 Reducer，并将返回结果合并成一个大的 State 对象。 下面是combineReducer的简单实现。 1234567891011const combineReducers = reducers =&gt; &#123; return (state = &#123;&#125;, action) =&gt; &#123; return Object.keys(reducers).reduce( (nextState, key) =&gt; &#123; nextState[key] = reducers[key](state[key], action); return nextState; &#125;, &#123;&#125; ); &#125;;&#125;; 你可以把所有子 Reducer 放在一个文件里面，然后统一引入。 1234import &#123; combineReducers &#125; from 'redux'import * as reducers from './reducers'const reducer = combineReducers(reducers) 五、工作流程本节对 Redux 的工作流程，做一个梳理。 首先，用户发出 Action。 1store.dispatch(action); 然后，Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action。 Reducer 会返回新的 State 。 1let nextState = todoApp(previousState, action); State 一旦有变化，Store 就会调用监听函数。 12// 设置监听函数store.subscribe(listener); listener可以通过store.getState()得到当前状态。如果使用的是 React，这时可以触发重新渲染 View。 1234function listerner() &#123; let newState = store.getState(); component.setState(newState); &#125; 六、实例：计数器下面我们来看一个最简单的实例。 12345678910111213const Counter = (&#123; value &#125;) =&gt; ( &lt;h1&gt;&#123;value&#125;&lt;/h1&gt;);const render = () =&gt; &#123; ReactDOM.render( &lt;Counter value=&#123;store.getState()&#125;/&gt;, document.getElementById('root') );&#125;;store.subscribe(render);render(); 上面是一个简单的计数器，唯一的作用就是把参数value的值，显示在网页上。Store 的监听函数设置为render，每次 State 的变化都会导致网页重新渲染。下面加入一点变化，为Counter添加递增和递减的 Action。 1234567891011121314151617181920212223242526272829const Counter = (&#123; value &#125;) =&gt; ( &lt;h1&gt;&#123;value&#125;&lt;/h1&gt; &lt;button onClick=&#123;onIncrement&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;onDecrement&#125;&gt;-&lt;/button&gt;);const reducer = (state = 0, action) =&gt; &#123; switch (action.type) &#123; case 'INCREMENT': return state + 1; case 'DECREMENT': return state - 1; default: return state; &#125;&#125;;const store = createStore(reducer);const render = () =&gt; &#123; ReactDOM.render( &lt;Counter value=&#123;store.getState()&#125; onIncrement=&#123;() =&gt; store.dispatch(&#123;type: 'INCREMENT'&#125;)&#125; onDecrement=&#123;() =&gt; store.dispatch(&#123;type: 'DECREMENT'&#125;)&#125; /&gt;, document.getElementById('root') );&#125;;render();store.subscribe(render); 完整的代码请看这里。 转自阮一峰Redux 入门教程（一）：基本用法]]></content>
      <categories>
        <category>React学习</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习（三）]]></title>
    <url>%2F2017%2F08%2F26%2FReact%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、ECMAScript2016 引包import 是 ECMAScript 2016的最新语法。如果加上大括号引用一个模块： 1import &#123;fn,fn2&#125; from "./a.js"; 表示：用fn来接受 a 模块中的exports.fn= function(){} 用fn2来接受 a 模块中的exports.fn2=function(){} 如果一个模块是一个类，它是这么写的： 1234567891011class People&#123; constructor(name)&#123; this.name = name; &#125; sayHello()&#123; alert("哈哈，我是" + this.name); &#125;&#125;export default People; //注意这里的ECMAScript2016的暴露语法 此时引包就不能加大括号： 1import People from "./People.js" 注意ECMAScript2016中定义类的语法： 12345678910111213class 类名&#123; constructor()&#123; &#125; 类的实例方法1()&#123; &#125; 类的实例方法2()&#123; &#125;&#125; 二、webpack-dev-serverThe webpack-dev-server is a little Node.js Express server。可以模拟一个服务器，底层是nodejs+express，让我们的前端代码可以不在阿帕奇中但是快速能够获得一个服务器环境。并且是自动检测代码改变的，可以替代之前的watch功能。 安装： 1cnpm install webpack-dev-server --save-dev 然后在package.json中创建一个 script： 123456789101112131415&#123; "name": "webpack_dev_server_study", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "start": "webpack-dev-server" &#125;, "author": "", "license": "ISC", "devDependencies": &#123; "webpack": "^2.2.1", "webpack-dev-server": "^2.3.0" &#125;&#125; 此时我们加上的start表示一会儿可以用npm run start来运行程序，此时npm将帮助我们敲击webpack-dev-server命令。 此时webpack.config.js文件，多了一条output设置： 1234567891011var path = require("path");module.exports = &#123; entry: &#123; app: ["./js/main.js"] &#125;, output: &#123; path: path.resolve(__dirname, "dist"), publicPath: "/mydist/", filename: "bundle.js" &#125;&#125;; publicPath表示要将我们的文件编译到哪个虚拟地址。注意，编译出的文件bundle.js不会真正的生成，就是说你用资源管理器看不见这个文件。但是webpack_dev_server在后台帮我们用express增加了一个路由，路由正是用publicPath来定义的： 此时npm run start就可以打开http://127.0.0.1:8080/来查看项目。8080 端口是webpack_dev_server的默认端口。 除了publicPath之外呢，webpack.config.js文件没有任何变化，在文件中不会体现这个东西将会开启一个服务器。也就是说体现开启服务器，就是在package.json中配置一个script。实时监听的，任何文件变化，都会立即更改，由于不用写文件，所以要比watch要快。]]></content>
      <categories>
        <category>React学习</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习（二）]]></title>
    <url>%2F2017%2F08%2F25%2FReact%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、webpack学习1.1 前端工程化概述在前端开发的初始阶段，开发者通常只用关心html，css，javascript。但由于 项目变得越来越大 迭代更新越来越频繁 团队合作越来越多紧密 对编程体验要求越来越高 逐步形成了很多“最佳实践”。有很多免费的工具都可以使用。这些工具都是依赖Node.js的。 包管理工具：依赖越来越复杂（实际上没有那么复杂），所以此时就利用bower和npm可以有效管理依赖。package.json文件和bower.json文件很好用，可以看见项目的后台依赖、前端依赖。 脚手架：现在的项目结构挺复杂，比如react+angular就要配半天，所以为了方便你起步，出现了yeman、slush。 前端工作流工具：比如gulp、grunt，这两个工具可以用gulp.config.js文件或者grunt.config.js文件列出清单，让这两个工具做什么，比如混淆一个js文件，合并多个js文件，他们都是用task数组表示工程一件事儿、一件事儿自动帮我们做。编译less也能自动watch观测less的改变，自动生成css文件。 预处理编译工具：比如less的编译用lessc，sass的编译用sass，jsx的编译用babel。他们都可以提交给gulp、grunt来自动完成编译。 模块编译工具：webpack是一个本质上是一个CMD模块编译工具，就是把多个具有import、require、export写出来的模块可以编译为普通浏览器能够识别的普通JavaScript程序。里面集成loader的东西，让webpack可以一统babel、lessc、sass、jpg压缩等等。webpack越来越强大，甚至拥有了工作流的功能，比如合并js、压缩个js等等。 代码测试工具：大公司、大项目在用。 1.2 初识webpack网页打包工具，webpack。依赖nodejs的，所以机器上要安装nodejs。 webpack把零散的js文件、less文件、图片文件，打包成为一个bundle。 我们需要让机器上有webpack工具，此时就要在全局路径下安装webpack 1$ npm install webpack -g 我们来测试webpack到底干嘛用的，所以我们建立c:\test文件夹。 我们创建一个a.js文件： 1alert("你好webpack！"); 此时cd c:\test里面，然后： 1webpack a.js dist.js 然后做一个页面，引入dist.js文件： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/javascript" src="dist.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 此时能够弹出alert框。dist文件是这样的： 此时webpack帮我们进行了打包，进行了CMD规范的处理。 我们再来一个案例，进行升级。此时a文件用CMD规范，类似NodeJS的语法来对b进行引用。 a.js文件： 123var b = require("./b");b.fn(); b.js文件 123exports.fn = function()&#123; alert("我是b文件中的fn函数");&#125; 此时 1webpack a.js dist.js 并没有b的事儿，但是webpack看见了a再引用b，此时就把b就一并打包进去了。此时IE6都能运行刚才的程序。 webpack最恐怖的就是它颠覆了我们用前端框架的模式，比如jQuery，此时只需要 1npm install jquery 然后主入口文件（a.js）里面1var $ = require("jquery"); 此时jQuery也会被编译到dist.js文件中。一个项目如果使用webpack，此时就能裸写CMD规范代码。 1.3 使用文件来配置webpack写一个文件，告诉webpack你要做什么。项目的根目录要放置webpack.config.js文件，告诉webpack你的任务是什么。 src文件夹中存放源文件，dist是我们准备放置生成的bundle文件。 webpack.config.js文件里面，要定义入口和出口： 12345678var path = require("path");module.exports = &#123; entry: './src/a.js', output: &#123; path: path.resolve(__dirname, './dist'), filename: 'bundle.js' &#125;&#125;; 加载器loader也是非常重要的配置项，webpack是一个海纳百川的工具，所以就要能够接纳一些其他工具，比如babel可以编译jsx文件， 此时webpack就让他开发一个针对webpack的插件，叫做-loader。 12cnpm install babel-loadercnpm install babel-core 改变webpack.config.js文件： 12345678910111213var path = require("path");module.exports = &#123; entry: './src/a.js', output: &#123; path: path.resolve(__dirname, './dist'), filename: 'bundle.js' &#125;, module: &#123; rules: [ &#123;test: /\.(js|jsx)$/, use: 'babel-loader'&#125; //表示js和jsx结尾的文件编译 ] &#125;&#125;; 如果要处理less、sass此时就要使用他们的loader 完整的webpack.config.js 12345678910111213141516171819var path = require("path");var webpack = require("webpack");module.exports = &#123; entry: './src/a.js', output: &#123; path: path.resolve(__dirname, './dist'), filename: 'bundle.js' &#125;, module: &#123; //loader rules: [ &#123;test: /\.(js|jsx)$/, use: 'babel-loader'&#125; ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin() //让生成的代码被混淆加密 ], watch : true //监听文件变化&#125;; 相当于解析ES2016和jsx文件是babel的能力，一定要记住先安装 12cnpm install babel-corecnpm install babel-loader 1.4 开发中的依赖package.json文件中，通过dependencies描述项目依赖，devDependencies描述开发依赖。 只要这个项目是前端项目，即使后台不是Node.js也会有package.json，因为它的所有的开发工具，都依赖NodeJS。前端项目依赖Node.js的所有工程化工具的。 面对一个项目，最开始的工作就是 1npm init 生成一个package.json，这个是工程的身份证。 然后安装webpack 1npm install webpack --save-dev 加上--save-dev，此时webpack就是我们的开发依赖了。 此时package.json文件： 1234567891011121314&#123; "name": "test2", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "author": "", "license": "ISC", "devDependencies": &#123; "webpack": "^2.2.1" &#125;&#125; 安装babel的相关loader： 12cnpm install babel-core --save-devcnpm install babel-loader --save-dev 前端依赖 1cnpm install jquery --save 二、webpack和Reactwebpack使用的CMD规范进行开发，此时我们的React就作为了依赖项。 12345678cnpm install react --save-devcnpm install react-dom --save-devcnpm install babel-preset-es2015 --save-devcnpm install babel-preset-es2016 --save-devcnpm install babel-preset-react --save-devcnpm install babel-polyfill --save-devcnpm install babel-loader --save-devcnpm install babel-core --save-dev 然后创建一个.babelrc文件，告诉babel如何工作，很关键。 12345678&#123; "presets": [ "es2015", "es2016", "react" ], "plugins": []&#125; 改变webpack.config.js里面的设置，明确设置loader： 记住cnpm install --save-dev webpack 1234567891011121314151617181920212223242526272829var path = require("path");var webpack = require("webpack");module.exports = &#123; entry: './src/index.js', output: &#123; path: path.resolve(__dirname, './dist'), filename: 'index.bundle.js' &#125;, module: &#123; //loader loaders:[ &#123; test:/.jsx?$/, loaders:"babel-loader", exclude:"/node_modules/" &#125; ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin() //让生成的代码被混淆加密 , new webpack.DefinePlugin(&#123; //这里加上表示我们的react正在处于开发模式中，不会收到警告提醒。 'process.env':&#123; 'NODE_ENV': JSON.stringify('production') &#125; &#125;) ], watch : true&#125;; 然后就能webpack --watch了。 三、Flux架构Flux架构入门教程 四、ReduxRedux 入门教程]]></content>
      <categories>
        <category>React学习</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客网的一些题]]></title>
    <url>%2F2017%2F08%2F24%2F%E7%89%9B%E5%AE%A2%E7%BD%91%E7%9A%84%E4%B8%80%E4%BA%9B%E9%A2%98%2F</url>
    <content type="text"><![CDATA[表达式 ”2”+3+4 的值为？ 1A."27" B.9 C."234" D."9" //C Cookie, LocalStorage 与 SessionStorage的区别？详细解答 特性 Cookie localStorage sessionStorage 数据的生命期 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效 除非被清除，否则永久保存 仅在当前会话下有效，关闭页面或浏览器后被清除 存放数据大小 4K左右 一般为5MB 同左 与服务器端通信 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 仅在客户端（即浏览器）中保存，不参与和服务器的通信 同左 易用性 需要程序员自己封装，源生的Cookie接口不友好 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 同左 cookie 和session 1、cookie数据存放在客户的浏览器上，session数据放在服务器上。 2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session。 3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用COOKIE。 4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。每次请求一个新的页面的时候Cookie都会被发送过去，与服务器进行交互。 以下代码的执行结果是什么？ 12345var arr=[];arr[0]=0;arr[1]=1;arr.foo-'c';console.log(arr.length);//2 下面代码中span标签的width和height分别为多少？ 12345678&lt;div style="width:400px;height:200px;""&gt; &lt;span style="float:left;width:auto;height:100%;"&gt; &lt;i style="position:absolute;float:left;width:100px;height:50px;"&gt;hello&lt;/i&gt; &lt;/span&gt;&lt;/div&gt;//首先span不是块级元素，是不支持宽高的，但是style中有了个float：left；就使得span变成了块级元素支持宽高，height:100%;即为，200，宽度由内容撑开。但是内容中的 i 是绝对定位，脱离了文档流，所以不占父级空间，所以span的width=0 写出下面代码的运行结果 123456789101112var a,b;(function()&#123; alert(a); alert(b); var a=b=3; alert(a); alert(b);&#125;)();alert(a);alert(b);//undefined，undefined，3,3，undefined，3//解析：var a=b=3 相当于 var a = 3；b = 3；b是全局的 写出下面代码的运行结果 123456(function() &#123; var a = b = 5; &#125;)(); console.log(b);console.log(a);//5，Uncaught ReferenceError: a is not defined 写出下面代码的运行结果 123456789function A() &#123; this.do=function() &#123;return ‘foo’;&#125;;&#125;A.prototype=function() &#123; this.do=function() &#123;return ‘bar’&#125;;&#125;;var x=new A().do();x 的值是：foo//首先从自己的实例对象里面找该属性，找到了就不用再向上继续查找了。 var a = [1,4,5,2,9];下面求a中最大值正确的是(C) 1A.Math.max(a) B.Math.max.call(null,a) C.Math.max.apply(null,a)]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[React学习（一）]]></title>
    <url>%2F2017%2F08%2F23%2FReact%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、React起步1.1 bower 的使用bower是前端界的npm。npm有npm install命令，bower也有bower install命令。用来管理、维护前端开发中的JS库的。 bower只负责前端库，nodejs的东西它不管，比如你bower拿不到mongodb的。 自定义bower的安装目录 在项目根下创建一个名为.bowerrc的文件然后 123&#123; "directory" : "js/lib" //指定bower安装的目录&#125; 执行bower install react可以看到文件下载到 js 文件夹下的 lib 文件夹中了。 bower初始化 12bower init // 在git bash中执行会出错，在windows cmd 中执行此命令 会提示你输入一些基本信息，根据提示按回车或者空格即可，然后会生成一个bower.json文件，用来保存该项目的配置 包的安装 比如要安装一个react，输入如下命令： 1bower install react --save 然后bower就会从远程下载react最新版本到你的js/lib目录下其中–save参数是保存配置到你的bower.json，你会发现bower.json文件已经多了一行： 123"dependencies": &#123; "react": "^15.6.1"&#125; 1.2 认识 babel 和 JSXbable是一个compiler（编译器），英语原意是噪音的意思，把噪音变为我们能听懂的声音。 bable可以最大限度的让我们的前端界面，现在就可以使用ECMAScript2016甚至今后有更新的语法。bable会把它编译为现在能用的JS语句。 我们现在仅仅需要把babel运行在前端。所以此时仅仅需要用bower去下载即可： 1bower install babel 下载之后的文件叫做 browser.min.js，表示babel在浏览器端在进行babel语句的编译。 babel和react共同提供了一个语法，叫做jsx。 1.3 Hello,World !引入三个文件，分别是react、react-dom、browser(是babel文件)： 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type="text/javascript" src="js/react/react.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="js/react/react-dom.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="js/babel/browser.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="box"&gt;&lt;/div&gt; &lt;script type="text/babel"&gt; ReactDOM.render( &lt;h1&gt;Hello,React!&lt;/h1&gt;, document.getElementById('box') ); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在一个script标签，这个标签的type是text/babel，此时babel就会在浏览器端进行JSX和ECMAScript2016的翻译工作。 ReactDOM.render()函数表示让一个JSX让它上树，此时接受两个参数，一个JSX语句，一个是盒子。 1234ReactDOM.render( &lt;h1&gt;Hello,React!&lt;/h1&gt;, document.getElementById('box') ); 此时盒子中的所有内容都将被ReactDOM对象接管。 JSX是一个语法糖，目的就是让HTML拥有JavaScript的作用域，这是一个React突破性的创举。 比如： 1234567&lt;script type="text/babel"&gt; var str="Cool"; ReactDOM.render( &lt;h1&gt;Hello,React!&#123;str&#125;&lt;/h1&gt;, document.getElementById('box') );&lt;/script&gt; 此时JSX语句，“沐浴”在了JS的作用域下。 JSX 的基本语法规则：遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析；遇到代码块（以 { 开头），就用 JavaScript 规则解析。 JSX 允许直接在模板插入 JavaScript 变量。如果这个变量是一个数组，则会展开这个数组的所有成员 12345678910&lt;script type="text/babel"&gt; var arr = [ &lt;h1&gt;Hello world!&lt;/h1&gt;, &lt;h2&gt;React is awesome&lt;/h2&gt;,];ReactDOM.render( &lt;div&gt;&#123;arr&#125;&lt;/div&gt;, document.getElementById('box'));&lt;/script&gt; 二、创建组件2.1 方法一最简单的创建一个自定义的组件的方法，就是使用一个函数，这个函数必须大写字母开头，如果是小写字母开头就不会渲染为组件。函数返回JSX语句。使用这个组件的时候，用自封闭标签来当做这个组件放置的位置： 12345678910&lt;script type="text/babel"&gt; function MyComponent()&#123; return &lt;h1&gt;Welcome !&lt;/h1&gt;; &#125; ReactDOM.render( &lt;MyComponent/&gt;, document.getElementById("box") );&lt;/script&gt; 2.2 方法二创建一个自定义组件，就是创建一个类，这个类要继承React.Component对象。这个类必须定义类方法render，这个方法返回一个JSX语句。 1234567891011121314151617181920&lt;script type="text/babel"&gt; //要定义一个组件，实际上就是定义一个类 class MyComponent extends React.Component&#123; render()&#123; return &lt;h1&gt;我是一个h1，我买了一个iphone&#123;3+4&#125;&lt;/h1&gt; &#125; &#125; //应用这个组件 ReactDOM.render( &lt;section&gt; &lt;MyComponent /&gt; &lt;MyComponent /&gt; &lt;MyComponent /&gt; &lt;MyComponent /&gt; &lt;/section&gt; , document.getElementById("box") )&lt;/script&gt; 2.3 方法三1234567891011121314151617&lt;script type="text/babel"&gt; var MyComponent = React.createClass(&#123; render : function()&#123; return &lt;h1&gt;我是一个h1，我是&#123;2 + 4&#125;&lt;/h1&gt; &#125; &#125;); ReactDOM.render( &lt;section&gt; &lt;MyComponent /&gt; &lt;MyComponent /&gt; &lt;MyComponent /&gt; &lt;/section&gt; , document.getElementById("box") )&lt;/script&gt; 三、获得组件自定义属性3.1 this.props我们创建组件，肯定要设置、使用组件上面的属性。请看下面的程序，在创建组件的时候，JSX中如果出现了this，this一定表示使用这个组件的时候写的那个自定义标签。props就是函数的属性，可以继续打点去枚举任何属性。 12345678910111213141516&lt;script type="text/babel"&gt; var MyComponent = React.createClass(&#123; render : function()&#123; return &lt;p&gt;&#123;this.props.a&#125;&lt;/p&gt;; &#125; &#125;); ReactDOM.render( &lt;section&gt; &lt;MyComponent a="11"/&gt; &lt;MyComponent a="22"/&gt; &lt;MyComponent a="33"/&gt; &lt;/section&gt; , document.querySelector("#box") );&lt;/script&gt; 3.2 组件的嵌套，属性级级上传组件的嵌套，属性可以级级上传。this是使用这个自定义组件的时候那个标签。 1234567891011121314151617181920212223242526272829&lt;script type="text/babel"&gt; var InnerComponent = React.createClass(&#123; render : function()&#123; return &lt;a href=&#123;this.props["data-href"]&#125;&gt;去这个网站&lt;/a&gt;; &#125; &#125;); var MyComponent = React.createClass(&#123; render : function()&#123; return ( &lt;div&gt; &lt;h1&gt;&#123;this.props.info&#125;&lt;/h1&gt; &lt;InnerComponent data-href=&#123;this.props["data-href"]&#125; /&gt; &lt;/div&gt; ); &#125; &#125;); ReactDOM.render( &lt;section&gt; &lt;MyComponent info="百度" data-href="http://www.baidu.com/"/&gt; &lt;MyComponent info="网易" data-href="http://www.163.com/"/&gt; &lt;MyComponent info="搜狐" data-href="http://www.sohu.cn/"/&gt; &lt;/section&gt; , document.querySelector("#box") );&lt;/script&gt; 四、获得真实的DOM节点4.1 先说说事件监听我们现在要给一个组件里面的按钮添加事件监听，此时用onClick、onMoouseenter、onFocus的写法，所有原来的事件名，on之后的字母大写，此时React会帮你用DOM2级绑定到冒泡阶段上。注意大写字母！！ 创建一个组件的时候，不仅仅只有Render方法，还可以有其他方法，其他方法都是组件里面的方法。 1234567891011121314151617181920&lt;script type="text/babel"&gt; var MyComponent = React.createClass(&#123; sayhello : function()&#123; alert('Hello') &#125;, render : function()&#123; return ( &lt;section&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;input type="button" value="按钮" onClick=&#123;this.sayhello&#125;/&gt; &lt;/section&gt; ); &#125; &#125;); ReactDOM.render( &lt;MyComponent /&gt; , document.querySelector("#box") )&lt;/script&gt; 4.2 获得DOM元素组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM （virtual DOM）。只有当它插入文档以后，才会变成真实的 DOM 。根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 DOM diff ，它可以极大提高网页的性能表现。 但是，有时需要从组件获取真实 DOM 的节点，这时就要用到 ref 属性。 1234567891011121314151617181920&lt;script type="text/babel"&gt; var MyComponent = React.createClass(&#123; changeColor : function()&#123; this.refs.mytext.style.color="red"; &#125;, render : function()&#123; return ( &lt;section&gt; &lt;h1 ref="mytext"&gt;Hello&lt;/h1&gt; &lt;input type="button" value="按钮" onClick=&#123;this.changeColor&#125;/&gt; &lt;/section&gt; ); &#125; &#125;); ReactDOM.render( &lt;MyComponent /&gt; , document.querySelector("#box") )&lt;/script&gt; this.refs.[refName]就会返回这个真实的 DOM 节点。注意设置的时候用ref，引用的使用用refs。 五、状态我们用React创建的每一个component都有自己的状态，实际上定义的时候是状态的模型，实例化每一个component的时候，每一个component都拥有自己的状态。state 和 props 主要的区别在于 props 是不可变的，而 state 可以根据与用户交互来改变。这就是为什么有些容器组件需要定义 state 来更新和修改数据。 而子组件只能通过 props 来传递数据。 5.1 初始状态和使用状态我们现在可以给这个组件的实例设置一个状态，状态是一个JSON对象，里面用k-v来维持一个个状态，此时用getInitialState函数来设置初始状态。 123456789101112131415161718192021&lt;script type="text/babel"&gt;var MyComponent = React.createClass(&#123; //创建一个组件类 //得到初始状态函数，这个函数必须返回一个对象 getInitialState : function()&#123; return &#123; "a" : 1 &#125; &#125;, render : function()&#123; return &lt;h1&gt;&#123;this.state.a&#125;&lt;/h1&gt; &#125;&#125;);//使用组件ReactDOM.render( &lt;MyComponent&gt;&lt;/MyComponent&gt; , document.getElementById("box"))&lt;/script&gt; 如果创建组件的时候使用的是ES6的class关键字创建的，可以很明显看见state是自己身上的属性： 1234567891011121314class MyComponent extends React.Component&#123; constructor(props)&#123; super(props); //调用超类 //所谓的状态就是自己身上的属性 this.state = &#123; "a" : 1 &#125; &#125; render()&#123; return &lt;h1&gt;你好&#123;this.state.a&#125;&lt;/h1&gt; &#125;&#125; 5.2 设置状态如果要更改状态， 不能直接用点语法更改状态，一定要使用setState()函数，因为这个函数能够让视图同步刷新。但是是局部刷新，就是所有用到这个状态的地方进行刷新。 案例 - 购物车数量 12345678910111213141516171819202122232425262728293031323334353637383940&lt;script type="text/babel"&gt; var MyComponent = React.createClass(&#123; //创建一个组件类 //得到初始状态函数，这个函数必须返回一个对象 getInitialState : function()&#123; return &#123; "a" : 1 &#125; &#125;, minus : function()&#123; //让状态改变，setState会引发视图的刷新。并且还是局部刷新。 this.setState(&#123;"a" : this.state.a - 1&#125;); &#125;, add : function()&#123; this.setState(&#123;"a" : this.state.a + 1&#125;); &#125;, render : function()&#123; return ( &lt;div&gt; &lt;input type="button" value="-" onClick=&#123;this.minus&#125; /&gt; &lt;span&gt;&#123;this.state.a&#125;&lt;/span&gt; &lt;input type="button" value="+" onClick=&#123;this.add&#125;/&gt; &lt;/div&gt; ) &#125; &#125;); //使用组件 ReactDOM.render( &lt;div&gt; &lt;MyComponent&gt;&lt;/MyComponent&gt; &lt;MyComponent&gt;&lt;/MyComponent&gt; &lt;MyComponent&gt;&lt;/MyComponent&gt; &lt;MyComponent&gt;&lt;/MyComponent&gt; &lt;/div&gt; , document.getElementById("box") )&lt;/script&gt; 六、组件的生命周期在创建一个组件的时候，语法就是 1234567React.createClass(&#123;//这里书写下面的方法componentWillMount : function()&#123;&#125;,componentDidMount : function()&#123;&#125;,...render: function()&#123;&#125;&#125;); 一个组件有三个状态：Mount上树、update更新、unmount下树 1234567891011121314componentWillMount 在渲染前调用,在客户端也在服务端。 componentDidMount : 在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.refs来进行访问。 如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异部操作阻塞UI)。componentWillReceiveProps 在组件接收到一个新的prop时被调用。这个方法在初始化render时不会被调用。shouldComponentUpdate 返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用。 可以在你确认不需要更新组件时使用。componentWillUpdate在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用。componentDidUpdate 在组件完成更新后立即调用。在初始化时不会被调用。componentWillUnmount在组件从 DOM 中移除的时候立刻被调用。]]></content>
      <categories>
        <category>React学习</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解网页性能管理]]></title>
    <url>%2F2017%2F08%2F21%2F%E8%AF%A6%E8%A7%A3%E7%BD%91%E9%A1%B5%E6%80%A7%E8%83%BD%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. 网页生成的过程要理解网页性能为什么不好，就要了解网页是怎么生成的。 网页的生成过程，大致可以分成五步。 1、HTML代码转成DOM； 2、CSS代码转成CSSOM（CSS Object Model）； 3、结合DOM和CSSOM，生成一棵渲染树（包含每个节点的视觉信息）； 4、生成布局（layout），即将所有渲染树的所有节点进行平面合成； 5、将局部绘制（paint）在屏幕上。 这五步里面，第一步到第三步都非常快，耗时的是第四步和第五步。 “生成布局”（flow）和”绘制”（paint）这两步，合称为”渲染”（render）。 2. 重排和重绘网页生成的时候，至少会渲染一次。用户访问的过程中，还会不断重新渲染。 以下三种情况，会导致网页重新渲染。 12345修改DOM修改样式表用户事件（比如鼠标悬停、页面滚动、输入框键入文字、改变窗口大小等等） 重新渲染，就需要重新生成布局和重新绘制。前者叫做”重排”（reflow），后者叫做”重绘”（repaint）。 需要注意的是，”重绘”不一定需要”重排”，比如改变某个网页元素的颜色，就只会触发”重绘”，不会触发”重排”，因为布局没有改变。但是，”重排”必然导致”重绘”，比如改变一个网页元素的位置，就会同时触发”重排”和”重绘”，因为布局改变了。 3. 对于性能的影响重排和重绘会不断触发，这是不可避免的。但是，它们非常耗费资源，是导致网页性能低下的根本原因。 提高网页性能，就是要降低”重排”和”重绘”的频率和成本，尽量少触发重新渲染。 前面提到，DOM变动和样式变动，都会触发重新渲染。但是，浏览器已经很智能了，会尽量把所有的变动集中在一起，排成一个队列，然后一次性执行，尽量避免多次重新渲染。 12div.style.color = 'blue';div.style.marginTop = '30px'; 上面代码中，div元素有两个样式变动，但是浏览器只会触发一次重排和重绘。 如果写得不好，就会触发两次重排和重绘。 上面代码对div元素设置背景色以后，第二行要求浏览器给出该元素的位置，所以浏览器不得不立即重排。一般来说，样式的写操作之后，如果有下面这些属性的读操作，都会引发浏览器立即重新渲染。 1234567offsetTop/offsetLeft/offsetWidth/offsetHeightscrollTop/scrollLeft/scrollWidth/scrollHeightclientTop/clientLeft/clientWidth/clientHeightgetComputedStyle() 所以，从性能角度考虑，尽量不要把读操作和写操作，放在一个语句里面。 一般的规则是： 12345样式表越简单，重排和重绘就越快。重排和重绘的DOM元素层级越高，成本就越高。table元素的重排和重绘成本，要高于div元素 4. 提高性能的九个技巧有一些技巧，可以降低浏览器重新渲染的频率和成本。 第一条，是上一节说到的，DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。 第二条，如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候，浏览器又要重排。 第三条，不要一条条地改变样式，而要通过改变class，或者csstext属性，一次性地改变样式。 1234567891011// badvar left = 10;var top = 10;el.style.left = left + "px";el.style.top = top + "px";// good el.className += " theclassname";// goodel.style.cssText += "; left: " + left + "px; top: " + top + "px;"; 第四条，尽量使用离线DOM，而不是真实的网面DOM，来改变元素样式。比如，操作Document Fragment对象，完成后再把这个对象加入DOM。再比如，使用cloneNode() 方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。 第五条，先将元素设为display: none（需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。 第六条，position属性为absolute或fixed的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。 第七条，只在必要的时候，才将元素的display属性为可见，因为不可见的元素不影响重排和重绘。另外，visibility : hidden的元素只对重绘有影响，不影响重排。 第八条，使用虚拟DOM的脚本库，比如React等。 第九条，使用window.requestAnimationFrame()、window.requestIdleCallback()这两个方法调节重新渲染（详见后文）。 5.刷新率很多时候，密集的重新渲染是无法避免的，比如scroll事件的回调函数和网页动画。 网页动画的每一帧（frame）都是一次重新渲染。每秒低于24帧的动画，人眼就能感受到停顿。一般的网页动画，需要达到每秒30帧到60帧的频率，才能比较流畅。如果能达到每秒70帧甚至80帧，就会极其流畅。 大多数显示器的刷新频率是60Hz，为了与系统一致，以及节省电力，浏览器会自动按照这个频率，刷新动画（如果可以做到的话）。 所以，如果网页动画能够做到每秒60帧，就会跟显示器同步刷新，达到最佳的视觉效果。这意味着，一秒之内进行60次重新渲染，每次重新渲染的时间不能超过16.66毫秒。 一秒之间能够完成多少次重新渲染，这个指标就被称为”刷新率”，英文为FPS（frame per second）。60次重新渲染，就是60FPS。 如果想达到60帧的刷新率，就意味着JavaScript线程每个任务的耗时，必须少于16毫秒。一个解决办法是使用Web Worker，主线程只用于UI渲染，然后跟UI渲染不相干的任务，都放在Worker线程。 6. 开发者工具的Timeline面板（现已改名为performance）Chrome浏览器开发者工具的Timeline面板，是查看”刷新率”的最佳工具。这一节介绍如何使用这个工具。 首先，按下 F12 打开”开发者工具”，切换到Timeline面板。 左上角有一个灰色的圆点，这是录制按钮，按下它会变成红色。然后，在网页上进行一些操作，再按一次按钮完成录制。 Timeline面板提供两种查看方式：横条的是”事件模式”（Event Mode），显示重新渲染的各种事件所耗费的时间；竖条的是”帧模式”（Frame Mode），显示每一帧的时间耗费在哪里。 先看”事件模式”，你可以从中判断，性能问题发生在哪个环节，是JavaScript的执行，还是渲染？ 不同的颜色表示不同的事件。 1234567蓝色：网络通信和HTML解析黄色：JavaScript执行紫色：样式计算和布局，即重排绿色：重绘 哪种色块比较多，就说明性能耗费在那里。色块越长，问题越大。 帧模式（Frames mode）用来查看单个帧的耗时情况。每帧的色柱高度越低越好，表示耗时少。 你可以看到，帧模式有两条水平的参考线。 下面的一条是60FPS，低于这条线，可以达到每秒60帧；上面的一条是30FPS，低于这条线，可以达到每秒30次渲染。如果色柱都超过30FPS，这个网页就有性能问题了。 此外，还可以查看某个区间的耗时情况。 或者点击每一帧，查看该帧的时间构成。 7. window.requestAnimationFrame()有一些JavaScript方法可以调节重新渲染，大幅提高网页性能。 其中最重要的，就是 window.requestAnimationFrame() 方法。它可以将某些代码放到下一次重新渲染时执行。 12345function doubleHeight(element) &#123; var currentHeight = element.clientHeight; element.style.height = (currentHeight * 2) + 'px';&#125;elements.forEach(doubleHeight); 上面的代码使用循环操作，将每个元素的高度都增加一倍。可是，每次循环都是，读操作后面跟着一个写操作。这会在短时间内触发大量的重新渲染，显然对于网页性能很不利。 我们可以使用window.requestAnimationFrame()，让读操作和写操作分离，把所有的写操作放到下一次重新渲染。 1234567function doubleHeight(element) &#123; var currentHeight = element.clientHeight; window.requestAnimationFrame(function () &#123; element.style.height = (currentHeight * 2) + 'px'; &#125;);&#125;elements.forEach(doubleHeight); 页面滚动事件（scroll）的监听函数，就很适合用 window.requestAnimationFrame() ，推迟到下一次重新渲染。 123$(window).on('scroll', function() &#123; window.requestAnimationFrame(scrollHandler);&#125;); 当然，最适用的场合还是网页动画。下面是一个旋转动画的例子，元素每一帧旋转1度。 12345678910var rAF = window.requestAnimationFrame;var degrees = 0;function update() &#123; div.style.transform = "rotate(" + degrees + "deg)"; console.log('updated to degrees ' + degrees); degrees = degrees + 1; rAF(update);&#125;rAF(update); 8. window.requestIdleCallback()还有一个函数window.requestIdleCallback()，也可以用来调节重新渲染。它指定只有当一帧的末尾有空闲时间，才会执行回调函数。 1requestIdleCallback(fn); 上面代码中，只有当前帧的运行时间小于16.66ms时，函数fn才会执行。否则，就推迟到下一帧，如果下一帧也没有空闲时间，就推迟到下下一帧，以此类推。 它还可以接受第二个参数，表示指定的毫秒数。如果在指定 的这段时间之内，每一帧都没有空闲时间，那么函数fn将会强制执行。 1requestIdleCallback(fn, 5000); 上面的代码表示，函数fn最迟会在5000毫秒之后执行。 函数 fn 可以接受一个 deadline 对象作为参数。 123456789requestIdleCallback(function someHeavyComputation(deadline) &#123; while(deadline.timeRemaining() &gt; 0) &#123; doWorkIfNeeded(); &#125; if(thereIsMoreWorkToDo) &#123; requestIdleCallback(someHeavyComputation); &#125;&#125;); 上面代码中，回调函数 someHeavyComputation 的参数是一个 deadline 对象。 deadline对象有一个方法和一个属性：timeRemaining() 和 didTimeout。 （1）timeRemaining() 方法 timeRemaining() 方法返回当前帧还剩余的毫秒。这个方法只能读，不能写，而且会动态更新。因此可以不断检查这个属性，如果还有剩余时间的话，就不断执行某些任务。一旦这个属性等于0，就把任务分配到下一轮requestIdleCallback。 前面的示例代码之中，只要当前帧还有空闲时间，就不断调用doWorkIfNeeded方法。一旦没有空闲时间，但是任务还没有全执行，就分配到下一轮requestIdleCallback。 （2）didTimeout属性 deadline对象的 didTimeout 属性会返回一个布尔值，表示指定的时间是否过期。这意味着，如果回调函数由于指定时间过期而触发，那么你会得到两个结果。 12timeRemaining方法返回0didTimeout 属性等于 true 因此，如果回调函数执行了，无非是两种原因：当前帧有空闲时间，或者指定时间到了。 123456789function myNonEssentialWork (deadline) &#123; while ((deadline.timeRemaining() &gt; 0 || deadline.didTimeout) &amp;&amp; tasks.length &gt; 0) doWorkIfNeeded(); if (tasks.length &gt; 0) requestIdleCallback(myNonEssentialWork);&#125;requestIdleCallback(myNonEssentialWork, 5000); 上面代码确保了，doWorkIfNeeded 函数一定会在将来某个比较空闲的时间（或者在指定时间过期后）得到反复执行。 requestIdleCallback 是一个很新的函数，刚刚引入标准，目前只有Chrome支持，不过其他浏览器可以用垫片库。 文章来源：网页性能管理详解]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解浏览器缓存]]></title>
    <url>%2F2017%2F08%2F19%2F%E8%AF%A6%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[老规矩，先上两张图： 浏览器第一次请求时： 浏览器后续请求时： 浏览器缓存，也就是客户端缓存，既是网页性能优化里面静态资源相关优化的一大利器，也是无数web开发人员在工作过程不可避免的一大问题，所以在产品开发的时候我们总是想办法避免缓存产生，而在产品发布之时又在想策略管理缓存提升网页的访问速度。了解浏览器的缓存命中原理，是开发web应用的基础，本文着眼于此，学习浏览器缓存的相关知识，总结缓存避免和缓存管理的方法，结合具体的场景说明缓存的相关问题。希望能对有需要的人有所帮助。 1. 浏览器缓存基本认识1.1 基本概念和优点浏览器缓存(Brower Caching)是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。 浏览器缓存的优点有： 1）减少了冗余的数据传输，节省了网费 2）减少了服务器的负担，大大提升了网站的性能 3）加快了客户端加载网页的速度 1.2 缓存的分类它分为强缓存和协商缓存： 1）浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如某个css文件，如果浏览器在加载它所在的网页时，这个css文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个css，连请求都不会发送到网页所在服务器； 2）当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源； 3）强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。 4）当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。 2. 强缓存的原理当浏览器对某个资源的请求命中了强缓存时，返回的http状态为200，在chrome的开发者工具的network里面size会显示为from cache，比如京东的首页里就有很多静态资源配置了强缓存，用chrome打开几次，再用f12查看network，可以看到有不少请求就是从缓存中加载的： 强缓存是利用Expires或者Cache-Control这两个http response header实现的，它们都用来表示资源在客户端缓存的有效期。 2.1 ExpiresExpires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT，它的缓存原理是： 1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Expires的header，如： 2）浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）； 3）浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较，如果请求时间在Expires指定的时间之前，就能命中缓存，否则就不行。 4）如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header在重新加载的时候会被更新。 2.2 Cache-ControlExpires是较老的强缓存管理header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。所以在http1.1的时候，提出了一个新的header，就是Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：Cache-Control:max-age=315360000，它的缓存原理是： 1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Cache-Control的header，如： 2）浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来； 3）浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。 4）如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header在重新加载的时候会被更新。 Cache-Control描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。 这两个header可以只启用一个，也可以同时启用，当response header中，Expires和Cache-Control同时存在时，Cache-Control优先级高于Expires： 3. 强缓存的管理前面介绍的是强缓存的原理，在实际应用中我们会碰到需要强缓存的场景和不需要强缓存的场景，通常有2种方式来设置是否启用强缓存： 1）通过代码的方式，在web服务器返回的响应中添加Expires和Cache-Control Header； 2）通过配置web服务器的方式，让web服务器在响应资源的时候统一添加Expires和Cache-Control Header。 由于在开发的时候不会专门去配置强缓存，而浏览器又默认会缓存图片，css和js等静态资源，所以开发环境下经常会因为强缓存导致资源没有及时更新而看不到最新的效果，解决这个问题的方法有很多，常用的有以下几种： 1）直接ctrl+f5，这个办法能解决页面直接引用的资源更新的问题； 2）使用浏览器的隐私模式开发； 3）如果用的是chrome，可以f12在network那里把缓存给禁掉（这是个非常有效的方法）： 4）在开发阶段，给资源加上一个动态的参数，如css/index.css?v=0.0001，由于每次资源的修改都要更新引用的位置，同时修改参数的值，所以操作起来不是很方便，除非你是在动态页面比如jsp里开发就可以用服务器变量来解决（v=${sysRnd}），或者你能用一些前端的构建工具来处理这个参数修改的问题； 5）如果资源引用的页面，被嵌入到了一个iframe里面，可以在iframe的区域右键单击重新加载该页面。6）如果缓存问题出现在ajax请求中，最有效的解决办法就是ajax的请求地址追加随机数； 7）还有一种情况就是动态设置iframe的src时，有可能也会因为缓存问题，导致看不到最新的效果，这时候在要设置的src后面添加随机数也能解决问题； 8）如果你用的是grunt和gulp这种前端工具开发，通过它们的插件比如grunt-contrib-connect来启动一个静态服务器，则完全不用担心开发阶段的资源更新问题，因为在这个静态服务器下的所有资源返回的respone header中，cache-control始终被设置为不缓存： 4. 强缓存的应用强缓存是前端性能优化最有力的工具，没有之一，对于有大量静态资源的网页，一定要利用强缓存，提高响应速度。通常的做法是，为这些静态资源全部配置一个超时时间超长的Expires或Cache-Control，这样用户在访问网页时，只会在第一次加载时从服务器请求静态资源，其它时候只要缓存没有失效并且用户没有强制刷新的条件下都会从自己的缓存中加载，比如前面提到过的京东首页缓存的资源，它的缓存过期时间都设置到了2026年： 然而这种缓存配置方式会带来一个新的问题，就是发布时资源更新的问题，比如某一张图片，在用户访问第一个版本的时候已经缓存到了用户的电脑上，当网站发布新版本，替换了这个图片时，已经访问过第一个版本的用户由于缓存的设置，导致在默认的情况下不会请求服务器最新的图片资源，除非他清掉或禁用缓存或者强制刷新，否则就看不到最新的图片效果。 这个问题已经有成熟的解决方案，具体内容可阅读知乎这篇文章详细了解： http://www.zhihu.com/question/20790576 文章提到的东西都属于理论上的解决方案，不过现在已经有很多前端工具能够实际地解决这个问题，由于每个工具涉及到的内容细节都有很多，本文没有办法一一深入介绍。有兴趣的可以去了解下grunt gulp webpack fis 还有edp这几个工具，基于这几个工具都能解决这个问题，尤其是fis和edp是百度推出的前端开发平台，有现成的文档可以参考： http://fis.baidu.com/fis3/api/index.html http://ecomfe.github.io/edp/doc/initialization/install/ 强缓存还有一点需要注意的是，通常都是针对静态资源使用，动态资源需要慎用，除了服务端页面可以看作动态资源外，那些引用静态资源的html也可以看作是动态资源，如果这种html也被缓存，当这些html更新之后，可能就没有机制能够通知浏览器这些html有更新，尤其是前后端分离的应用里，页面都是纯html页面，每个访问地址可能都是直接访问html页面，这些页面通常不加强缓存，以保证浏览器访问这些页面时始终请求服务器最新的资源。 5. 协商缓存的原理当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串，比如你打开京东的首页，按f12打开开发者工具，再按f5刷新页面，查看network，可以看到有不少请求就是命中了协商缓存的： 查看单个请求的Response Header，也能看到304的状态码和Not Modified的字符串，只要看到这个就可说明这个资源是命中了协商缓存，然后从客户端缓存中加载的，而不是服务器最新的资源： 协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的。 5.1 Last-Modified 和 If-Modified-Since【Last-Modified，If-Modified-Since】的控制缓存的原理是： 1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间： 2）浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值： 3）服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header： 4）浏览器收到304的响应后，就会从缓存中加载资源。 5）如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。 【Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对header来管理协商缓存，这对header就是【ETag、If-None-Match】。 5.2 ETag 和 If-None-Match1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题： 2）浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值： 3）服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化： 4）浏览器收到304的响应后，就会从缓存中加载资源。 6. 协商缓存的管理协商缓存跟强缓存不一样，强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。大部分web服务器都默认开启协商缓存，而且是同时启用【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】，比如apache: 如果没有协商缓存，每个到服务器的请求，就都得返回资源内容，这样服务器的性能会极差。 【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】一般都是同时启用，这是为了处理Last-Modified不可靠的情况。有一种场景需要注意： 分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败； 分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）； 京东页面的资源请求，返回的repsones header就只有Last-Modified，没有ETag： 协商缓存需要配合强缓存使用，你看前面这个截图中，除了Last-Modified这个header，还有强缓存的相关header，因为如果不启用强缓存的话，协商缓存根本没有意义。 7. 浏览器行为对缓存的影响如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会先检查是否命中强缓存，如果强缓存命中则直接读取缓存，如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，如果协商缓存命中，则告诉浏览器还是可以从缓存读取，否则才从服务器返回最新的资源。这是默认的处理方式，这个方式可能被浏览器的行为改变： 1）当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存； 2）当f5刷新网页时，跳过强缓存，但是会检查协商缓存； 8. 不能缓存的请求当然并不是所有请求都能被缓存。 无法被浏览器缓存的请求： 1）HTTP信息头中包含Cache-Control:no-cache，pragma:no-cache（HTTP1.0），或Cache-Control:max-age=0等告诉浏览器不用缓存的请求 2）需要根据Cookie，认证信息等决定输入内容的动态请求是不能被缓存的 3）经过HTTPS安全加密的请求（有人也经过测试发现，ie其实在头部加入Cache-Control：max-age信息，firefox在头部加入Cache-Control:Public之后，能够对HTTPS的资源进行缓存，参考《HTTPS的七个误解》） 4）POST请求无法被缓存 5）HTTP响应头中不包含Last-Modified/Etag，也不包含Cache-Control/Expires的请求无法被缓存 本文来源：流云诸葛-博客园]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[imooc（五）]]></title>
    <url>%2F2017%2F08%2F18%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%BA%94%EF%BC%88imooc%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1. 渲染机制什么是DOCTYPE及作用 → 浏览器渲染过程 → 重排Reflow → 重绘Repaint → 布局Layout 1.1 什么是DOCTYPE及作用DTD （document type definition，文档类型定义）是一系列的语法规则，用来定义 XML 或 (X)HTML 的文件类型。浏览器会使用它来判断文档类型，决定使用何种协议来解析，以及切换浏览器模式。 DOCTYPE 是用来声明文档类型和 DTD 规范的，一个主要的用途便是文件的合法性验证。如果文件代码不合法，那么浏览器解析时就是出一些差错。 HTML 51&lt;!DOCTYPE html&gt; HTML 4.01 Strict12//该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt; HTML 4.01 Transitional 123//该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt; 1.2 浏览器如何渲染页面浏览器解析 1、浏览器通过请求的 URL 进行域名解析，向服务器发起请求，接收文件（HTML、CSS、JS、img等等）； 2、HTML 文件加载后开始构建 DOM Tree； 3、CSS 文件加载后开始解析和构建 CSS Rule Tree； 4、Javascript 脚本文件加载后， 通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree 浏览器渲染 浏览器渲染主要有三个步骤： 1、解析。浏览器会解析HTML/SVG/XHTML，浏览器解析这三种文件会产生一个DOM Tree；解析CSS，产生style rules；解析Javacript，主要通过DOM API和CSSOM API来操作DOM Tree和CSS Rule Tree。 2、解析完成后，浏览器引擎会通过DOM Tree和CSS Rule Tree来构造Rendering Tree。 3、调用操作系统Native GUI的API绘制。 1.3 重排 Reflow 和重绘 Repaint 注1注2Reflow 当元素改变的时候，将会影响文档内容或结构，或元素位置，此过程称为 Reflow。（ HTML 使用的是 flow based layout ，也就是流式布局，所以，如果某元件的几何尺寸发生了变化，需要重新布局，也就叫 Reflow。） 1234567当你增加、删除、修改DOM结点时，会导致Reflow或Repaint当你移动DOM的位置，或是搞个动画的时候。当你修改CSS样式的时候。当你Resize窗口的时候（移动端没有这个问题），或是滚动的时候。当你修改网页的默认字体时。注：display:none会触发reflow，而visibility:hidden只会触发repaint，因为没有发现位置变化。 Repaint当元素改变的时候，将不会影响元素在页面当中的位置（比如 background-color, border-color, visibility），浏览器仅仅会应用新的样式重绘此元素，此过程称为 Repaint。 屏幕的一部分要重画，比如某个CSS的背景色变了。但是元素的几何尺寸没有变。 2. JS运行机制JavaScript 运行机制详解 如何理解JS的单线程 → 什么是任务队列 → 什么是Event Loop 异步任务：setInterval()和setTimeout、DOM事件、ES6中的Promise 3. 页面性能关于页面性能 题目：提升页面性能的方法有哪些？ 1、资源压缩合并，减少HTTP请求； 2、非核心代码异步加载（异步加载的方式、异步加载的区别） 3、利用浏览器缓存（缓存的分类、缓存的原理） 4、使用CDN 5、预解析DNS 12&lt;meta http-equiv="x-dns-prefetch-control" content="on" /&gt;&lt;link rel="dns-prefetch" href="//host_name_to_prefetch.com" /&gt; 3. 1 异步加载的方式1、动态脚本加载 12345678(function()&#123; var script = document.createElement('script'); script.type = 'text/javascript'; script.src = "http://code.jquery.com/jquery-1.7.2.min.js"; var tmp = document.getElementsByTagName('script')[0]; tmp.parentNode.insertBefore(script, tmp);&#125;)();//兼容所有浏览器 2、defer 12345&lt;script&gt;标签的defer="defer"属性defer属性规定是否对脚本执行进行延迟，直到页面加载为止如果脚本不会改变文档的内容，可将defer属性加入到&lt;script&gt;标签中，以便加快处理文档的速度兼容所有浏览器此方法可以确保所有设置了defer属性的脚本按顺序执行 3、async 12345&lt;script&gt;标签的async="async"属性async属性是HTML5新增属性，需要Chrome、FireFox、IE9+浏览器支持async属性规定一旦脚本可用，则会异步执行async属性仅适用于外部脚本此方法不能保证脚本按顺序执行 3.2 异步加载的区别1、defer是在HTML解析完之后才会执行，如果是多个，按照加载的顺序依次执行； 2、async是在加载完之后立即执行，如果是多个，执行顺序和加载顺序无关。 3.3 浏览器缓存注强制缓存： Expires：服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。 Cache-Control：是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示。 协商缓存： Last-Modified、If-Modified-Since: ETag、If-None-Match： 4. 错误监控前端错误的分类 → 错误的捕获方式 → 上报错误的基本原理 4.1 前端错误的分类即时运行错误：代码错误 资源加载错误 4.2 错误的捕获方式即时运行错误的捕获方式： 1231. try..catch2.window.onerror 资源加载错误：123451.object.onerror2.performance.getEntries()3.Error事件捕获 延伸：跨域的JS运行错误可以捕获吗，错误提示什么，应该怎么处理？ 121.在script标签增加crossing属性2.设置js资源响应头Access-Control-Origin：* 4.3上报错误的基本原理1、采用Ajax通信的方式上报 2、利用Image对象上报 1(new Image()).src="http://baidu.com/test?r=bhhj";]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[imooc（四）]]></title>
    <url>%2F2017%2F08%2F18%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9B%9B%EF%BC%88imooc%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1.通信类什么是同源策略及限制 → 前后端如何通信 → 如何创建Ajax → 跨域通信的几种方式 1.1什么是同源策略及其限制浏览器同源政策及其规避方法 所谓”同源”指的是”三个相同：协议相同、域名相同、端口相同。指一段脚本只能读取来自同一来源的窗口和文档的属性。 同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。 同源策略的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。 限制范围： 12345（1） Cookie、LocalStorage 和 IndexDB 无法读取。（2） DOM 无法获得。（3） AJAX 请求不能发送。 1.2 前后端如何通信一、Ajax（Aajx请求只能发给同源的网址） 二、WebSocket（该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。） 三、CORS（Cross-Origin Resource Sharing）（同源跨域都支持） 1.3 如何创建一个AjaxAjax和Http状态字 一、XMLHttpRequest对象的工作流程 二、兼容性处理 三、事件的触发条件 四、事件的触发顺序 123456789101112var xhr=new XMLHttpRequest();xhr.onreadystatechange=function () &#123; if (xhr.readyState==4) &#123; if (xhr.status&gt;=200&amp;&amp;xhr.status&lt;300||xhr.status==304) &#123; //代码 &#125; &#125;&#125;xhr.open("get","./",true);xhr.send(null); 1.4 跨域通信的几种方式123456789JSONPHash （hash改变，页面不会刷新）postMessage（H5新增）WebSocket（不受同源策略限制）CORS（可理解为支持跨域通信的Ajax） JSONP跨域原理： 基本原理：利用script标签的异步加载特性实现给服务端传一个回调函数，服务器返回一个传递过去的回调函数名称的JS代码 在remote.com 上有remote.js文件，内容如下： 1callback(&#123;"result": "data from remote.com"&#125;); 我们本地的jsonp.html页面中包含了如下JavaScript代码： 123456&lt;script type="text/javascript"&gt;var callback = function(data)&#123; alert('receive data from remote:' + data.result);&#125;;&lt;/script&gt;&lt;script type="text/javascript" src="http://remote.com/remote.js"&gt;&lt;/script&gt; 在浏览器打开jsonp.html，我们会看到弹出窗，内容为： 1receive data from remote: data from remote.com 利用&lt;script src=&quot;remote.js&quot;&gt;不受同源策略限制的后门，达到向remote URL获取数据然后更新本地页面DOM的目的。这就是JSONP的核心。 WebSocket教程 跨域资源共享 CORS 详解 2. 安全类2.1 CSRF（跨站请求伪造）浅谈CSRF攻击方式 一、基本概念 CSRF（Cross-site request forgery）：跨站请求伪造。可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。 二、攻击原理 三、防御措施 Token 验证 Referer 验证 隐藏令牌 2.2 XSS（跨站脚本攻击）指的是攻击者往Web页面里插入恶意html标签或者javascript代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。 Web安全-XSS 3. 算法类排序 → 堆栈、队列、链表 → 递归 → 波兰式和逆波兰式 3.1 排序冒泡排序： 快速排序： 选择排序： 希尔排序： 3.2 堆栈、队列和链表堆栈、队列和链表.html) 3.3 递归递归 3.4 波兰式和逆波兰式理论 源码]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
        <tag>通信</tag>
        <tag>JSONP跨域</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[imooc（三）]]></title>
    <url>%2F2017%2F08%2F18%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B8%89%EF%BC%88imooc%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1.原型链类创建对象有几种方法 → 原型、构造函数、实例、原型链 → instanceof 的原理 → new 运算符 1.1 创建对象的方式一、字面量方式创建 1234var obj = &#123; name : 'Beme', age : 21&#125;;//分号最好加上 二、通过构造函数创建 1234567function Person(name,age)&#123; this.name=name; this.age=age;&#125;var boy=new Person('小明',12);var girl=new Person('小红',10) 三、Object.create1234567var Person = &#123; name : "Beme", age : 21, run: function()&#123; alert("I like running"); &#125; &#125; 然后，直接用Object.create()生成实例，不需要用到new。 123var p1 = Object.create(Person); alert(p1.age);//21 p1.run();//I like running 这种方法比”构造函数法”简单，但是不能实现私有属性和私有方法，实例对象之间也不能共享数据，对”类”的模拟不够全面。 1.2 原型、构造函数、实例、原型链JavaScript学习总结（五）原型和原型链详解 注：图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。 1.3 instanceof 的原理123456function Person(name) &#123; this.name=name;&#125;;var Beme=new Person('Beme');console.log(Beme instanceof Person); //trueconsole.log(Beme instanceof Object); //true 为什么 Beme instanceof Object结果为true呢？ 12因为：Beme.__proto__===Person.prototype;而 Person.prototype.__proto__===Object.prototype 12A instanceof B 验证A对象是不是B类的实例。A instanceof B， 不能证明A是new B()出来的，因为可能是继承。 我们用constructor来判断比用instanceof更严谨：12345function Person(name) &#123; this.name=name;&#125;;var Beme=new Person('Beme');console.log(Beme.__proto__.constructor===Person);//true 1.4 new运算符首先，一个新对象被创建。它继承自foo.prototype。然后，构造函数foo被执行。执行的时候，相应的传参会被传入，同时上下文（this）会被指定为这个新实例。new foo等同于new foo()，只能用在不传递任何参数的情况。最后，如果构造函数返回了一个“对象”，那么这个对象会取代整个new出来的结果。如果构造函数没有返回对象，那么new出来的结果为步骤1创建的对象。 123456789var new1=function (func) &#123; var o=Object.create(func.prototype); var k=func.call(o); if (typeof k === 'object') &#123; return k; &#125;else &#123; return o; &#125;&#125;;//new1 的工作原理和new的原理一样。 2. 面向对象类类与实例（类的声明、生成实例） → 类与继承（如何实现继承、继承的几种方式） JavaScript继承方式详解 原型和原型链详解]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>原型链</tag>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[互联网协议入门（二）]]></title>
    <url>%2F2017%2F08%2F17%2F%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[七、一个小结我们已经知道，网络通信就是交换数据包。电脑A向电脑B发送一个数据包，后者收到了，回复一个数据包，从而实现两台电脑之间的通信。数据包的结构，基本上是下面这样： 发送这个包，需要知道两个地址： 123* 对方的MAC地址* 对方的IP地址 有了这两个地址，数据包才能准确送到接收者手中。但是，前面说过，MAC地址有局限性，如果两台电脑不在同一个子网络，就无法知道对方的MAC地址，必须通过网关（gateway）转发。 上图中，1号电脑要向4号电脑发送一个数据包。它先判断4号电脑是否在同一个子网络，结果发现不是（后文介绍判断方法），于是就把这个数据包发到网关A。网关A通过路由协议，发现4号电脑位于子网络B，又把数据包发给网关B，网关B再转发到4号电脑。 1号电脑把数据包发到网关A，必须知道网关A的MAC地址。所以，数据包的目标地址，实际上分成两种情况： 12345场景 数据包地址同一个子网络 对方的MAC地址，对方的IP地址非同一个子网络 网关的MAC地址，对方的IP地址 发送数据包之前，电脑必须判断对方是否在同一个子网络，然后选择相应的MAC地址。接下来，我们就来看，实际使用中，这个过程是怎么完成的。 八、用户的上网设置8.1 静态IP地址你买了一台新电脑，插上网线，开机，这时电脑能够上网吗？通常你必须做一些设置。有时，管理员（或者ISP）会告诉你下面四个参数，你把它们填入操作系统，计算机就能连上网了： 1234567* 本机的IP地址* 子网掩码* 网关的IP地址* DNS的IP地址 下图是Windows系统的设置窗口。 这四个参数缺一不可，后文会解释为什么需要知道它们才能上网。由于它们是给定的，计算机每次开机，都会分到同样的IP地址，所以这种情况被称作”静态IP地址上网”。 但是，这样的设置很专业，普通用户望而生畏，而且如果一台电脑的IP地址保持不变，其他电脑就不能使用这个地址，不够灵活。出于这两个原因，大多数用户使用”动态IP地址上网”。 8.2 动态IP地址所谓”动态IP地址”，指计算机开机后，会自动分配到一个IP地址，不用人为设定。它使用的协议叫做DHCP协议。 这个协议规定，每一个子网络中，有一台计算机负责管理本网络的所有IP地址，它叫做”DHCP服务器”。新的计算机加入网络，必须向”DHCP服务器”发送一个”DHCP请求”数据包，申请IP地址和相关的网络参数。 前面说过，如果两台计算机在同一个子网络，必须知道对方的MAC地址和IP地址，才能发送数据包。但是，新加入的计算机不知道这两个地址，怎么发送数据包呢？ DHCP协议做了一些巧妙的规定。 8.3 DHCP协议首先，它是一种应用层协议，建立在UDP协议之上，所以整个数据包是这样的： （1）最前面的”以太网标头”，设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。 （2）后面的”IP标头”，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。 （3）最后的”UDP标头”，设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。 这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道”这个包是发给我的”，而其他计算机就可以丢弃这个包。 接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个”DHCP响应”数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。 新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。 8.4 上网设置：小结这个部分，需要记住的就是一点：不管是”静态IP地址”还是”动态IP地址”，电脑上网的首要步骤，是确定四个参数。这四个值很重要，值得重复一遍： 1234567* 本机的IP地址* 子网掩码* 网关的IP地址* DNS的IP地址 有了这几个数值，电脑就可以上网”冲浪”了。接下来，我们来看一个实例，当用户访问网页的时候，互联网协议是怎么运作的。 九、一个实例：访问网页9.1 本机参数我们假定，经过上一节的步骤，用户设置好了自己的网络参数： 1234567* 本机的IP地址：192.168.1.100* 子网掩码：255.255.255.0* 网关的IP地址：192.168.1.1* DNS的IP地址：8.8.8.8 然后他打开浏览器，想要访问Google，在地址栏输入了网址：www.google.com。 这意味着，浏览器要向Google发送一个网页请求的数据包。 9.2 DNS协议我们知道，发送数据包，必须要知道对方的IP地址。但是，现在，我们只知道网址www.google.com，不知道它的IP地址。 DNS协议可以帮助我们，将这个网址转换成IP地址。已知DNS服务器为8.8.8.8，于是我们向这个地址发送一个DNS数据包（53端口）。 然后，DNS服务器做出响应，告诉我们Google的IP地址是172.194.72.105。于是，我们知道了对方的IP地址。 9.3 子网掩码接下来，我们要判断，这个IP地址是不是在同一个子网络，这就要用到子网掩码。 已知子网掩码是255.255.255.0，本机用它对自己的IP地址192.168.1.100，做一个二进制的AND运算（两个数位都为1，结果为1，否则为0），计算结果为192.168.1.0；然后对Google的IP地址172.194.72.105也做一个AND运算，计算结果为172.194.72.0。这两个结果不相等，所以结论是，Google与本机不在同一个子网络。 因此，我们要向Google发送数据包，必须通过网关192.168.1.1转发，也就是说，接收方的MAC地址将是网关的MAC地址。 9.4 应用层协议浏览网页用的是HTTP协议，它的整个数据包构造是这样的： HTTP部分的内容，类似于下面这样： 123456789 GET / HTTP/1.1Host: www.google.comConnection: keep-aliveUser-Agent: Mozilla/5.0 (Windows NT 6.1) ……Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Encoding: gzip,deflate,sdchAccept-Language: zh-CN,zh;q=0.8Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3Cookie: … … 我们假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。 9.5 TCP协议TCP数据包需要设置端口，接收方（Google）的HTTP端口默认是80，发送方（本机）的端口是一个随机生成的1024-65535之间的整数，假定为51775。 TCP数据包的标头长度为20字节，加上嵌入HTTP的数据包，总长度变为4980字节。 9.6 IP协议然后，TCP数据包再嵌入IP数据包。IP数据包需要设置双方的IP地址，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。 IP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。 9.7 以太网协议最后，IP数据包嵌入以太网数据包。以太网数据包需要设置双方的MAC地址，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。 以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。 9.8 服务器端响应经过多个网关的转发，Google的服务器172.194.72.105，收到了这四个以太网数据包。 根据IP标头的序号，Google将四个包拼起来，取出完整的TCP数据包，然后读出里面的”HTTP请求”，接着做出”HTTP响应”，再用TCP协议发回来。 本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。 这个例子就到此为止，虽然经过了简化，但它大致上反映了互联网协议的整个通信过程。]]></content>
      <categories>
        <category>零碎笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[互联网协议入门（一）]]></title>
    <url>%2F2017%2F08%2F17%2F%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言我们每天使用互联网，你是否想过，它是如何实现的？ 全世界几十亿台电脑，连接在一起，两两通信。上海的某一块网卡送出信号，洛杉矶的另一块网卡居然就收到了，两者实际上根本不知道对方的物理位置，你不觉得这是很神奇的事情吗？ 互联网的核心是一系列协议，总称为”互联网协议”（Internet Protocol Suite）。它们对电脑如何连接和组网，做出了详尽的规定。理解了这些协议，就理解了互联网的原理。 一、概述1.1 五层模型互联网的实现，分成好几层。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。 用户接触到的，只是最上面的一层，根本没有感觉到下面的层。要理解互联网，必须从最下层开始，自下而上理解每一层的功能。 如何分层有不同的模型，有的模型分七层，有的分四层。我觉得，把互联网分成五层，比较容易解释。 如上图所示，最底下的一层叫做”实体层”（Physical Layer），最上面的一层叫做”应用层”（Application Layer），中间的三层（自下而上）分别是”链接层”（Link Layer）、”网络层”（Network Layer）和”传输层”（Transport Layer）。越下面的层，越靠近硬件；越上面的层，越靠近用户。 它们叫什么名字，其实并不重要。只需要知道，互联网分成若干层就可以了。 1.2 层与协议每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则。 大家都遵守的规则，就叫做”协议”（protocol）。 互联网的每一层，都定义了很多协议。这些协议的总称，就叫做”互联网协议”（Internet Protocol Suite）。它们是互联网的核心，下面介绍每一层的功能，主要就是介绍每一层的主要协议。 二、实体层我们从最底下的一层开始。 电脑要组网，第一件事要干什么？当然是先把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。 这就叫做”实体层”，它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。 三、链接层3.1 定义单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？ 这就是”链接层”的功能，它在”实体层”的上方，确定了0和1的分组方式。 3.2 以太网协议早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做“以太网”（Ethernet）的协议，占据了主导地位。 以太网规定，一组电信号构成一个数据包，叫做”帧”（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。 “标头”包含数据包的一些说明项，比如发送者、接受者、数据类型等等；”数据”则是数据包的具体内容。 “标头”的长度，固定为18字节。”数据”的长度，最短为46字节，最长为1500字节。因此，整个”帧”最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。 3.3 MAC地址上面提到，以太网数据包的”标头”，包含了发送者和接受者的信息。那么，发送者和接受者是如何标识呢？ 以太网规定，连入网络的所有设备，都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。 每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。 前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。 3.4 广播定义地址只是第一步，后面还有更多的步骤。 首先，一块网卡怎么会知道另一块网卡的MAC地址？ 回答是有一种ARP（Address Resolution Protocol）协议，可以解决这个问题。这个留到后面介绍，这里只需要知道，以太网数据包必须知道接收方的MAC地址，然后才能发送。 其次，就算有了MAC地址，系统怎样才能把数据包准确送到接收方？ 回答是以太网采用了一种很”原始”的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。 上图中，1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机都会收到这个包。它们读取这个包的”标头”，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做”广播”（broadcasting）。 有了数据包的定义、网卡的MAC地址、广播的发送方式，”链接层”就可以在多台计算机之间传送数据了。 四、网络层4.1 网络层的由来以太网协议，依靠MAC地址发送数据。理论上，单单依靠MAC地址，上海的网卡就可以找到洛杉矶的网卡了，技术上是可以实现的。 但是，这样做有一个重大的缺点。以太网采用广播方式发送数据包，所有成员人手一”包”，不仅效率低，而且局限在发送者所在的子网络。也就是说，如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理的，否则互联网上每一台计算机都会收到所有包，那会引起灾难。 互联网是无数子网络共同组成的一个巨型网络，很难想象上海和洛杉矶的电脑会在同一个子网络，这几乎是不可能的。 因此，必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送。（”路由”的意思，就是指如何向不同的子网络分发数据包，这是一个很大的主题，本文不涉及。）遗憾的是，MAC地址本身无法做到这一点。它只与厂商有关，与所处网络无关。 这就导致了”网络层”的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。 于是，”网络层”出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。 网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。 4.2 IP协议规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。 目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。 习惯上，我们用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。 互联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。 但是，问题在于单单从IP地址，我们无法判断网络部分。还是以172.16.254.1为例，它的网络部分，到底是前24位，还是前16位，甚至前28位，从IP地址上是看不出来的。 那么，怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数”子网掩码”（subnet mask）。 所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。 知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。 比如，已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。 总结一下，IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。 4.3 IP数据包根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息。 但是前面说过，以太网数据包只包含MAC地址，并没有IP地址的栏位。那么是否需要修改数据定义，再添加一个栏位呢？ 回答是不需要，我们可以把IP数据包直接放进以太网数据包的”数据”部分，因此完全不用修改以太网的规格。这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构。 具体来说，IP数据包也分为”标头”和”数据”两个部分。 “标头”部分主要包括版本、长度、IP地址等信息，”数据”部分则是IP数据包的具体内容。它放进以太网数据包后，以太网数据包就变成了下面这样。 IP数据包的”标头”部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。因此，理论上，一个IP数据包的”数据”部分，最长为65,515字节。前面说过，以太网数据包的”数据”部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。 4.4 ARP协议（地址解析协议）关于”网络层”，还有最后一点需要说明。 因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的MAC地址，另一个是对方的IP地址。通常情况下，对方的IP地址是已知的（后文会解释），但是我们不知道它的MAC地址。 所以，我们需要一种机制，能够从IP地址得到MAC地址。 这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），让网关去处理。 第二种情况，如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。 总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。 五、传输层5.1 传输层的由来有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。 接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？ 也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。 “端口”是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。 “传输层”的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做”套接字”（socket）。有了它，就可以进行网络应用程序开发了。 5.2 UDP协议（用户数据报协议）现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。 UDP数据包，也是由”标头”和”数据”两部分组成。 “标头”部分主要定义了发出端口和接收端口，”数据”部分就是具体的内容。然后，把整个UDP数据包放入IP数据包的”数据”部分，而前面说过，IP数据包又是放在以太网数据包之中的，所以整个以太网数据包现在变成了下面这样： UDP数据包非常简单，”标头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。 5.3 TCP协议（传输控制协议）UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。 为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。 因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。 TCP数据包和UDP数据包一样，都是内嵌在IP数据包的”数据”部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。 六、应用层应用程序收到”传输层”的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。 “应用层”的作用，就是规定应用程序的数据格式。 举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。 这是最高的一层，直接面对用户。它的数据就放在TCP数据包的”数据”部分。因此，现在的以太网的数据包就变成下面这样。 至此，整个互联网的五层结构，自下而上全部讲完了。这是从系统的角度，解释互联网是如何构成的。下一篇，我们从用户的角度，自上而下看看这个结构是如何发挥作用，完成一次网络数据交换的。 文章来源：http://www.ruanyifeng.com]]></content>
      <categories>
        <category>零碎笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[imooc（二）]]></title>
    <url>%2F2017%2F08%2F16%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%BA%8C%EF%BC%88imooc%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1.DOM事件类基本概念：DOM 事件的级别 → DOM事件模型（冒泡和捕获） → DOM 事件流 → 描述DOM事件捕获的具体流程 → Event对象的常见应用 → 自定义事件 1.1事件级别DOM01element.onclick=function()&#123;&#125; DOM2 12345element.addEventListener('click',function()&#123;&#125;,false)默认：false（冒泡）true（捕获） DOM31element.addEventListener('keyup',function()&#123;&#125;,false) 1.2事件模型DOM事件模型包括冒泡型事件和捕获型事件。 冒泡型事件：事件从特定的事件目标到最不特定的事件目标的顺序触发。 捕获型事件：与冒泡事件相反，事件从最不精确的对象开始触发，然后到最精确。 1.3事件流事件流包括三个阶段：事件捕获阶段–&gt;处于目标阶段–&gt;事件冒泡阶段。 首先发生的是事件捕获阶段，为截获事件提供了机会。然后是实际的目标接收事件。最后一个阶段是冒泡阶段。 1.4事件捕获和冒泡的具体流程Window –&gt; Document –&gt; html –&gt; body –&gt; … –&gt; 目标元素 1.5 Event对象的常见应用event.preventDefault()：取消事件的默认动作。 event.stopPropagation()：阻止事件冒泡。 event.stopImmediatePropagation()：如果一个元素上绑定了多个事件，若其中某个事件执行了此方法，那么后续的事件将不再执行。 event.currentTarget()：返回其监听器触发事件的节点，即当前处理该事件的元素、文档或窗口。 event.target()：返回事件的目标节点（触发该事件的节点），如生成事件的元素、文档或窗口。 1.6自定义事件1234567var event = new Event('build');// Listen for the event.elem.addEventListener('build', function (e) &#123; ... &#125;, false);// Dispatch the event.elem.dispatchEvent(event); CustomEvent 2. HTTP协议类HTTP协议的主要特点 → HTTP报文的组成部分 → HTTP方法 → POST 和 GET 的区别 → HTTP 状态码 → 什么是持久连接 → 什么是管线化 2.1 HTTP协议的主要特点一、简单快速：客户端向服务器请求服务时，只需传送请求方法和路径。 二、灵活：HTTP允许传输任意类型的数据对象。 三、无连接：服务器处理完客户端的请求并收到客户端的应答后，即断开连接。采用这种方式可以节省传输时间。 四、无状态：指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。 2.2 HTTP报文的组成部分HTTP 报文的组成部分 一、请求报文：请求行、请求头、空行、请求体。 二、响应报文：状态行、响应头、空行、响应体。 2.3 HTTP方法一、GET：获取资源 二、POST：传输资源 三、PUT：更新资源 四、DELETE：删除资源 五、HEAD：获得报文首部 2.4 POST和GET的区别（重要）POST和GET的区别 GET 在浏览器回退时是无害的，而 POST 会再次提交请求 GET 请求会被浏览器主动缓存，而 POST 不会，除非手动设置 GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留 GET 请求在URL中传送的参数是有长度限制的，而 POST 没有长度限制 与 POST 相比，GET 的安全性较差，因为 GET 的参数直接暴露在URL上，所以不能来传递敏感信息 GET 参数通过 URL 传递，POST 放在 Request body中 2.5 HTTP 状态码HTTP 状态消息 1XX：指示信息 - 表示请求已收到，继续处理 2XX：成功 - 表示请求已被成功接收 3XX：重定向 - 要完成请求必须进行更进一步操作 4XX：客户端错误 - 请求有语法错误或请求无法实现 5XX：服务器错误 - 服务器未能实现合法的请求 2.6 持久连接HTTP 协议采用“请求 - 应答”模式，当使用普通模式，即非 Keep-Alive 模式时，每个请求/应答客户和服务器都要新建立一个连接，完成之后立即断开连接（HTTP协议为无连接的协议）。 当使用 Keep-Alive 模式（又称持久连接、连接重用）时，Keep-Alive 功能使客户端到服务器端的连接持久有效，当出现对服务器的后续请求时，Keep-Alive 功能避免了建立或者重新建立连接。 Keep-Alive 模式在 HTTP/1.1支持，HTTP/1.0 不支持。 2.7 管线化HTTP管线化可以克服同域并行请求限制带来的阻塞，它是建立在持久连接之上，是把所有请求一并发给服务器，但是服务器需要按照顺序一个一个响应，而不是等到一个响应回来才能发下一个请求，这样就节省了很多请求到服务器的时间。 管线化机制须通过永久连接（persistent connection）完成，仅 HTTP/1.1 支持此技术（ HTTP/1.0 不支持），并且只有 GET 和 HEAD 要求可以进行管线化，而POST则有所限制。此外，初次创建连接时也不应启动管线机制，因为对方（服务器）不一定支持 HTTP/1.1 版本的协议。]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[imooc（一）]]></title>
    <url>%2F2017%2F08%2F15%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B8%80%EF%BC%88imooc%EF%BC%89%2F</url>
    <content type="text"><![CDATA[页面布局 题目：假设高度已知，请写出三栏布局，其中左栏、右栏宽度各为300px，中间自适应。 float实现基于纯float实现的三栏布局需要将中间的内容放在HTML结构的最后，否则右侧会沉在中间内容的下侧。 原理：元素浮动后，脱离文档流，后面的元素受浮动影响，设置受影响元素的margin值即可。 两边固定宽度，中间宽度自适应。 利用中间元素的margin值控制两边的间距。 宽度小于左右部分宽度之和时，右侧部分会被挤下去。 12345678910&lt;div class="left"&gt;左侧宽度固定&lt;/div&gt;&lt;div class="right"&gt;右侧宽度固定&lt;/div&gt;&lt;div class="main"&gt;中间内容自适应&lt;/div&gt;&lt;style type="text/css"&gt; div &#123;height: 100px;&#125; .left &#123;width: 300px;background: blue;float: left;&#125; .right &#123;width: 300px;background: green;float: right;&#125; .main &#123;background: gray;&#125;&lt;/style&gt; position实现12345678910&lt;div class="left"&gt;左侧宽度固定&lt;/div&gt;&lt;div class="main"&gt;中间内容自适应&lt;/div&gt;&lt;div class="right"&gt;右侧宽度固定&lt;/div&gt;&lt;style type="text/css"&gt; div &#123;height: 100px;&#125; .left&#123;position: absolute;left: 0;width: 300px;background: yellow;&#125; .right&#123;position: absolute;right: 0;width: 300px;background: gray;&#125; .main&#123;position: absolute;left: 300px;right: 300px;background: skyblue;&#125;&lt;/style&gt; flex布局在外围包裹一层div，设置为display：flex；中间设置flex：1；但是盒模型默认紧紧挨着，可以使用margin控制外边距。 12345678910111213&lt;div id="wrap"&gt; &lt;div class="left"&gt;左侧宽度固定&lt;/div&gt; &lt;div class="main"&gt;中间内容自适应&lt;/div&gt; &lt;div class="right"&gt;右侧宽度固定&lt;/div&gt;&lt;/div&gt;&lt;style type="text/css"&gt; div &#123;height: 100px;&#125; #wrap &#123;display: flex;&#125; .left &#123;width: 300px;background: red;&#125; .right &#123;width: 300px;background: blue;&#125; .main &#123;flex: 1;background: pink;&#125;&lt;/style&gt; 页面布局的变通三栏布局 左右宽度固定，中间自适应 上下高度固定，中间自适应 两栏布局 左宽度固定，右自适应 右宽度固定，左自适应 上高度固定，下自适应 下高度固定，上自适应 CSS盒模型 谈谈你对CSS盒模型的认识 标准模型+IE模型 → 标准模型和IE模型的区别 → CSS如何设置这两种模型 → JS如何设置获取盒模型对应的宽和高 → 实例题（根据盒模型解释边距重叠）→ BFC（边距重叠解决方案） 标准模型+IE模型两者的区别在于content的不同，IE(5.5及以前)盒模型的content包括border、padding CSS如何设置这两种模型123456box-sizing:border-box || content-box(default)当使用border-box时，页面将采用怪异模式解析计算，怪异模式也称为IE模式。当使用content-box时：页面将采用标准模式来解析计算，content-box也是默认模式 此特性在自适应的网页会非常好用，因为它不会破坏网页的结构 BFC浅析什么是BFC（Block formatting contexts）浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。 在BFC中，盒子从顶端开始垂直地一个接一个地排列，两个盒子之间的垂直的间隙是由他们的margin 值所决定的。在一个BFC中，两个相邻的块级盒子的垂直外边距会产生折叠。 在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）。 BFC 的特性BFC 对布局的影响主要体现在对 float和 margin 两个属性的处理。在我看来，BFC 让 float和 margin 这两个属性的表现更加符合我们的直觉。 根据 BFC 对其内部元素和外部元素的表现特性，我将 BFC 的特性总结为对内部元素的包裹性及对外部元素的独立性。 对内部元素的包裹性BFC 对内部元素的包裹性主要体现在 BFC 可以包裹浮动元素，以及 BFC 可以包裹 margin。 BFC 包裹浮动元素BFC 的特性之一就是其高度的计算会包括所有浮动元素的高度，所以使用 BFC 可以包裹浮动元素，达到清除浮动的目的。 1234&lt;div style="overflow: hidden; background: #AAA;"&gt; &lt;div style="float: left; width: 100px; height: 100px; background: #000;"&gt; &lt;/div&gt;&lt;/div&gt; overflow: hidden 可以触发一个元素的 BFC 属性，使该元素成为一个 BFC 容器，从而使该元素对内部元素及外部元素表现出 BFC 的特性，更多可以触发 BFC 属性的条件会在后面总结。 运行代码可以看到，我们虽然没有进行任何清除浮动的工作，外层 div 还是包裹住了内层浮动的 div，没有造成高度塌陷的情况。 另外，将外层div 同时设为浮动来清除内层浮动的方法本质上也是应用了 BFC 的特性，因为将一个元素设为浮动也会触发该元素的 BFC 属性，使外层元素成为一个 BFC 容器。 BFC 包裹 marginBFC 对内部元素的另一个特性就是可以取消margin 折叠(margin collapse)。这个特性我喜欢更形象的称之为包裹margin。 1234&lt;div style="background: #AAA;"&gt; &lt;div style="width: 100px; height: 100px; margin-top: 50px; background: #000;"&gt; &lt;/div&gt;&lt;/div&gt; 运行代码可以看到，内层 div的 margin 并没有将内层div相对于外层 div 向下推移，而是将内外两层 div 整体向下推移： 而我们想要的结果是这样的： 内外两层div被整体向下推移的原因就是margin 折叠，关于margin 折叠的相关介绍可以参见这里。CSS 中父子元素的 margin 只要相邻，也会发生折叠，CSS 规范虽是如此，但很多时候这并不符合我们的预期：我们希望外部div能够包裹内部div的 margin，避免形成折叠，这时我们就可以使用 BFC。 1234&lt;div style="overflow:hidden; background:#AAA;"&gt; &lt;div style="width:100px; height:100px; margin-top:50px; background:#000;"&gt; &lt;/div&gt;&lt;/div&gt; 我们将外层 div设置为一个 BFC 容器，由于 margin折叠只会发生在同一个 BFC 中的元素之间，而不同 BFC 的元素之间以及元素及其所属的 BFC 之间不会发生 margin折叠，因此就可以实现对 margin 的包裹。 对外部元素的独立性BFC 对外部元素的独立性在于 BFC元素不会与浮动元素叠加。例如： 1234&lt;div style="float: left; width: 100px; height: 100px; background: #000;"&gt;&lt;/div&gt;&lt;div style="height: 200px; background: #AAA;"&gt;&lt;/div&gt; 可以看到，浮动的div 由于脱离了文档流，导致正常的 div 左上角被覆盖。为了避免这种情况，我们使第二个 div 成为 BFC 容器： 1234&lt;div style="float: left; width: 100px; height: 100px; background: #000;"&gt;&lt;/div&gt;&lt;div style="overflow: hidden; height: 200px; background: #AAA;"&gt;&lt;/div&gt; 当第二个div 成为 BFC 容器后，其不会再受到浮动 div的影响，布局相对独立。这样的技巧经常用作两栏或三栏自适应布局。 触发 BFC介绍 BFC 的时候我们就已经说过，BFC 可以被理解为元素的一个属性，但是这个属性无法被显式的设置，那么如何触发一个元素的 BFC 属性呢？上面的代码中使用的 overflow:hidden 就是触发 BFC 的一种方式，除了设置 overflow:hidden，下面的 CSS 属性设置都可以触发 BFC: 1234567float 设置为除 none 外的取值；overflow 设置为除 visible 之外的取值；position 设置为除 static 及 relative 之外的取值；display 设置为 table-cell、table-caption、inline-block 中的任一取值； BFC 与 LayoutIE 作为浏览器中的奇葩，当然不可能按部就班的支持 BFC 标准，于是乎 IE 中有了 Layout 这个东西。Layout 和 BFC 基本是等价的，为了处理 IE 的兼容性，在需要触发 BFC 时，我们除了需要用上面的 CSS 属性来触发 BFC，还需要针对 IE 浏览器使用 zoom: 1来触发 IE 浏览器的 Layout。 BFC的作用自适应的两栏布局12&lt;div style="width: 300px;height: 100px;background: #000;float: left;"&gt;&lt;/div&gt;&lt;div style="height: 200px;background: #AAA;overflow: hidden;"&gt;&lt;/div&gt; 清除内部浮动未触发BFC1234&lt;div style="width: 300px;background: blue;"&gt; &lt;div style="width: 100px;height: 100px;background: #AAA;float: left;"&gt;&lt;/div&gt; &lt;span&gt;这是里面的内容&lt;/span&gt;&lt;/div&gt; 触发BFC 1234&lt;div style="width: 300px;background: blue;overflow: hidden;"&gt; &lt;div style="width: 100px;height: 100px;background: #AAA;float: left;"&gt;&lt;/div&gt; &lt;span&gt;这是里面的内容&lt;/span&gt;&lt;/div&gt; 防止margin重叠123456789&lt;p&gt;内容一&lt;/p&gt;&lt;p&gt;内容二&lt;/p&gt;p&#123; background: #AAA; width: 200px; height: 100px; margin: 100px;&#125; 我们可以在p外面包裹一层容器，并触发该容器生成一个BFC。那么两个P便不属于同一个BFC，就不会发生margin重叠了。 1234567891011121314&lt;p&gt;内容一&lt;/p&gt;&lt;div class="wrap"&gt; &lt;p&gt;内容二&lt;/p&gt;&lt;/div&gt;p&#123; background: #AAA; width: 200px; height: 100px; margin: 100px;&#125;.wrap&#123; overflow: hidden;&#125; 浅析BFC：https://zjy.name/archives/bfc-introduction.html]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一些JavaScript面试题（一）]]></title>
    <url>%2F2017%2F08%2F09%2F%E4%B8%80%E4%BA%9BJavaScript%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[给数字加上千分位。字符串方法： 123456789function toThousands(num) &#123; var num = (num || 0).toString(), result = ''; while (num.length &gt; 3) &#123; result = ',' + num.slice(-3) + result; num = num.slice(0, num.length - 3); &#125; if (num) &#123; result = num + result; &#125; return result;&#125; 正则表达式： 123function toThousands(num) &#123; return (num || 0).toString().replace(/\B(?=(\d&#123;3&#125;)+$)/g,",");&#125; 数组去重方法一（IE8及以下不支持）： 1234567891011var arr = [0,0,1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 3]; function uniqueArr(arr) &#123; var result = []; for (var i = 0; i &lt; arr.length; i++) &#123; if (result.indexOf(arr[i]) == -1) &#123; result.push(arr[i]) &#125; &#125; return result; &#125; console.log(uniqueArr(arr));//[0, 1, 2, 3] 方法二： 1234567891011121314var arr = [0,0,1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 3]; function uniqueArr(arr) &#123; var temp=&#123;&#125;, //这个对象是数组伴随对象，能够方便检索数组中是否存在某一个数字 result = []; for(var i=0;i&lt;arr.length;i++)&#123; //检查对象中有没有这个属性，如果没有这个属性，那么推入结果数组，并且让对象添加这个属性。属性值设置为1。 if (!temp[arr[i]]) &#123; result.push(arr[i]); temp[arr[i]]=1; &#125; &#125; return result; &#125; console.log(uniqueArr(arr));//[0, 1, 2, 3] 方法三：先排序，再去重 123456789var a = [1, 1,11,12,12,2, 3, 4, 4, 3, 2];a = a.sort();var b = [];for (var i = 0; i &lt; a.length; i++) &#123; if (a[i] !== a[i - 1]) &#123; b.push(a[i]); &#125;&#125;console.log(b); typeof都返回哪些数据类型1undefined、string、number、Boolean、object、function 字符串反转，例如abcdefg返回gfedcba。用两种方法实现。方法一： 123456789var str = "abcdefg"; function revStr(str) &#123; var result = ""; for (var i = str.length - 1; i &gt;= 0; i--) &#123; result += str[i]; &#125; return result; &#125; console.log(revStr(str));//gfedcba 方法二： 123456789var str = "abcdefg"; function revStr(str) &#123; var arr = str.split(""); arr.reverse(); return arr.join(""); //return str.split("").reverse().join(""); &#125; console.log(revStr(str)); //gfedcba 判断一个JavaScript对象是数组第一，使用 typeof加length属性，因为数组有length属性。第二，使用instanceof可以判断一个变量是不是数组。123456789var arr = ["a", "b", "c"]; function isArr(arr) &#123; if (typeof arr.length == 'number' &amp;&amp; arr instanceof Array) &#123; return "arr is Array" &#125; else &#123; return "arr is not Array" &#125; &#125; console.log(isArr(arr)); //arr is Array 继承和多态继承：继承就是子类的prototype指向父类的一个实例。 JS实现继承的几种方式 借用构造函数实现继承1234567function Parent1()&#123; this.name="parent1";&#125;function Child1()&#123; Parent1.call(this); this.type="child1";&#125; 缺点：Child1无法继承Parent1的原型对象，并没有真正的实现继承（部分继承） 借用原型链实现继承123456789function Parent2() &#123; this.name = "parent2"; this.play = [1, 2, 3];&#125;function Child2() &#123; this.type = "child2"; &#125; Child2.prototype = new Parent2(); 缺点：原型对象的属性是共享的 组合式继承 1234567891011function Parent3() &#123; this.name = "parent3"; this.play = [1, 2, 3]; &#125;function Child3() &#123; Parent3.call(this); this.type = "child3"; &#125; Child3.prototype = Object.create(Parent3.prototype);Child3.prototype.constructor = Child3; 多态：多态就是子类改变了父类的方法，就是多态。 12345678910111213141516function Super() &#123; &#125; Super.prototype.haha = function() &#123; console.log("哈哈") &#125; function Child() &#123; &#125; Child.prototype = new Super(); Child.prototype.haha = function() &#123; console.log("这就是多态") &#125; var c = new Child(); c.haha(); 关于闭包闭包： 能够读取其他函数内部变量的函数。由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 闭包的用途： 一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 学习JavaScript闭包 详解JS闭包 下列JavaScript代码执行后，依次alert的结果是： 1234567(function test( )&#123; var a=b=5; alert(typeof a); //number alert(typeof b); //number&#125;)()alert(typeof a); //undefined 有var 的声明alert(typeof b) //number 没有var声明 描述一下事件冒泡，介绍事件委托（事件代理）的实现方法，以及它的原理和优点。事件从最大的元素开始捕获，往下传输，就是捕获过程。然后开始冒泡。事件委托，给父元素添加点击事件，通过事件冒泡，点击子元素的时候会冒泡到父亲上。节约内存。 如何实现数组的随机排序？方法一： 1234567891011var arr = [1,2,3,4,5,6,7,8,9,10]; function randSort1(arr)&#123; for(var i = 0,len = arr.length;i &lt; len; i++ )&#123; var rand = parseInt(Math.random()*len); var temp = arr[rand]; arr[rand] = arr[i]; arr[i] = temp; &#125; return arr; &#125; console.log(randSort1(arr)); 方法二：（不推荐，因为不能真正地随机打乱数组） 12345var arr = [1,2,3,4,5,6,7,8,9,10];arr.sort(function()&#123; return Math.random() - 0.5;&#125;)console.log(arr); 方法三： 1234567891011var arr = [1,2,3,4,5,6,7,8,9,10];function randSort(arr)&#123; var mixedArray = []; while(arr.length &gt; 0)&#123; var randomIndex = parseInt(Math.random()*arr.length); mixedArray.push(arr[randomIndex]); arr.splice(randomIndex, 1); &#125; return mixedArray; &#125; console.log(randSort(arr)); 当new Foo()时发生了什么 创建了一个新对象 将this指向这个新对象 执行构造函数里面的代码 返回新对象（this） 参考《JS高程》6.6.2]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git远程操作常用命令]]></title>
    <url>%2F2017%2F08%2F04%2FGit%E8%BF%9C%E7%A8%8B%E6%93%8D%E4%BD%9C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[git clone远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到git clone命令。 1$ git clone &lt;版本库的网址&gt; git remote为了便于管理，Git要求每个远程主机都必须指定一个主机名。git remote命令就用于管理主机名。不带选项的时候，git remote命令列出所有远程主机。 12$ git remoteorigin 使用-v选项，可以参看远程主机的网址。 git fetch一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到git fetch命令。 1$ git fetch &lt;远程主机名&gt; 上面命令将某个远程主机的更新，全部取回本地。 git fetch命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。 默认情况下，git fetch取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。 1$ git fetch &lt;远程主机名&gt; &lt;分支名&gt; 比如，取回origin主机的master分支。 1$ git fetch origin master 所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如origin主机的master，就要用origin/master读取。 git branch命令的-r选项，可以用来查看远程分支，-a选项查看所有分支。 123456$ git branch -rorigin/master$ git branch -a* master remotes/origin/master 上面命令表示，本地主机的当前分支是master，远程分支是origin/master。 取回远程主机的更新以后，可以在它的基础上，使用git checkout命令创建一个新的分支。 1$ git checkout -b newBrach origin/master 上面命令表示，在origin/master的基础上，创建一个新分支。 此外，也可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支。 123$ git merge origin/master# 或者$ git rebase origin/master 上面命令表示在当前分支上，合并origin/master。 git pullgit pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。 1$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 比如，取回 origin主机的next分支，与本地的master分支合并，需要写成下面这样。 1$ git pull origin next:master 如果远程分支是与当前分支合并，则冒号后面的部分可以省略。 1$ git pull origin next 上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。 12$ git fetch origin$ git merge origin/next 在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动”追踪”origin/master分支。 Git也允许手动建立追踪关系。 1git branch --set-upstream master origin/next 上面命令指定master分支追踪origin/next分支。 如果当前分支与远程分支存在追踪关系， git pull就可以省略远程分支名。 1$ git pull origin 上面命令表示，本地的当前分支自动与对应的origin主机”追踪分支”（remote-tracking branch）进行合并。如果当前分支只有一个追踪分支，连远程主机名都可以省略。 1$ git pull 上面命令表示，当前分支自动与唯一一个追踪分支进行合并。如果合并需要采用rebase模式，可以使用--rebase选项。 1$ git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 如果远程主机删除了某个分支，默认情况下，git pull不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致git pull不知不觉删除了本地分支。 但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。 1234$ git pull -p# 等同于下面的命令$ git fetch --prune origin $ git fetch -p git pushgit push命令用于将本地分支的更新，推送到远程主机。它的格式与git pull命令相仿。 1$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以git pull是&lt;远程分支&gt;:&lt;本地分支&gt;，而git push是&lt;本地分支&gt;:&lt;远程分支&gt;。 如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。 1$ git push origin master 上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。 如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。 123$ git push origin :master# 等同于$ git push origin --delete master 上面命令表示删除origin主机的master分支。 如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。 1$ git push origin 上面命令表示，将当前分支推送到origin主机的对应分支。 如果当前分支只有一个追踪分支，那么主机名都可以省略。 1$ git push 如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。 1$ git push -u origin master 常用命令添加当前目录的所有文件到暂存区：git add . 提交暂存区到仓库区：git commit -m &#39;message&#39; 创建+切换分支：git checkout -b &lt;name&gt; 删除本地分支：git branch -d &lt;name&gt; 删除远程分支：git push origin --delete &lt;name&gt; 撤销工作区的修改：git checkout -- . 撤销暂存区的修改：git reset HEAD &lt;file&gt; 版本回退（重置暂存区和工作区，与指定commit一致）:git reset --hard commit_id回退到哪个版本：git log ； 回到未来的版本：git reflog]]></content>
      <categories>
        <category>Git学习</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习（五）分支管理]]></title>
    <url>%2F2017%2F08%2F04%2FGit%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[创建与合并分支我们创建dev分支，然后切换到dev分支： 12$ git checkout -b devSwitched to a new branch 'dev' git checkout命令加上-b参数表示创建并切换，相当于以下两条命令： 123$ git branch dev$ git checkout devSwitched to branch 'dev' 然后，用git branch命令查看当前分支： 123$ git branch* dev master git branch命令会列出所有分支，当前分支前面会标一个*号。 然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行内容： 15.创建了一个新分支 然后提交： 1234$ git add readme.txt$ git commit -m "creat a new branch"[dev a118862] creat a new branch 1 file changed, 4 insertions(+), 1 deletion(-) 现在，dev分支的工作完成，我们就可以切换回master分支： 12$ git checkout masterSwitched to branch 'master' 切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变： 12345678$ cat readme.txt1.git学习。初步2.看看git status命令的结果3.重复上一步的内容4.git中的暂存区和工作区 现在，我们把dev分支的工作成果合并到master分支上： 12345$ git merge devUpdating 08a13dd..a118862Fast-forward readme.txt | 5 ++++- 1 file changed, 4 insertions(+), 1 deletion(-) git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。 合并完成后，就可以放心地删除dev分支了： 12$ git branch -d devDeleted branch dev (was a118862). 删除后，查看branch，就只剩下master分支了： 12$ git branch* master 常用分支命令查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; 删除远程分支：git push origin --delete &lt;name&gt; 本地新建分支后提交到远程： git push origin &lt;name&gt; 多人协作当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。 要查看远程库的信息，用git remote： 12$ git remoteorigin 或者，用git remote -v显示更详细的信息： 123$ git remote -vorigin git@github.com:Syzq/gitlearn.git (fetch)origin git@github.com:Syzq/gitlearn.git (push) 上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。 推送分支推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： 1$ git push origin master 如果要推送其他分支，比如dev，就改成： 1$ git push origin dev]]></content>
      <categories>
        <category>Git学习</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F2017%2F08%2F04%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序冒泡排序（Bubble Sort）是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 算法步骤 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 动图演示 什么时候最快当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用啊）。 什么时候最慢当输入的数据是反序时（写一个 for 循环反序输出数据不就行了，干嘛要用你冒泡排序呢。） JavaScript 代码实现12345678910111213function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len ; i++) &#123; for (var j = 0; j &lt; len - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; // 相邻元素两两对比 var temp = arr[j]; arr[j] = arr[j+1]; // 元素交换 arr[j+1] = temp; &#125; &#125; &#125; return arr;&#125;]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F2017%2F08%2F04%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[快速排序快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。 快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。 快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。 算法步骤 从数列中挑出一个元素，称为 “基准”（pivot）; 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序； 递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。 动图演示 JavaScript代码实现我们首先来看看基准（pivot）的原理： 12345678910111213141516function quickSort(arr) &#123; var pivot = arr[0], //选择数组的第一项作为基准 left = [], //所有比基准小的放到基准的左边 right = []; //所有比基准大的放到基准的右边 for (var i = 1; i &lt; arr.length; i++) &#123; //从数组的第二项开始遍历 if (arr[i] &lt; pivot) &#123; left.push(arr[i]) &#125; else &#123; right.push(arr[i]) &#125; &#125; return left.concat(pivot, right); //返回一个按照left、pivot、right的顺序数组 &#125; var shuzu = [54, 21, 212, 1, 789, 52, 12, 50]; var arr = quickSort(shuzu); console.log(arr);// [21, 1, 52, 12, 50, 54, 212, 789, 54] 第一次排序之后，基准“54”左边的都比它小，右边的都比它大。 然后一直递归下去（注意自己调用自己的时候一定要有终点）： 12345678910111213141516171819202122function quickSort(arr) &#123; if (arr.length&lt;=1) &#123; //结束的条件 return arr &#125; var pivot = arr[0], //选择数组的第一项作为基准 left = [], //所有比基准小的放到基准的左边 right = []; //所有比基准大的放到基准的右边 for (var i = 1; i &lt; arr.length; i++) &#123; //从数组的第二项开始遍历 if (arr[i] &lt; pivot) &#123; left.push(arr[i]) &#125; else &#123; right.push(arr[i]) &#125; &#125; return quickSort(left).concat(pivot, quickSort(right)); //返回一个按照left、pivot、right的顺序数组 &#125; var shuzu = [54, 21, 212, 1, 789, 52, 12, 50]; var arr = quickSort(shuzu); console.log(arr); //[1, 12, 21, 50, 52, 54, 212, 789]]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习（四）远程仓库]]></title>
    <url>%2F2017%2F08%2F03%2FGit%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[添加远程库如果你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。 首先，登陆GitHub，然后，在右上角找到Create a new repo按钮，创建一个新的仓库： 在Repository name填入自己的项目名称，其他保持默认设置，点击Create repository按钮，就成功地创建了一个新的Git仓库： 目前，在GitHub上的这个仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。 然后根据GitHub的提示，在本地的仓库下运行命令： 1$ git remote add origin git@github.com:Syzq/gitlearn.git 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 下一步，就可以把本地库的所有内容推送到远程库上： 1$ git push -u origin master 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样。 从现在起，只要本地作了提交，就可以通过命令： 1$ git push origin master 小结要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 关联后，使用命令git push -u origin maste第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改。 Tips：如何删除GitHub上远程仓库的文件夹 首先需要pull远程仓库中的repo 然后在git的shell中执行： git rm -r --cached directoryName 这样就在缓存区删除了这个文件夹 最后提交和push 123git commit -m "remove new gitignore directory"git push origin master]]></content>
      <categories>
        <category>Git学习</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些HTML和CSS面试题]]></title>
    <url>%2F2017%2F08%2F03%2F%E4%B8%80%E4%BA%9BHTML%E5%92%8CCSS%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[如何清除一个标签的子标签的浮动清除浮动的几种方法： 父元素有高度，此时就没有浮动的影响了 父元素如果不愿意设置固定死的高度，而是自动适配，就写overflow:hidden;_zoom:1; 后面的元素父盒子加上clear:both;盒子还是没有高度，margin失效； 两个盒子之前加上一个&lt;div class=&quot;cl&quot;&gt;&lt;/div&gt; .fl{clear:both}，隔墙法，盒子还是没有高度，但是marign有用。 盒子加上::after{content:&quot;&quot;,clear:both;} ，内墙法，这个元素自己最后的子元素是一个标准流元素，所以一下子给这个父盒子撑高了。 描述一下浮动会造成什么影响，如何居中一个浮动元素 【脱标】：浮动的元素脱离标准文档流。【贴边】：左浮动就会紧贴父元素左边，右浮动贴右边。【字围】：文字会环绕这个浮动元素。【收缩】：不区分行内元素和块级元素了，原来的行内元素现在可以设置宽度和高度，原来的块级元素如果不写width现在会自动缩进为内容宽度。 浮动的元素要想居中，必须定位。利用margin-left:50%; left: - 1/2width。 1234567891011&lt;style type="text/css"&gt; div&#123; float: left; width: 500px; height: 100px; background-color: orange; position: relative; margin-left: 50%; left:-250px; &#125;&lt;/style&gt; 原理：margin-left:50%;此时元素的左边线就会到屏幕中线，拉回自己的width一半即可。所以要用相对定位拉动。或者transform:translate(-50%,0); 简单说明绝对定位和浮动的区别和应用。 绝对定位脱离标准文档流，它的参考点是文档的左上角或者右上角。如果有任何父元素有定位属性，此时就依据“子绝父相”规则来设置自己的定位参考元素。在做网页时候非常的灵活方便。制作覆盖效果的时候，会大量使用绝对定位。 浮动脱离标准文档流，通常用于制作并排显示的元素，通常用于大的布局，或者无序列表比如图片的并排。可以使用clear:both;属性让标准流中的其他元素在此之后依次排列。 行内元素和块级元素的区别，行内元素有哪些，块级元素有哪些行内元素不能设置宽度、高度，但是能并排显示，浏览器视行内元素是“文本流元素”。span、a、em、b、u、i。 块级元素能设置宽度、高度，但是不能并排显示。div、h1、ul、p、li、section、header。 CSS引入的方法有哪些？都有什么区别1234外链式&lt;link href="1.css" type="text/css" rel="stylesheet" /&gt;内嵌式&lt;style type="text/css"&gt;&lt;/style&gt;导入式&lt;style&gt;@import url(1.css)&lt;/style&gt;行内式&lt;div style="width:200px;background:red;"&gt;&lt;/div&gt; 外链式方便多个网页同时使用一个样式表。 内嵌式速度快，但是改版麻烦，可以减少HTTP请求。 导入式不好用，因为页面首先加载，然后导入样式表，页面在1s~2s内会有没有样式表的情况，然后突然有了样式。因为link引用CSS时，在页面加载时同步加载；而@import在页面加载完后才开始对对应CSS进行加载。 行内式通常用于开发时候的临时测试，语义不清晰，不能使用。 在书写高效CSS时，需要考虑哪些问题？基本原则是：去掉不必要的样式、合并相同的样式、尽可能缩小样式的大小。多用公共类，让css变得不臃肿。 比如：gulp中有一个插件叫做gulp-csso，可以智能合并相同的样式，比如div p{font-size:10px;color:green;} p{color:green;} 它会智能变为：div p{font-size:10px;} p{color:green;}。 简述一下什么是内容与表现分离HTML就是负责语义，其他什么都不需要管。HTML不要用b、u、i来设置加粗、下划线、倾斜，而是写font-weight:bold; text-decoration:underline; font-style:italic; 用CSS来表示。再比如，logo可以用h1，用背景替换文字来呈递图片。text-indent:-999em; CSS层叠是什么CSS全名叫做层叠式样式表，cascading style sheet，cascading就是层叠的意思。层叠具体有两层含义： 比如一个标签它可以通过多种手段给他添加属性。123456#logo&#123;&#125;.spec&#123;&#125;h1&#123;&#125;body&#123;&#125;&lt;h1 id="logo" class="spec"&gt;&lt;/h1&gt; 此时这个标签就被多个选择器添加属性，如果属性有冲突，CSS有精确的权重计算方法来确定“听谁的”。 一个选择器可以同时作用在多个标签身上，也有一些属性可以继承下去。使标签是由多个选择器共同影响而来。此时CSS就可以写的很精简。 浏览器是如何根据CSS选择器选择对应元素的#表示id，浏览器会寻找拥有id的元素。.表示类名class属性，空格表示后代，&gt; 表示子元素,+ 表示下一个兄弟 ， ~后面所有兄弟。 选择器 权重 ID选择器 100 类选择器 10 标签选择器 1 属性选择器 10 各种伪类选择器 如:link， :visited， :hover， :active， :target， :root， :not等 10 各种伪元素 如::first-letter,::first-line,::after,::before,::selection 1 !important优先级最高，高于上面一切。* 选择器最低，低于一切。 在HTML代码中如何做SEOh标签合理使用，strong标签语义比较强，合理使用。title、&lt;meta name=&quot;description&quot; /&gt;、&lt;meta name=&quot;keywords&quot; /&gt;要合理设置a标签要写title，img要写altdiv要有合理类名，比如.content、.header、.address，便于搜索引擎爬虫检索HTML层次清晰，id不要重复，便于搜索引擎爬虫检索 CSS怎样判断不同分辨率显示不同宽度布局，从而实现自适应宽度 使用百分比布局，用百分比来写宽度、marign、padding 使用em当做单位，写一段JS让html根元素的字号随着浏览器宽度的变化而等比例变化 使用媒体查询，&lt;link href=&quot;1.css&quot; media=&quot;screen and (min-width=900px)&quot; /&gt; 一个页面（HTML）由哪几部分构成？分别是什么？作用是什么由head和body构成。 head里面放置一些配置信息，比如配置title、keyword、description、charset等等信息，不会显示在浏览器中。 body是内容，会显示在浏览器的屏幕中。 为什么利用多个域名来存储网站资源会更有效CDN，表示让用户从离自己最近的下载点下载资源。 突破服务器的带宽限制。 节约主域名的连接数，提升并发。 更加安全，比如静态资源服务器上面，不能运行任何代码的。 谈谈对CSS Sprites技术优缺点的理解。CSS精灵技术，优点就是减少HTTP的请求数量，加快网页渲染速度。便于一整套更换，比如圣诞节了，此时可以改变CSS中的各种按钮、logo变成圣诞风格，一下子全变了。 缺点就是不能随意改变之前已经在精灵上面的图片的位置，做repeat-x、repeat-y精灵难以实现。做先导小符号的时候，精灵要靠边。 用纯CSS创建一个三角形的原理是什么？12345678把上、左、右三条边隐藏掉（颜色设为 transparent） #demo &#123; width: 0; height: 0; border-width: 20px; border-style: solid; border-color: yellow red blue gray; &#125; html5有哪些新特性语义化更好的内容标签（header,nav,footer,aside,article,section） 音频、视频API(audio,video) 画布(Canvas) API 地理(Geolocation) API 拖拽释放(Drag and drop) API 本地离线存储 表单控件，calendar、date、time、email、url、search]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习（三）工作区和暂存区]]></title>
    <url>%2F2017%2F07%2F31%2FGit%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8C%E6%9A%82%E5%AD%98%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[工作区（Working Directory）就是在电脑里能看到的目录。 版本库（Repository）工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 前面我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。 你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 现在，我们再练习一遍，先对readme.txt做个修改，比如加上一行内容： 12345671.git学习。初步2.看看git status命令的结果3.重复上一步的内容4.git中的暂存区和工作区 然后，在工作区新增一个LICENSE文本文件（内容随便写）。 先用git status查看一下状态： 1234567891011121314$ git statusOn branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: readme.txtUntracked files: (use "git add &lt;file&gt;..." to include in what will be committed) LICENSEno changes added to commit (use "git add" and/or "git commit -a") 现在，使用两次命令git add，把readme.txt和LICENSE都添加后，用git status再查看一下： 1234567$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) new file: LICENSE modified: readme.txt 现在，暂存区的状态就变成这样了： 所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。 1234$ git commit -m "修改了readme.txt文件并且新增了LICENSE文件"[master 08a13dd] 修改了readme.txt文件并且新增了LICENSE文件 2 files changed, 4 insertions(+), 1 deletion(-) create mode 100644 LICENSE 一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的： 123$ git statusOn branch masternothing to commit, working tree clean 现在版本库变成了这样，暂存区就没有任何内容了： 暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。]]></content>
      <categories>
        <category>Git学习</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习（二）版本回退]]></title>
    <url>%2F2017%2F07%2F27%2FGit%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80%2F</url>
    <content type="text"><![CDATA[git status我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件，随意更改一下里面的内容，然后运行git status命令查看结果： 123456789$ git statusOn branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: readme.txtno changes added to commit (use "git add" and/or "git commit -a") git status命令可以让我们时刻掌握仓库当前的状态，上面的命令告诉我们，readme.txt被修改过了，但还没有准备提交的修改。 git diff虽然Git告诉我们readme.txt被修改了，但如果能看看具体修改了什么内容，自然是很好的。所以，需要用git diff这个命令看看： 123456789101112$ git diff readme.txtdiff --git a/readme.txt b/readme.txtindex 4c31934..42861d1 100644--- a/readme.txt+++ b/readme.txt@@ -1 +1,3 @@-&lt;U+FEFF&gt;1.git学习。初步\ No newline at end of file+&lt;U+FEFF&gt;1.git学习。初步++2.看看git status命令的结果\ No newline at end of file git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们添加的一条信息“2.看看git status命令的结果”。 知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是git add： 1$ git add readme.txt 同样没有任何输出。在执行第二步git commit之前，我们再运行git status看看当前仓库的状态： 123456$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: readme.txt git status告诉我们，将要被提交的修改包括readme.txt，下一步，就可以放心地提交了： 123$ git commit -m "添加了一条信息"[master 1998486] 添加了一条信息 1 file changed, 3 insertions(+), 1 deletion(-) 提交后，我们再用git status命令看看仓库的当前状态： 123$ git statusOn branch masternothing to commit, working tree clean Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working directory clean）的。 版本回退现在，我们已经学会了修改文件，然后把修改后的文件提交到Git版本库。再练习一次，修改readme.txt文件中的内容然后尝试提交。 1234$ git add readme.txt$ git commit -m "添加了第3条信息"[master 6256515] 添加了第3条信息 1 file changed, 3 insertions(+), 1 deletion(-) 像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。 现在，我们回顾一下readme.txt文件一共有几个版本被提交到Git仓库里了：版本1： 第一次使用add和commit提交文件 11.git学习。初步 版本2： 添加了一条信息 1231.git学习。初步2.看看git status命令的结果 版本3： 添加了第3条信息 123451.git学习。初步2.看看git status命令的结果3.重复上一步的内容 当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看： 123456789101112131415161718$ git logcommit 6256515d442222716889c134209ec551ec4b1cff (HEAD -&gt; master)Author: Beme &lt;syzq2018@qq.com&gt;Date: Mon Jul 31 20:54:06 2017 +0800 添加了第3条信息commit 1998486a571d07dbd64d3a47361bf62a74a8344bAuthor: Beme &lt;syzq2018@qq.com&gt;Date: Mon Jul 31 20:48:51 2017 +0800 添加了一条信息commit 47512f70b3bfb5aaa5395719fbc454356c96f2b4Author: Beme &lt;syzq2018@qq.com&gt;Date: Mon Jul 31 20:33:25 2017 +0800 第一次使用add和commit提交文件 git log命令显示从最近到最远的提交日志，我们可以看到3次提交。 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数： 1234$ git log --pretty=oneline6256515d442222716889c134209ec551ec4b1cff (HEAD -&gt; master) 添加了第3条信息1998486a571d07dbd64d3a47361bf62a74a8344b 添加了一条信息47512f70b3bfb5aaa5395719fbc454356c96f2b4 第一次使用add和commit提交文件 好了，现在我们准备把readme.txt回退到上一个版本，也就是“添加了一条信息”的那个版本，怎么做呢？ 首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交6256515d442222716889c134209ec551ec4b1c...，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 现在，我们要把当前版本“添加了第3条信息”回退到上一个版本“添加了一条信息”，就可以使用git reset命令： 12$ git reset --hard HEAD^HEAD is now at 1998486 添加了一条信息 此时便回到了该版本： 1234$ cat readme.txt1.git学习。初步2.看看git status命令的结果 如果想再次回到最新的版本（“添加了第三条信息”），可以先使用命令git reflog查看命令历史，以便确定要回到未来的哪个版本。 12345$ git reflog1998486 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to HEAD^6256515 HEAD@&#123;1&#125;: commit: 添加了第3条信息1998486 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: 添加了一条信息47512f7 HEAD@&#123;3&#125;: commit (initial): 第一次使用add和commit提交文件 然后再次使用git reset --hard commit_id命令在版本的历史之间穿梭 12$ git reset --hard 6256515HEAD is now at 6256515 添加了第3条信息 小结HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。]]></content>
      <categories>
        <category>Git学习</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习（一）创建版本库]]></title>
    <url>%2F2017%2F07%2F27%2FGit%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Git是什么？Git是目前世界上最先进的分布式版本控制系统（没有之一）。 在Windows上安装Git从https://git-for-windows.github.io下载，然后按默认选项安装即可。 安装完成后，还需要最后一步设置，在命令行输入：12$ git config --global user.name "Your Name"$ git config --global user.email "email@example.com" 创建版本库(git init) 首先，选择一个合适的地方，创建一个空目录： 123$ mkdir learngit //创建文件夹命令$ cd learngit //进入到该文件夹$ pwd //显示当前目录 通过git init命令把这个目录变成Git可以管理的仓库： 1$ git init 然后当前目录下多了一个.git的目录如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。 把文件添加到版本库(git add和git commit)现在我们编写一个readme.txt文件，内容随意。注意一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。 用命令git add告诉Git，把文件添加到仓库：1$ git add readme.txt 执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。 用命令git commit告诉Git，把文件提交到仓库：1$ git commit -m "wrote a readme file" 简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。 为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：123$ git add file1.txt$ git add file2.txt file3.txt$ git commit -m "add 3 files." 小结初始化一个Git仓库，使用git init命令。 添加文件到Git仓库，分两步： 第一步，使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件 第二步，使用命令git commit，完成]]></content>
      <categories>
        <category>Git学习</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人简历]]></title>
    <url>%2F2017%2F07%2F12%2F%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86%2F</url>
    <content type="text"><![CDATA[联系方式 手机：159-3567-7921 Email：`syzq2018@qq.com ` QQ：876603678 个人信息 杨笑盈/男 本科/山西农业大学 工作年限：大四 期望职位：Web前端工程师 技术博客：https://syzq.github.io GitHub: https://github.com/Syzq 职业技能 HTML： 能熟练运用 HTML 进行页面搭建 较好掌握 HTML 标签及其语义化 对 HTML5 新增内容和 API 了然于胸、有Canvas游戏开发经验 CSS： 能较熟练的运用 CSS 属性及 CSS3 的新属性 能较好的还原设计稿 掌握 Bootstrap 框架及其源码实现原理 JavaScript： 有较好的原生 JS 知识功底 注重 JavaScript 性能优化 了解面向对象编程，对 ES6 有粗浅的认知 对JS原型链、闭包、异步和单线程都有一定见解 了解原生Ajax，了解其实现原理 前端框架： 对Vue和React都有所涉猎，可以根据公司不同要求深入掌握某一特定框架 能较好利用Bootstrap、jQuery、Underscore、等提高开发效率。 前端工具：能用 gulp，webpack 配置基本的前端自动化开发环境 数据库相关：MongoDB、Mongoose 版本管理：会使用 Git 进行版本管理 其他： 了解原生 Node、会使用 Express 框架、有独立搭建简单网站经验 会使用基本的 Linux 命令 自我评定 工作方面：能快速上手自己所做工作并融入工作环境，能融洽的处理好和同事的关系。有强烈的上进心和责任心。 职规方面：未来5-10年内将认真投入web前端领域并希望有所建树。 其他：对一切新鲜的事物都很感兴趣，有较强自学能力和学习欲望。 原生JS基础比较扎实，能够在短时间内学习并掌握公司实际项目所需的前端流行框架。 具有较强的抗压能力，有良好的职业道德操守。 有良好的代码书写习惯，喜欢优雅的代码，注重代码的可维护性以及可复用性。 致谢感谢您花时间阅读我的简历，期待能有机会和您共事。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Flex布局：实例篇]]></title>
    <url>%2F2017%2F05%2F07%2FFlex%E5%B8%83%E5%B1%80%EF%BC%9A%E5%AE%9E%E4%BE%8B%E7%AF%87%2F</url>
    <content type="text"><![CDATA[不管是什么布局，Flex往往都可以几行命令搞定。 一、骰子的布局如果不加说明，本节的HTML模板一律如下。 123&lt;div class="box"&gt; &lt;span class="item"&gt;&lt;/span&gt;&lt;/div&gt; 上面代码中，div元素（代表骰子的一个面）是Flex容器，span元素（代表一个点）是Flex项目。如果有多个项目，就要添加多个span元素，以此类推。 单项目首先，只有左上角1个点的情况。Flex布局默认就是首行左对齐，所以一行代码就够了。 123.box &#123; display: flex;&#125; 设置项目的对齐方式，就能实现居中对齐和右对齐。 1234.box &#123; display: flex; justify-content: center;&#125; 1234.box &#123; display: flex; justify-content: flex-end;&#125; 设置交叉轴对齐方式，可以垂直移动主轴。 1234.box &#123; display: flex; align-items: center;&#125; 12345.box &#123; display: flex; justify-content: center; align-items: center;&#125; 12345.box &#123; display: flex; justify-content: center; align-items: flex-end;&#125; 12345.box &#123; display: flex; justify-content: flex-end; align-items: flex-end;&#125; 双项目 1234.box &#123; display: flex; justify-content: space-between;&#125; 12345.box &#123; display: flex; flex-direction: column; justify-content: space-between;&#125; 123456.box &#123; display: flex; flex-direction: column; justify-content: space-between; align-items: center;&#125; 123456.box &#123; display: flex; flex-direction: column; justify-content: space-between; align-items: flex-end;&#125; 1234567.box &#123; display: flex;&#125;.item:nth-child(2) &#123; align-self: center;&#125; 12345678.box &#123; display: flex; justify-content: space-between;&#125;.item:nth-child(2) &#123; align-self: flex-end;&#125; 三项目 1234567891011.box &#123; display: flex;&#125;.item:nth-child(2) &#123; align-self: center;&#125;.item:nth-child(3) &#123; align-self: flex-end;&#125; 四项目 123456.box &#123; display: flex; flex-wrap: wrap; justify-content: flex-end; align-content: space-between;&#125; 12345678910111213141516171819202122&lt;div class="box"&gt; &lt;div class="column"&gt; &lt;span class="item"&gt;&lt;/span&gt; &lt;span class="item"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class="column"&gt; &lt;span class="item"&gt;&lt;/span&gt; &lt;span class="item"&gt;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;.box &#123; display: flex; flex-wrap: wrap; align-content: space-between;&#125;.column &#123; flex-basis: 100%; display: flex; justify-content: space-between;&#125; 六项目 12345.box &#123; display: flex; flex-wrap: wrap; align-content: space-between;&#125; 123456.box &#123; display: flex; flex-direction: column; flex-wrap: wrap; align-content: space-between;&#125; 123456789101112131415161718192021222324252627282930313233&lt;div class="box"&gt; &lt;div class="row"&gt; &lt;span class="item"&gt;&lt;/span&gt; &lt;span class="item"&gt;&lt;/span&gt; &lt;span class="item"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class="row"&gt; &lt;span class="item"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class="row"&gt; &lt;span class="item"&gt;&lt;/span&gt; &lt;span class="item"&gt;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;.box &#123; display: flex; flex-wrap: wrap;&#125;.row&#123; flex-basis: 100%; display:flex;&#125;.row:nth-child(2)&#123; justify-content: center;&#125;.row:nth-child(3)&#123; justify-content: space-between;&#125; 九项目 1234.box &#123; display: flex; flex-wrap: wrap;&#125; 二、网格布局基本网格布局最简单的网格布局，就是平均分布。在容器里面平均分配空间，跟上面的骰子布局很像，但是需要设置项目的自动缩放。 12345678910111213&lt;div class="Grid"&gt; &lt;div class="Grid-cell"&gt;...&lt;/div&gt; &lt;div class="Grid-cell"&gt;...&lt;/div&gt; &lt;div class="Grid-cell"&gt;...&lt;/div&gt;&lt;/div&gt;.Grid &#123; display: flex;&#125;.Grid-cell &#123; flex: 1;&#125; 百分比布局某个网格的宽度为固定的百分比，其余网格平均分配剩余的空间。 123456789101112131415161718192021222324252627282930&lt;div class="Grid"&gt; &lt;div class="Grid-cell u-1of4"&gt;...&lt;/div&gt; &lt;div class="Grid-cell"&gt;...&lt;/div&gt; &lt;div class="Grid-cell u-1of3"&gt;...&lt;/div&gt;&lt;/div&gt;.Grid &#123; display: flex;&#125;.Grid-cell &#123; flex: 1;&#125;.Grid-cell.u-full &#123; flex: 0 0 100%;&#125;.Grid-cell.u-1of2 &#123; flex: 0 0 50%;&#125;.Grid-cell.u-1of3 &#123; flex: 0 0 33.3333%;&#125;.Grid-cell.u-1of4 &#123; flex: 0 0 25%;&#125; 三、圣杯布局圣杯布局（Holy Grail Layout）指的是一种最常见的网站布局。页面从上到下，分成三个部分：头部（header），躯干（body），尾部（footer）。其中躯干又水平分成三栏，从左到右为：导航、主栏、副栏。 123456789101112131415161718192021222324252627282930313233343536373839&lt;body class="HolyGrail"&gt; &lt;header&gt;...&lt;/header&gt; &lt;div class="HolyGrail-body"&gt; &lt;main class="HolyGrail-content"&gt;...&lt;/main&gt; &lt;nav class="HolyGrail-nav"&gt;...&lt;/nav&gt; &lt;aside class="HolyGrail-ads"&gt;...&lt;/aside&gt; &lt;/div&gt; &lt;footer&gt;...&lt;/footer&gt;&lt;/body&gt;.HolyGrail &#123; display: flex; min-height: 100vh; flex-direction: column;&#125;header,footer &#123; flex: 1;&#125;.HolyGrail-body &#123; display: flex; flex: 1;&#125;.HolyGrail-content &#123; flex: 1;&#125;.HolyGrail-nav, .HolyGrail-ads &#123; /* 两个边栏的宽度设为12em */ flex: 0 0 12em;&#125;.HolyGrail-nav &#123; /* 导航放到最左边 */ order: -1;&#125; 如果是小屏幕，躯干的三栏自动变为垂直叠加。 1234567891011@media (max-width: 768px) &#123; .HolyGrail-body &#123; flex-direction: column; flex: 1; &#125; .HolyGrail-nav, .HolyGrail-ads, .HolyGrail-content &#123; flex: auto; &#125;&#125; 四、输入框的布局我们常常需要在输入框的前方添加提示，后方添加按钮。 123456789101112131415&lt;div class="InputAddOn"&gt; &lt;span class="InputAddOn-item"&gt;...&lt;/span&gt; &lt;input class="InputAddOn-field"&gt; &lt;button class="InputAddOn-item"&gt;...&lt;/button&gt;&lt;/div&gt;.InputAddOn &#123; display: flex;&#125;.InputAddOn-field &#123; flex: 1;&#125; 五、悬挂式布局有时，主栏的左侧或右侧，需要添加一个图片栏。 12345678910111213141516171819&lt;div class="Media"&gt; &lt;img class="Media-figure" src="" alt=""&gt; &lt;p class="Media-body"&gt;...&lt;/p&gt;&lt;/div&gt;.Media &#123; display: flex; align-items: flex-start;&#125;.Media-figure &#123; margin-right: 1em;&#125;.Media-body &#123; flex: 1;&#125; 六、固定的底栏有时，页面内容太少，无法占满一屏的高度，底栏就会抬高到页面的中间。这时可以采用Flex布局，让底栏总是出现在页面的底部。 12345678910111213141516&lt;body class="Site"&gt; &lt;header&gt;...&lt;/header&gt; &lt;main class="Site-content"&gt;...&lt;/main&gt; &lt;footer&gt;...&lt;/footer&gt;&lt;/body&gt;.Site &#123; display: flex; min-height: 100vh; flex-direction: column;&#125;.Site-content &#123; flex: 1;&#125; 七、流式布局每行的项目数固定，会自动分行。 12345678910111213141516.parent &#123; width: 200px; height: 150px; background-color: black; display: flex; flex-flow: row wrap; align-content: flex-start;&#125;.child &#123; box-sizing: border-box; background-color: white; flex: 0 0 25%; height: 50px; border: 1px solid red;&#125; 文章来源：http://www.ruanyifeng.com/blog/2015/07/flex-examples.html]]></content>
      <categories>
        <category>HTML(5)和CSS(3)</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flex布局：语法篇]]></title>
    <url>%2F2017%2F05%2F05%2FFlex%E5%B8%83%E5%B1%80%EF%BC%9A%E8%AF%AD%E6%B3%95%E7%AF%87%2F</url>
    <content type="text"><![CDATA[布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。 一、Flex 布局是什么？Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为 Flex 布局。 123.box&#123; display: flex;&#125; 行内元素也可以使用 Flex 布局。 123.box&#123; display: inline-flex;&#125; Webkit 内核的浏览器，必须加上-webkit前缀。 1234.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。 二、基本概念采用Flex布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 三、容器的属性以下6个属性设置在容器上。 1234567891011flex-direction:规定项目排列方向。flex-wrap:规定项目是否拆行或拆列。flex-flow:是flex-direction属性和flex-wrap属性的简写形式justify-content:规定项目在主轴（横轴）方向上的对齐方式。align-items:规定在flex容器的当前行的侧轴（纵轴）方向上的对齐方式。align-content:多根轴线的对齐方式。必须有多行的项目才能生效。 flex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）。 123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; 它可能有4个值。 1234row（默认值）：主轴为水平方向，起点在左端。row-reverse：主轴为水平方向，起点在右端。column：主轴为垂直方向，起点在上沿。column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 它可能取三个值。 （1）nowrap（默认）：不换行。 （2）wrap：换行，第一行在上方。 （3）wrap-reverse：换行，第一行在下方。 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; justify-content属性justify-content属性定义了项目在主轴上的对齐方式。 1234.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly;&#125; 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 1234567891011flex-start（默认值）：左对齐flex-end：右对齐center： 居中space-between：均匀排列每个元素。首个元素放置于起点，末尾元素放置于终点space-around：均匀排列每个元素。每个元素周围分配相同的空间。space-evenly：均匀排列每个元素。每个元素之间的间隔相等。 align-items属性align-items属性定义项目在交叉轴上如何对齐。 123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 123456789flex-start：项目位于容器的开头。flex-end：项目位于容器的结尾。center：项目位于容器的中心。baseline: 项目的第一行文字的基线对齐。stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 1234.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch | space-evenly;&#125; 该属性可能取6个值。 12345678910111213flex-start：与交叉轴的起点对齐。flex-end：与交叉轴的终点对齐。center：与交叉轴的中点对齐。space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。stretch（默认值）：轴线占满整个交叉轴。space-evenly：每一行元素都完全上下等分。 四、项目的属性以下6个属性设置在项目上。 1234567891011order:规定项目的排列顺序。flex-grow:定义项目的放大比例。flex-shrink:定义项目的缩小比例。flex-basis:设置或检索弹性盒伸缩基准值。flex:是flex-grow, flex-shrink 和 flex-basis的简写。align-self:子项单独在侧轴（纵轴）方向上的对齐方式。 order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 123.item &#123; order: &lt;integer&gt;;&#125; flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 123.item &#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]&#125; 该属性有两个快捷值：auto (1 1 auto)和none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。]]></content>
      <categories>
        <category>HTML(5)和CSS(3)</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS3：background属性]]></title>
    <url>%2F2017%2F05%2F03%2FCSS3%EF%BC%9Abackground%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[在css中，共有如下几个background属性： 属性 描述 CSS background 在一个声明中设置所有的背景属性。 1 background-attachment 设置背景图像是否固定或者随着页面的其余部分滚动。 1 background-color 设置元素的背景颜色。 1 background-image 设置元素的背景图像。 1 background-position 设置背景图像的开始位置。 1 background-repeat 设置是否及如何重复背景图像。 1 background-clip 规定背景的绘制区域。 3 background-origin 规定背景图片的定位区域。 3 background-size 规定背景图片的尺寸。 3 从表格中，我们可以看出 background-clip ，background-origin和 background-size是css3中新增的属性。 确定背景的裁剪区域1background-clip: border-box|padding-box|content-box; 注：本属性不支持IE6,7,8 值 描述 border-box 背景被裁剪到边框盒。 padding-box 背景被裁剪到内边距框。 content-box 背景被裁剪到内容框。 一张图看懂三个属性值的区别： 规定背景图像的尺寸1background-size: length|percentage|cover|contain; 值 描述 cover 把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。背景图像的某些部分也许无法显示在背景定位区域中。 contain 把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域。 定位背景图像background-origin属性规定background-position 属性相对于什么位置来定位。1background-origin: padding-box|border-box|content-box; 值 描述 padding-box 背景图像相对于内边距框来定位。 border-box 背景图像相对于边框盒来定位。 content-box 背景图像相对于内容框来定位。]]></content>
      <categories>
        <category>HTML(5)和CSS(3)</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解JS模块化开发]]></title>
    <url>%2F2017%2F04%2F10%2F%E8%AF%A6%E8%A7%A3JS%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[什么是模块化开发前端开发中，起初只要在script标签中嵌入几十上百行代码就能实现一些基本的交互效果，后来js得到重视，应用也广泛起来了，jQuery，Ajax，Node.Js，MVC，MVVM等的助力也使得前端开发得到重视，也使得前端项目越来越复杂，然而，JavaScript却没有为组织代码提供任何明显帮助，甚至没有类的概念，更不用说模块（module）了，那么什么是模块呢？ 一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。模块开发需要遵循一定的规范，否则就都乱套了。 根据AMD规范，我们可以使用define定义模块，使用require调用模块。 目前，通行的js模块规范主要有两种：CommonJS和AMD。 AMD规范AMD 即Asynchronous Module Definition，中文名是“异步模块定义”的意思。它是一个在浏览器端模块化开发的规范，服务器端的规范是CommonJS。 模块将被异步加载，模块加载不影响后面语句的运行。所有依赖某些模块的语句均放置在回调函数中。 AMD是RequireJS 在推广过程中对模块定义的规范化的产出。 define() 函数AMD规范只定义了一个函数 define()，它是全局变量。函数的描述为： 1define(id?, dependencies?, factory); 参数说明： id：指定义中模块的名字，可选；如果没有提供该参数，模块的名字应该默认为模块加载器请求的指定脚本的名字。如果提供了该参数，模块名必须是“顶级”的和绝对的（不允许相对名字）。 依赖dependencies：是一个当前模块依赖的，已被模块定义的模块标识的数组字面量。依赖参数是可选的，如果忽略此参数，它应该默认为[&quot;require&quot;, &quot;exports&quot;, &quot;module&quot;]。然而，如果工厂方法的长度属性小于3，加载器会选择以函数的长度属性指定的参数个数调用工厂方法。 工厂方法factory，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值。 模块名的格式模块名用来唯一标识定义中模块，它们同样在依赖性数组中使用： 123456模块名是用正斜杠分割的有意义单词的字符串单词须为驼峰形式，或者"."，".."模块名不允许文件扩展名的形式，如“.js”模块名可以为 "相对的" 或 "顶级的"。如果首字符为“.”或“..”则为相对的模块名顶级的模块名从根命名空间的概念模块解析相对的模块名从 "require" 书写和调用的模块解析 使用 require 和 exports创建一个名为”alpha“的模块，使用了require，exports，和名为”beta“的模块: 1234567define("alpha", ["require", "exports", "beta"], function (require, exports, beta) &#123; exports.verb = function() &#123; return beta.verb(); //Or: return require("beta").verb(); &#125; &#125;); require API介绍： https://github.com/amdjs/amdjs-api/wiki/require AMD规范中文版：https://github.com/amdjs/amdjs-api/wiki/AMD-(%E4%B8%AD%E6%96%87%E7%89%88) 目前，实现AMD的库有RequireJS 、curl 、Dojo 、Nodules 等。 CommonJS规范CommonJS是服务器端模块的规范，Node.js采用了这个规范。Node.JS首先采用了js模块化的概念。 根据CommonJS规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性。 输出模块变量的最好方法是使用module.exports对象。 123456789var i = 1;var max = 30;module.exports = function () &#123; for (i -= 1; i++ &lt; max; ) &#123; console.log(i); &#125; max *= 1.1;&#125;; 上面代码通过module.exports对象，定义了一个函数，该函数就是模块外部与内部通信的桥梁。 加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的module.exports对象。 CommonJS 规范：http://javascript.ruanyifeng.com/nodejs/module.html RequireJS和SeaJSRequireJS由James Burke创建，他也是AMD规范的创始人。 define方法用于定义模块，RequireJS要求每个模块放在一个单独的文件里。 RequireJS 和 Sea.js 都是模块加载器，倡导模块化开发理念，核心价值是让 JavaScript 的模块化开发变得简单自然。 SeaJS与RequireJS最大的区别: SeaJS对模块的态度是懒执行, 而RequireJS对模块的态度是预执行。 RequireJS的用法：http://www.ruanyifeng.com/blog/2012/11/require_js.html 为什么要用requireJS试想一下，如果一个网页有很多的js文件，那么浏览器在下载该页面的时候会先加载js文件，从而停止了网页的渲染，如果文件越多，浏览器可能失去响应。其次，要保证js文件的依赖性，依赖性最大的模块（文件）要放在最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。 RequireJS就是为了解决这两个问题而诞生的： 12（1）实现js文件的异步加载，避免网页失去响应；（2）管理模块之间的依赖性，便于代码的编写和维护。 AMD和CMDCMD（Common Module Definition） 通用模块定义。该规范明确了模块的基本书写格式和基本交互规则。该规范是在国内发展出来的。AMD是依赖关系前置，CMD是按需加载。 在 CMD规范中，一个模块就是一个文件。代码的书写格式如下： 1define(factory); factory为函数时，表示是模块的构造方法。执行该构造方法，可以得到模块向外提供的接口。factory 方法在执行时，默认会传入三个参数：require、exports 和 module： 12345define(function(require, exports, module) &#123; // 模块代码&#125;); require是可以把其他模块导入进来的一个参数，而export是可以把模块内的一些属性和方法导出的。 CMD规范地址：https://github.com/seajs/seajs/issues/242 12AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。 对于依赖的模块，AMD是提前执行，CMD 是延迟执行。 12AMD:提前执行（异步加载：依赖先执行）+延迟执行CMD:延迟执行（运行到需加载，根据顺序执行） CMD推崇依赖就近，AMD 推崇依赖前置。看如下代码： 1234567891011121314151617// CMDdefine(function(require, exports, module) &#123;var a = require('./a')a.doSomething()// 此处略去 100 行var b = require('./b') // 依赖可以就近书写b.doSomething()// ... &#125;)// AMD 默认推荐的是define(['./a', './b'], function(a, b) &#123; // 依赖必须一开始就写好a.doSomething()// 此处略去 100 行b.doSomething()...&#125;) 另外一个区别是： 12AMD:API根据使用范围有区别，但使用同一个api接口CMD:每个API的职责单一 AMD的优点是：异步并行加载，在AMD的规范下，同时异步加载是不会产生错误的。 CMD的机制则不同，这种加载方式会产生错误，如果能规范化模块内容形式，也可以。 sea.js如何使用？1234567891011121314151617 - 引入sea.js的库 - 如何变成模块？ - define - 如何调用模块？ -exports -sea.js.use - 如何依赖模块？ -require &lt;script type="text/javascript"&gt; define(function (require,exports,module) &#123; //exports : 对外的接口 //requires : 依赖的接口 require('./test.js');//如果地址是一个模块的话，那么require的返回值就是模块中的exports &#125;)&lt;/script&gt; sea.js 开发实例123456789101112131415161718192021222324252627 &lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;title&gt;鼠标拖拽的模块化开发实践&lt;/title&gt;&lt;style type="text/css"&gt;#div1&#123; width:200px; height:200px; background:black; position:absolute; display:none;&#125;#div2&#123; width:30px; height:30px; background:yellow; position:absolute; bottom:0; right:0;&#125;#div3&#123; width:100px; height:100px; background:blue; position:absolute; right:0; top:0;&#125;&lt;/style&gt;&lt;script type="text/javascript" src="./sea.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; //A同事 ：seajs.use('./main.js'); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" value="确定" id="input1" /&gt;&lt;div id="div1"&gt; &lt;div id="div2"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div id="div3"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; A同事123456789101112131415161718//A同事写的main.js:define(function (require,exports,module) &#123; var oInput = document.getElementById('input1'); var oDiv1 = document.getElementById('div1'); var oDiv2 = document.getElementById('div2'); var oDiv3 = document.getElementById('div3'); require('./drag.js').drag(oDiv3); oInput.onclick = function () &#123; oDiv1.style.display = 'block'; require('./scale.js').scale(oDiv1,oDiv2); require.async('./scale.js', function (ex) &#123; ex.scale(oDiv1,oDiv2); &#125;) &#125;&#125;); B同事1234567891011121314151617181920212223242526272829303132333435//B同事写的drag.js:define(function(require,exports,module)&#123; function drag(obj)&#123; var disX = 0; var disY = 0; obj.onmousedown = function(ev)&#123; var ev = ev || window.event; disX = ev.clientX - obj.offsetLeft; disY = ev.clientY - obj.offsetTop; document.onmousemove = function(ev)&#123; var ev = ev || window.event; var L = require('./range.js').range(ev.clientX - disX , document.documentElement.clientWidth - obj.offsetWidth , 0 ); var T = require('./range.js').range(ev.clientY - disY , document.documentElement.clientHeight - obj.offsetHeight , 0 ); obj.style.left = L + 'px'; obj.style.top = T + 'px'; &#125;; document.onmouseup = function()&#123; document.onmousemove = null; document.onmouseup = null; &#125;; return false; &#125;; &#125; exports.drag = drag;//对外提供接口 &#125;); C同事123456789101112131415161718192021222324252627282930313233343536373839//C同事写的scale.js:define(function(require,exports,module)&#123; function scale(obj1,obj2)&#123; var disX = 0; var disY = 0; var disW = 0; var disH = 0; obj2.onmousedown = function(ev)&#123; var ev = ev || window.event; disX = ev.clientX; disY = ev.clientY; disW = obj1.offsetWidth; disH = obj1.offsetHeight; document.onmousemove = function(ev)&#123; var ev = ev || window.event; var W = require('./range.js').range(ev.clientX - disX + disW , 500 , 100); var H = require('./range.js').range(ev.clientY - disY + disH , 500 , 100); obj1.style.width = W + 'px'; obj1.style.height = H + 'px'; &#125;; document.onmouseup = function()&#123; document.onmousemove = null; document.onmouseup = null; &#125;; return false; &#125;; &#125; exports.scale = scale; &#125;); D同事123456789101112131415161718192021// D同事的range.js--限定拖拽范围 define(function(require,exports,module)&#123; function range(iNum,iMax,iMin)&#123; if( iNum &gt; iMax )&#123; return iMax; &#125; else if( iNum &lt; iMin )&#123; return iMin; &#125; else&#123; return iNum; &#125; &#125; exports.range = range; &#125;); requirejs开发实例require.config是用来定义别名的，在paths属性下配置别名。然后通过requirejs(参数一，参数二)；参数一是数组，传入我们需要引用的模块名，第二个参数是个回调函数，回调函数传入一个变量，代替刚才所引入的模块。 main.js文件12345678910//别名配置requirejs.config(&#123; paths: &#123; jquery: 'jquery.min' //可以省略.js &#125;&#125;);//引入模块，用变量$表示jquery模块requirejs(['jquery'], function ($) &#123; $('body').css('background-color','red');&#125;); 引入模块也可以只写require()。requirejs通过define()定义模块，定义的参数上同。在此模块内的方法和变量外部是无法访问的，只有通过return返回才行。 define 模块1234567define(['jquery'], function ($) &#123;//引入jQuery模块 return &#123; add: function(x,y)&#123; return x + y; &#125; &#125;;&#125;); 将该模块命名为math.js保存。 main.js引入模块方法123require(['jquery','math'], function ($,math) &#123; console.log(math.add(10,100));//110&#125;); 没有依赖如果定义的模块不依赖其他模块，则可以： 1234567define(function () &#123; return &#123; name: "trigkit4", age: "21" &#125;&#125;); AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的。]]></content>
      <categories>
        <category>JavaScript学习总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[详解JS中的this关键字]]></title>
    <url>%2F2017%2F03%2F25%2FJS%E5%92%8CjQuery%E9%87%8C%E7%9A%84this%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[this 出现的场景在《javaScript语言精粹》这本书中，把this 出现的场景分为四类： 有对象就指向调用对象 没调用对象就指向全局对象 用new构造就指向新对象 通过 apply 或 call 或 bind 来改变 this 的所指。 函数调用模式中，this为window；方法调用模式中，this为方法所属的对象；构造器调用模式中，this为创建的新对象。 JS中的this我们要记住：this永远指向函数运行时所在的对象！而不是函数被创建时所在的对象。 this对象是在运行时基于函数的执行环境绑定的，在全局环境中，this等于window。 先来看个例子： 12345678910111213var name = "Zhang San"; var person = &#123; name: "Li Si", student: &#123; name: "Wang Wu", getname: function() &#123; return this.name; &#125; &#125; &#125;; console.log(person.student.getname()); //Wang Wu var test = person.student.getname; console.log(test()); //Zhang San 当getname被分配到test变量时，上下文指的是全局对象（window）。这是因为test是被隐式设置为全局对象的属性。出于这个原因，该函数返回window的name，所以在这里 this 指的是window， 所以返回的是第一个name。 说明this关键字通常在对象的构造函数中使用，用来引用对象。 关键字this：总是指向调用该方法的对象，如： 12345var iCar = new Object();iCar.color = "red";iCar.showColor = function()&#123; alert(this.color);//输出"red"&#125;; 关键字this用在对象的showColor()方法中，在此环境，this等于iCar 使用this是因为在实例化对象时，总是不能确定开发者会使用什么样的变量名。使用this，即可在任意多个地方重用同一个函数。考虑下面的例子： 12345678910111213function showColor()&#123; alert(this.color);&#125;var oCar1 = new Object;oCar1.color = "red";oCar1.showColor = showColor;var oCar2 = new Object;oCar2.color = "blue";oCar2.showColor = showColor;oCar1.showColor();//输出"red"oCar2.showColor();//输出"blue" 这段代码中，首先用this定义函数showColor()，然后创建两个对象oCar1和oCar2，一个对象属性被设置为&quot;red&quot;,另一个为&quot;blue&quot;；两个对象都被赋予了属性showColor，指向原始的showColor()函数，调用每个showColor的方法，oCar1输出red，oCar2输出blue。 引用对象属性时，必须使用this关键字。 作为构造函数调用所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象。 12345function Test() &#123; this.x=10; &#125; var obj=new Test(); console.log(obj.x);//10 全局环境中的this再看下面一个this出现在全局环境中的例子： 1234567var name='全局'; function getname() &#123; var name='局部'; return this.name ; &#125; console.log(getname());//全局 函数getName()所处的对象是window对象，因此this也一定在window对象中。此时的this指向window对象，所以getName()返回的this.name其实是window.name，因此console.log出全局。 结论： 无论this身处何处，一定要找到函数运行时（或者说在何处被调用 了）的位置。 通过不同的调用语法，改变相同函数内部this的值： 123456789var foo = &#123; test:function()&#123; alert(this); &#125; &#125; foo.test();//object,因为test方法在调用时属于foo对象 var baz = foo.test; baz();//window,因为baz()被调用时属于global对象 局部环境中的this看下面一个this出现在局部环境中的例子 12345678var name='全局'; var jubu=&#123; name:'局部', getname:function () &#123; return this.name &#125; &#125;; alert(jubu.getname());//局部 其中this身处的函数getName不是在全局环境中，而是处在jubu环境中。无论this身处何处，一定要找到函数运行时的位置。此时函数getName运行时的位置： 1alert(jubu.getName()); 显然，函数getName所在的对象是jubu，因此this的安身之处定然在jubu，即指向jubu对象，则getName返回的this.name其实是jubu.name，因此alert出来的是局部！ 作用域链中的this12345678910function scoping () &#123; console.log(this); return function () &#123; console.log(this); &#125;;&#125;scoping()();//window//window 因为scoping函数属于window对象，自然作用域链中的函数也属于window对象。 对象中的this可以在对象的任何方法中使用this来访问该对象的属性。这与用new得到的实例是不一样的。 12345678var obj = &#123; foo: "test", bar: function () &#123; console.log(this.foo); &#125;&#125;;obj.bar(); // "test" apply 和 call 调用以及 bind 绑定apply和 call 调用以及 bind 绑定都是指向绑定的对象，1234567891011121314var bar = &#123; value: 'huang', ages: 10&#125;;function foo() &#123; console.log(this);&#125;console.log(foo()); //window,函数没有所属对象：指向全局对象console.log(foo.apply(bar)); //即bar.foo()，this指向了bar,所以能读取该对象的所有属性console.log(foo.call(bar)); //ages: 10 value: "huang" __proto__: Objectvar newFoo = foo.bind(bar);console.log(newFoo()); //Object jQuery中的this$()生成的是什么呢？实际上$()=jquery()，那么也就是说返回的是一个jquery的对象。$(this)是jquery对象，能调用jquery的方法，例如click(), keyup()。 123456 $(function () &#123; $('button').click(function () &#123; alert(this);//this 表示原生的DOM //$(this)表示当前对象，这里指的是button &#125;) &#125;); 在许多情况下JQuery的this都指向HTML元素节点。 结论： this，表示当前的上下文对象是一个html DOM对象，可以调用html对象所拥有的属性，方法。 $(this),代表的上下文对象是一个jquery的上下文对象，可以调用jquery的方法和属性值。]]></content>
      <categories>
        <category>JavaScript学习总结</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown常用语法]]></title>
    <url>%2F2017%2F02%2F14%2FMarkDown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在线编辑器：http://dillinger.io 标题一1# 标题一 标题二1## 标题二 ··· 标题六1###### 标题六 -或*代表无序列表 无序列表1 无序列表2 123- 无序列表1* 无序列表2 有序列表 有序列表1 有序列表2 121. 有序列表12. 有序列表2 引用 引用一段话 12&gt; 引用一段话 这是一段文字这是一段斜体文字这是一段文字这是一段文字 这是一段文字这是一段粗体文字这是一段文字这是一段文字 这是一段文字这是一段粗斜体文字这是一段文字这是一段文字 12345这是一段文字*这是一段斜体文字*这是一段文字这是一段文字这是一段文字**这是一段粗体文字**这是一段文字这是一段文字这是一段文字***这是一段粗斜体文字***这是一段文字这是一段文字 表格 Col1111111 Col222222 Col33333 111 222 333 aaa bbb ccc 1234|Col1111111|Col222222|Col33333||---|:---:|---:||111|222|333||aaa|bbb|ccc| 代码单行代码：用包裹 代码 一段代码：用``` ``` 包裹 1234567891011html&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 链接和图片插入一个链接 1[插入一个链接](https://syzq.github.io) 插入图片： 1![百度Logo](https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo/bd_logo1_31bdc765.png)]]></content>
      <categories>
        <category>零碎笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jQuery入门]]></title>
    <url>%2F2016%2F09%2F14%2FjQuery%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[一、选择网页元素jQuery的基本设计和主要用法，就是”选择某个网页元素，然后对其进行某种操作”。这是它区别于其他函数库的根本特点。 使用jQuery的第一步，往往就是将一个选择表达式，放进构造函数jQuery()（简写为$），然后得到被选中的元素。 选择表达式可以是CSS选择器： 1234567$(document) //选择整个文档对象$('#myId') //选择ID为myId的网页元素$('div.myClass') // 选择class为myClass的div元素$('input[name=first]') // 选择name属性等于first的input元素 也可以是jQuery特有的表达式： 1234567891011$('a:first') //选择网页中第一个a元素$('tr:odd') //选择表格的奇数行$('#myForm :input') // 选择表单中的input元素$('div:visible') //选择可见的div元素$('div:gt(2)') // 选择所有的div元素，除了前三个$('div:animated') // 选择当前处于动画状态的div元素 二、改变结果集如果选中多个元素，jQuery提供过滤器，可以缩小结果集： 123456789$('div').has('p'); //选择包含p元素的div元素 $('div').not('.myClass'); //选择class不等于myClass的div元素 $('div').filter('.myClass'); //选择class等于myClass的div元素 $('div').first(); //选择第1个div元素 $('div').eq(5); //选择第6个div元素 有时候，我们需要从结果集出发，移动到附近的相关元素，jQuery也提供了在DOM树上的移动方法： 123456789$('div').next('p'); //选择div元素后面的第一个p元素$('div').parent(); //选择div元素的父元素$('div').closest('form'); //选择离div最近的那个form父元素$('div').children(); //选择div的所有子元素 $('div').siblings(); //选择div的同级元素 三、链式操作最终选中网页元素以后，可以对它进行一系列操作，并且所有操作可以连接在一起，以链条的形式写出来，比如： 1$('div').find('h3').eq(2).html('Hello'); 分解开来，就是下面这样： 1234567$('div') //找到div元素.find('h3') //选择其中的h3元素 .eq(2) //选择第3个h3元素 .html('Hello'); //将它的内容改为Hello 四、元素的操作：取值和赋值操作网页元素，最常见的需求是取得它们的值，或者对它们进行赋值。 jQuery使用同一个函数，来完成取值（getter）和赋值（setter）。到底是取值还是赋值，由函数的参数决定。 123$('h1').html(); //html()没有参数，表示取出h1的值 $('h1').html('Hello'); //html()有参数Hello，表示对h1进行赋值 常见的取值和赋值函数如下： 1234567891011.html() 取出或设置html内容 .text() 取出或设置text内容 .attr() 取出或设置某个属性的值 .width() 取出或设置某个元素的宽度 .height() 取出或设置某个元素的高度 .val() 取出某个表单元素的值 需要注意的是，如果结果集包含多个元素，那么赋值的时候，将对其中所有的元素赋值；取值的时候，则是只取出第一个元素的值（.text()例外，它取出所有元素的text内容）。 五、元素的操作：移动jQuery提供两组方法，来操作元素在网页中的位置移动。一组方法是直接移动该元素，另一组方法是移动其他元素，使得目标元素达到我们想要的位置。 假定我们选中了一个div元素，需要把它移动到p元素后面。 第一种方法是使用.insertAfter()，把div元素移动p元素后面： 1 $('div').insertAfter($('p')); 第二种方法是使用.after()，把p元素加到div元素前面： 1 $('p').after($('div')); 表面上看，这两种方法的效果是一样的，唯一的不同似乎只是操作视角的不同。但是实际上，它们有一个重大差别，那就是返回的元素不一样。第一种方法返回div元素，第二种方法返回p元素。你可以根据需要，选择到底使用哪一种方法。 使用这种模式的操作方法，一共有四对： 1234567.insertAfter()和.after()：在现存元素的外部，从后面插入元素 .insertBefore()和.before()：在现存元素的外部，从前面插入元素 .appendTo()和.append()：在现存元素的内部，从后面插入元素 .prependTo()和.prepend()：在现存元素的内部，从前面插入元素 六、元素的操作：复制、删除和创建除了元素的位置移动之外，jQuery还提供其他几种操作元素的重要方法。 复制元素使用.clone()。 删除元素使用.remove()和.detach()。两者的区别在于，前者不保留被删除元素的事件，后者保留，有利于重新插入文档时使用。 清空元素内容（但是不删除该元素）使用.empty()。 创建新元素的方法非常简单，只要把新元素直接传入jQuery的构造函数就行了： 12345$('&lt;p&gt;Hello&lt;/p&gt;'); $('&lt;li class="new"&gt;new list item&lt;/li&gt;'); $('ul').append('&lt;li&gt;list item&lt;/li&gt;'); 七、工具方法除了对选中的元素进行操作以外，还提供一些与元素无关的工具方法（utility）。不必选中元素，就可以直接使用这些方法。 工具方法即可给jquery使用，也可以给原生的js使用 常用的工具方法有以下几种： 1234567891011121314151617181920212223$.trim() 去除字符串两端的空格。 $.each() 遍历一个数组或对象。 $.inArray() 返回一个值在数组中的索引位置。如果该值不在数组中，则返回-1。 $.grep() 返回数组中符合某种标准的元素。 $.extend() 将多个对象，合并到第一个对象。 $.makeArray() 将对象转化为数组。 $.type() 判断对象的类别（函数对象、日期对象、数组对象、正则对象等等）。 $.isArray() 判断某个参数是否为数组。 $.isEmptyObject() 判断某个对象是否为空（不含有任何属性）。 $.isFunction() 判断某个参数是否为函数。 $.isPlainObject() 判断某个参数是否为用"&#123;&#125;"或"new Object"建立的对象。 $.support() 判断浏览器是否支持某个特性。 八、事件操作jQuery可以对网页元素绑定事件。根据不同的事件，运行相应的函数。 123 $('p').click(function()&#123; alert('Hello'); &#125;); 目前，jQuery主要支持以下事件： 1234567891011121314151617181920212223242526.blur() 表单元素失去焦点。.change() 表单元素的值发生变化.click() 鼠标单击.dblclick() 鼠标双击.focus() 表单元素获得焦点.focusin() 子元素获得焦点.focusout() 子元素失去焦点.hover() 同时为mouseenter和mouseleave事件指定处理函数.keydown() 按下键盘（长时间按键，只返回一个事件）.keypress() 按下键盘（长时间按键，将返回多个事件）.keyup() 松开键盘.load() 元素加载完毕.mousedown() 按下鼠标.mouseenter() 鼠标进入（进入子元素不触发）.mouseleave() 鼠标离开（离开子元素不触发）.mousemove() 鼠标在元素内部移动.mouseout() 鼠标离开（离开子元素也触发）.mouseover() 鼠标进入（进入子元素也触发）.mouseup() 松开鼠标.ready() DOM加载完成.resize() 浏览器窗口的大小发生改变.scroll() 滚动条的位置发生变化.select() 用户选中文本框中的内容.submit() 用户递交表单.toggle() 根据鼠标点击的次数，依次运行多个函数.unload() 用户离开页面 以上这些事件在jQuery内部，都是.bind()的便捷方式。使用.bind()可以更灵活地控制事件，比如为多个事件绑定同一个函数： 123456 $('input').bind( 'click change', //同时绑定click和change事件 function() &#123; alert('Hello'); &#125; ); 有时，你只想让事件运行一次，这时可以使用.one()方法。 123 $("p").one("click", function() &#123; alert("Hello"); //只运行一次，以后的点击不会运行 &#125;); .unbind()用来解除事件绑定。 1 $('p').unbind('click'); 所有的事件处理函数，都可以接受一个事件对象（event object）作为参数，比如下面例子中的e： 123 $("p").click(function(e) &#123; alert(e.type); // "click" &#125;); 这个事件对象有一些很有用的属性和方法： 123456789101112131415event.pageX 事件发生时，鼠标距离网页左上角的水平距离event.pageY 事件发生时，鼠标距离网页左上角的垂直距离event.type 事件的类型（比如click）event.which 按下了哪一个键event.data 在事件对象上绑定数据，然后传入事件处理函数event.target 事件针对的网页元素event.preventDefault()阻止事件的默认行为（比如点击链接，会自动打开新页面）event.stopPropagation() 停止事件向上层元素冒泡 在事件处理函数中，可以用this关键字，返回事件针对的DOM元素： 1234567 $('a').click(function(e) &#123; if ($(this).attr('href').match('evil')) &#123; //如果确认为有害链接 e.preventDefault(); //阻止打开 $(this).addClass('evil'); //加上表示有害的class &#125; &#125;); 有两种方法，可以自动触发一个事件。一种是直接使用事件函数，另一种是使用.trigger()或.triggerHandler()。 123$('a').click();$('a').trigger('click'); 九、特殊效果最后，jQuery允许对象呈现某些特殊效果。 1 $('h1').show(); //展现一个h1标题 常用的特殊效果如下： 1234567891011121314151617.fadeIn() 淡入.fadeOut() 淡出.fadeTo() 调整透明度.hide() 隐藏元素.show() 显示元素.slideDown() 向下展开.slideUp() 向上卷起.slideToggle() 依次展开或卷起某个元素.toggle() 依次展示或隐藏某个元素 除了.show()和.hide()，所有其他特效的默认执行时间都是400ms（毫秒），但是你可以改变这个设置。 123$('h1').fadeIn(300); // 300毫秒内淡入 $('h1').fadeOut('slow'); // 缓慢地淡出 在特效结束后，可以指定执行某个函数。 1 $('p').fadeOut(300, function() &#123; $(this).remove(); &#125;); 更复杂的特效，可以用.animate()自定义。 12345678 $('div').animate( &#123; left : "+=50", //不断右移 opacity : 0.25 //指定透明度 &#125;, 300, // 持续时间 function() &#123; alert('done!'); &#125; //回调函数 ); .stop()和.delay()用来停止或延缓特效的执行。$.fx.off如果设置为true，则关闭所有网页特效。 本文主要来源于：http://www.ruanyifeng.com/blog/2011/07/jquery_fundamentals.html]]></content>
      <categories>
        <category>前端常用库</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习总结（九）事件详解]]></title>
    <url>%2F2016%2F06%2F25%2FJavaScript%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B9%9D%EF%BC%89%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[事件处理程序在DOM中定义了一些事件， 而响应某个事件的函数就叫事件处理程序（或事件侦听器）。事件处理程序的名字一般以on开头，例如：onclick等。 事件冒泡与捕获事件流指的是页面中接收事件的顺序，IE，火狐和chrome浏览器都是事件冒泡，所谓是事件冒泡指的是事件最开始由最具体的元素接收，然后逐级向上传播到不具体的节点。而事件捕获则正好相反，事件捕获是由Netscape提出的，事件冒泡和捕获具体如下图所示： ) 虽然事件捕获是Netscape唯一支持的事件流模型，但目前IE9，火狐和谷歌也都支持这种事件流模型。 事件冒泡的好处因为事件具有冒泡机制，因此我们可以利用冒泡的原理，把事件加到父级上，触发执行效果。这样做的好处当然就是提高性能了。 1234567891011121314151617181920212223242526272829&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; window.onload = function () &#123; var aUl = document.getElementsById("bubble"); var aLi = aUl.getElementsByTagName("li"); for(var i = 0;i&lt;aLi.length;i++)&#123; aLi[i].onmouseover = function () &#123; this.style.backgroundColor = "blue"; &#125;; ali[i].onmouseout = function () &#123; this.style.backgroundColor = ""; &#125; &#125; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;ul id = "bubble"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt; 这样我们就可以做到li上面添加鼠标事件。但是如果说我们可能有很多个li用for循环的话就比较影响性能。下面我们可以用事件委托的方式来实现这样的效果。html不变: 1234567891011121314151617181920212223242526&lt;script type="text/javascript"&gt; window.onload = function () &#123; var aUl = document.getElementsById("bubble"); var aLi = aUl.getElementsByTagName("li"); //不管在哪个事件中，只要你操作的那个元素就是事件源。 // ie：window.event.srcElement // 标准下:event.target aUl.onmouseover = function (ev) &#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == "li")&#123; target.style.background = "blue"; &#125; &#125;; aUl.onmouseout = function (ev) &#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() = "li")&#123; target.style.background = ""; &#125; &#125; &#125;;&lt;/script&gt; 那么，如何阻止事件的冒泡呢，看下面一个例子： 1234567891011121314151617181920&lt;div onclick="showMsg(this,event)" id="outSide" style="width:100px; height:100px; background:#000; padding:50px"&gt;&lt;div onclick="showMsg(this,event)" id="inSide" style="width:100px; height:100px; background:#CCC"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;//阻止事件冒泡后，你点击灰色盒子，整个过程只弹一次对话框了（注意与默认情况对比）function showMsg(obj,e)&#123; alert(obj.id); stopBubble(e)&#125;//阻止事件冒泡函数function stopBubble(e)&#123; if (e &amp;&amp; e.stopPropagation) e.stopPropagation() else window.event.cancelBubble=true&#125;&lt;/script&gt; DOM 0级事件处理程序通过js指定事件处理程序通常是将回调函数赋给这个事件处理程序的属性。每个元素都有自己的事件处理程序属性（属性小写，例如：onclick） 123btn.onclick = function()&#123; console.log('hello');&#125;; 使用DOM 0级指定的事件处理程序被认为是元素的方法。因此，this指向当前元素： 123456var btn = document.getElementById('myDiv');//DOM上触发的事件会产生一个事件对象eventbtn.onclick = function (event) &#123; alert(this.id);//myDiv &#125;; DOM 2级事件处理程序DOM 2级定义了两个方法，用于指定和删除事件处理程序的操作：addEventListener()和removeEventListener()，他们都接受三个参数： 1231.事件名，事件名不用加on，比如click、mouseover2.作为事件处理程序的函数。3.布尔值（true表示捕获阶段调用事件处理程序，false表示冒泡阶段） IE中的事件处理程序IE9之前的IE浏览器不支持addEventListener()和removeEventListener（）。与其他浏览器不同的是，IE使用的是attachEvent()和detachEvent()方法来为DOM添加事件处理程序，由于IE8及更早版本只支持事件冒泡，所以他们只接受两个参数： 121、事件处理程序名称（前面要加on）2、事件处理程序函数 值得注意的是，使用attachEvent()方法的情况下，事件处理程序会在全局作用域中运行，所以，此时this等于window。 事件对象在触发DOM上的某个事件时，会产生一个事件对象event，这个对象包含着所有与事件相关的信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。event对象会被作为第一个参数传递给事件监听的回调函数。我们可以通过这个event对象来获取到大量当前事件相关的信息： 12345678type (String) — 事件的名称target (node) — 事件起源的DOM节点currentTarget?(node) — 当前回调函数被触发的DOM节点（后面会做比较详细的介绍）bubbles (boolean) — 指明这个事件是否是一个冒泡事件（接下来会做解释）preventDefault(function) — 这个方法将阻止浏览器中用户代理对当前事件的相关默认行为被触发。比如阻止&lt;a&gt;元素的click事件加载一个新的页面cancelable (boolean) — 这个变量指明这个事件的默认行为是否可以通过调用event.preventDefault来阻止。stopPropagation (function) — 取消事件的进一步捕获或冒泡，bubbles为true使用这个方法eventPhase：返回一个数字，表示事件目前所处的阶段，0为事件开始从DOM表层向目标元素传播，1为捕获阶段，2为事件到达目标元素，3为冒泡阶段。 此外，事件对象还可能拥有很多其他的属性，但是他们都是针对特定的event的。比如，鼠标事件包含clientX和clientY属性来表明鼠标在当前视窗的位置。另外，stopPropagation()方法用于立即停止事件在DOM中的传播，即取消进一步的事件冒泡或捕获。 12345678910var btn = document.getElementById('myDiv');btn.onclick = function (event) &#123; alert("clicked"); event.stopPropagation();&#125;;//避免触发在document.body上的事件处理程序document.body.onclick = function (event) &#123; alert("Body clicked"); &#125;; 只有在事件处理程序执行期间，event对象才会存在，一旦事件处理程序执行完毕，event对象就会自动销毁。 IE中的事件对象在DOM 0级中添加事件处理程序时，event对象是作为window对象的一个属性存在的： 12345var btn = document.getElementById('myDiv');btn.onclick = function (event) &#123; var event = window.event; alert(event.type);//click&#125;; IE 的event对象同样也包含与创建它的事件相关的属性和方法。 1234cancleBubble 布尔 默认值时false，但可以被设置成true来取消事件冒泡，与dom中的 stopPropagation()方法相同。returnValue 布尔 默认值是true，当设置成false时用以取消事件的默认行为 与dom中的preventDefault（）相同。srcElement 元素 事件的目标，与dom中的target属性相同。type 字符串 被触发的事件类型。 click事件当用户点击以后，event对象会包含以下属性。 123pageX，pageY：点击位置相对于html元素的坐标，单位为像素。clientX，clientY：点击位置相对于视口（viewport）的坐标，单位为像素。screenX，screenY：点击位置相对于设备显示屏幕的坐标，单位为设备硬件的像素 clientX，clientYclientX和clientY，他们的值表示事件发生时鼠标指针在视口中的水平和垂直坐标（不包含滚动条区域）。 偏移量 123456789通过以下4个属性可以取得元素的偏移量。（1）offsetHeight：元素在垂直方向上占用的空间大小，以像素计。包括元素的高度、（可见的）水平滚动条的高度、上边框高度和下边框高度。（2）offsetWidth：元素在水平方向上占用的空间大小，以像素计。包括元素的宽度、（可见的）垂直滚动条的宽度、左边框宽度和右边框宽度。（3）offsetLeft：元素的左外边框至包含元素的左内边框之间的像素距离。（4）offsetTop：元素的上外边框至包含元素的上内边框之间的像素距离。 pageX，pageY这两个属性表示鼠标光标在页面中的位置，在页面没有滚动的情况下，pageX，pageY的值与clientX，clientY的值相等。 滚动大小 滚动大小，指的是包含滚动内容的元素的大小。 123456789以下是4个与滚动大小相关的属性。（1）scrollHeight：在没有滚动条的情况下，元素内容的总高度。（2）scrollWidth：在没有滚动条的情况下，元素内容的总宽度。（3）scrollLeft：被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置。（4）scrollTop：被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置。 焦点事件焦点事件会在页面元素获得或失去焦点时触发，有以下4个焦点事件： 12341. blur：元素失去焦点时触发，该事件不冒泡2. focus：元素获得焦点时触发。不冒泡3. focusin：元素获得焦点时触发，冒泡4. focusout：元素失去焦点时触发，冒泡 鼠标事件DOM 3级定义了9个鼠标事件： 12345678910111213141516171819click：当用户点击鼠标主键通常是指鼠标左键或按回车键时触发。dbclick：用户双击鼠标时触发mousedown：当用户按下鼠标任意一个键都会触发，这个事件是不能够通过键盘触发的。mousemove：当鼠标在某元素周围移动时重复触发，该事件不能通过键盘事件触发。mouseout：当鼠标离开元素时触发，这个事件不能通过键盘触发。mouseover：当鼠标进入元素时触发，这个事件不能够通过键盘触发。 mouseenter：类似“mouseover”，但不冒泡，而且当光标移到后代元素上不会触发。 mouseleave：类似“mouseout”，但不冒泡。在元素上方是不触发。mouseup：当用户释放鼠标按键时触发，不能够通过键盘触发。传递给鼠标事件处理程序的事件对象有clientX和clientY属性，它们指定了鼠标指针相对于包含窗口的坐标。加入窗口的滚动偏移量，就可以把鼠标位置转换成文档坐标。 页面上的所有元素都支持鼠标事件。除了mouseenter和mouseleave外，所有的事件都冒泡，并且他们的默认行为是可以被取消掉的。但取消鼠标事件的默认行为可能会影响到其他事件，因为有些鼠标事件是相互依赖的。 mouseenter和mouseover的不同：http://www.w3school.com.cn/tiy/t.asp?f=jquery_event_mouseenter_mouseover 拖拉事件（1）drag事件 12drag事件在源对象被拖拉过程中触发。 （2）dragstart，dragend事件 1dragstart事件在用户开始用鼠标拖拉某个对象时触发，dragend事件在结束拖拉时触发。 （3）dragenter，dragleave事件 12dragenter事件在源对象拖拉进目标对象后，在目标对象上触发。dragleave事件在源对象离开目标对象后，在目标对象上触发。 （4）dragover事件 1dragover事件在源对象拖拉过另一个对象上方时，在后者上触发。 （5）drop事件 1当源对象被拖拉到目标对象上方，用户松开鼠标时，在目标对象上触发drop事件。]]></content>
      <categories>
        <category>JavaScript学习总结</category>
      </categories>
      <tags>
        <tag>JS事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习总结（八）正则表达式]]></title>
    <url>%2F2016%2F06%2F20%2FJavaScript%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E5%85%AB%EF%BC%89%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[基本概念正则表达式是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为“元字符”）。模式描述在搜索文本时要匹配的一个或多个字符串。 首先推荐几个正则表达式编辑器 Debuggex ：https://www.debuggex.com/ Regexper：http://www.regexper.com/ JavaScript RegExp 对象参考手册：http://w3school.com.cn/jsref/jsref_obj_regexp.asp 正则表达式是一种查找以及字符串替换操作。正则表达式在文本编辑器中广泛使用，比如正则表达式被用于： 1234检查文本中是否含有指定的特征词找出文中匹配特征词的位置从文本中提取信息，比如：字符串的子串修改文本 说明：正则表达式通常用于两种任务：1.验证，2.搜索/替换。用于验证时，通常需要在前后分别加上^和$，以匹配整个待验证字符串；搜索/替换时是否加上此限定则根据搜索的要求而定，此外，也有可能要在前后加上\b而不是^和$。此表所列的常用正则表达式，除个别外均未在前后加上任何限定，请根据需要，自行处理。 优先权顺序在构造正则表达式之后，就可以象数学表达式一样来求值，也就是说，可以从左至右并按照一个优先权顺序来求值。 下表从最高优先级到最低优先级列出各种正则表达式操作符的优先权顺序： 操作符 描述 \ 转义符 (), (?:), (?=), [] 圆括号和方括号 *, +, ?, {n}, {n,}, {n,m} 限定符 ^, $, \anymetacharacter 位置和顺序 字符类匹配 字符 描述 […] 查找方括号之间的任何字符。 [^…] 查找任何不在方括号之间的字符。 . 查找单个字符，除了换行和行结束符。 \w 查找单词字符。 \W 查找非单词字符。 \d 查找数字。 \D 查找非数字字符。 \s 查找空白字符。 \S 查找非空白字符。 \b 匹配单词边界。 \B 匹配非单词边界。 重复字符匹配 字 符 匹配 {n,m} 匹配前一项至少n次，但不能超过m次 {n,} 匹配前一项n次或更多次 {n} 匹配前一项n次 ? 匹配前一项0次或者1次，也就是说前一项是可选的，等价于{0，1} + 匹配前一项1次或多次，等价于{1，} * 匹配前一项0次或多次，等价于{0，} 字符类:锚字符 匹配 元字符/元符号 匹配 $ 匹配字符串的结尾，在多行检索中，匹配一行的结尾 ^ 匹配字符串的开头，在多行检索中，匹配一行的开头 \A 只有匹配字符串开始处 \b 匹配单词边界,词在 []内时无效 \B 匹配非单词边界 \G 匹配当前搜索的开始位置 \Z 匹配字符串结束处或行尾 \z 只匹配字符串结束处 字符类:记录字符 匹配 元字符/元符号 匹配情况 (string) 用于反向引用的分组 \1 或$1 匹配第一个分组中的内容 \2 或$2 匹配第二个分组中的内容 \3 或$3 匹配第三个分组中的内容 量词 量词 描述 n+ 匹配任何包含至少一个 n 的字符串。 n* 匹配任何包含零个或多个 n 的字符串。 n? 匹配任何包含零个或一个 n 的字符串。 n{X} 匹配包含 X 个 n 的序列的字符串。 n{X,Y} 匹配包含 X 至 Y 个 n 的序列的字符串。 n{X,} 匹配包含至少 X 个 n 的序列的字符串。 n$ 匹配任何结尾为 n 的字符串。 ^n 匹配任何开头为 n 的字符串。 ?=n 匹配任何其后紧接指定字符串 n 的字符串。 ?!n 匹配任何其后没有紧接指定字符串 n 的字符串。 正则表达式修饰符 字符 含义 i 执行不区分大小写的匹配 g 执行一个全局匹配，即找到所有匹配而非一次匹配 m 多行匹配模式，^匹配一行的开头和字符串开头，$匹配行的结束和字符串的结尾 RegExp的方法RegExp 对象有 3 个方法：test()、exec()以及 compile()。 方法 描述 test() 检索字符串中指定的值。返回 true 或 false。 exec() 检索字符串中指定的值。返回找到的值，并确定其位置。 compile() 编译正则表达式。既可以改变检索模式，也可以添加或删除第二个参数。 String 对象中的正则表达式方法 方法 描述 search() 检索与正则表达式相匹配的值。 match() 找到一个或多个正则表达式的匹配。 replace() 替换与正则表达式匹配的子串。 split() 把字符串分割为字符串数组。 match 方法12345/*使用 match 方法获取获取匹配数组*/ var pattern = /box/ig;//全局搜索 var str = 'This is a Box!,That is a Box too'; alert(str.match(pattern)); //匹配到两个 Box,Boxconsole.log(str.match(pattern).length);//获取数组的长度 search方法1234/*使用 search 来查找匹配数据*/var pattern = /box/ig;var str = 'This is a Box!,That is a Box too'; console.log(str.search(pattern));//10 查找到返回位置,否则返回 -1 replace方法1234/*使用 replace 替换匹配到的数据*/var pattern = /box/ig;var str = 'This is a Box!,That is a Box too'; console.log(str.replace(pattern, 'Cat'));//This is a Cat!,That is a Cat too split方法12345/*使用 split 拆分成字符串数组*/ var pattern = / /ig; var str = 'This is a Box!,That is a Box too'; console.log(str.split(pattern));//将空格拆开分组成数组 exec方法123456789101112131415/* 统计子字符串出现的所有位置*/function count(str)&#123; var b,r=/def/g; while(b = r.exec(str))&#123; console.log(b); &#125;&#125;count('abcdefabcdefabcdefabcdef');输出：[ 'def', index: 3, input: 'abcdefabcdefabcdefabcdef' ][ 'def', index: 9, input: 'abcdefabcdefabcdefabcdef' ][ 'def', index: 15, input: 'abcdefabcdefabcdefabcdef' ][ 'def', index: 21, input: 'abcdefabcdefabcdefabcdef' ] 建立正则表达式直接量语法 1/表达式/修饰符 创建 RegExp 对象的语法： 1new RegExp(字符串, 可选修饰符); 例子： 1234//用户名正则，4到16位（字母，数字，下划线，减号）var uPattern = /^[a-zA-Z0-9_-]&#123;4,16&#125;$/;//输出 trueconsole.log(uPattern.test("iFat3")); 正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。 正则表达式选择一个正则表达式选择包含1个或多个正则表达式序列。这些序列被竖线（|）字符分隔。如果这些序列中的任何一项符合匹配条件，那么这个选择就被匹配。他会按顺序依次匹配 1"into".match(/in | int/); 以上将在into中匹配in。但他不会匹配int,因为in已经匹配成功了。 正则表达式转义1\ / [ ] () &#123; &#125; ? + * | . ^ $ 如果希望按字面去匹配上面的字符，那么必须用一个\前缀来进行转义。\前缀不能使字母或数字字面化。 12345678910\f ： 换页符\n ： 换行符\r ： 回车符\t ： 制表(tab)符\^ 匹配 ^ 符号本身\$ 匹配 $ 符号本身\. 匹配小数点（.）本身 实例123String.prototype.trim = function () &#123; return this.replace(/(^\s*)|(\s*$)/g,'');&#125;; ^表示字符串必须以后面的规则开头，而(^\s*) 表示的就是以0个空格或者多个空格开头，后面的(\s*$)的意思就是, 以0个空格或者多个空格结尾。 匹配特定字符串12345^[A-Za-z]+$ //匹配由26个英文字母组成的字符串^[A-Z]+$ //匹配由26个英文字母的大写组成的字符串^[a-z]+$ //匹配由26个英文字母的小写组成的字符串^[A-Za-z0-9]+$ //匹配由数字和26个英文字母组成的字符串^\w+$ //匹配由数字、26个英文字母或者下划线组成的字符串 思维导图: 附：常用正则表达式用户名正则1234//用户名正则，4到16位（字母，数字，下划线，减号）var uPattern = /^[a-zA-Z0-9_-]&#123;4,16&#125;$/;//输出 trueconsole.log(uPattern.test("iFat3")); 密码强度正则1234//密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符var pPattern = /^.*(?=.&#123;6,&#125;)(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&amp;*? ]).*$/;//输出 trueconsole.log("=="+pPattern.test("iFat3#")); 整数正则123456789101112//正整数正则var posPattern = /^\d+$/;//负整数正则var negPattern = /^-\d+$/;//整数正则var intPattern = /^-?\d+$/;//输出 trueconsole.log(posPattern.test("42"));//输出 trueconsole.log(negPattern.test("-42"));//输出 trueconsole.log(intPattern.test("-42")); 数字正则可以是整数也可以是浮点数123456789//正数正则var posPattern = /^\d*\.?\d+$/;//负数正则var negPattern = /^-\d*\.?\d+$/;//数字正则var numPattern = /^-?\d*\.?\d+$/;console.log(posPattern.test("42.2"));console.log(negPattern.test("-42.2"));console.log(numPattern.test("-42.2")); Email正则1234567//Email正则var ePattern =/^\w+@[a-z0-9]+.[a-z]&#123;2,4&#125;$/ //var ePattern = /^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]&#123;2,4&#125;)$/;//输出 trueconsole.log(ePattern.test("65974040@qq.com")); 手机号正则1234//手机号正则var mPattern = /^[1][3][0-9]&#123;9&#125;$/;//输出 trueconsole.log(mPattern.test("13900000000")); 身份证号正则1234//身份证号（18位）正则var cP = /^[1-9]\d&#123;5&#125;(18|19|([23]\d))\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d&#123;3&#125;[0-9Xx]$/;//输出 trueconsole.log(cP.test("11010519880605371X")); URL正则1234//URL正则var urlP= /^((https?|ftp|file):\/\/)?([\da-z\.-]+)\.([a-z\.]&#123;2,6&#125;)([\/\w \.-]*)*\/?$/;//输出 trueconsole.log(urlP.test("http://42du.cn")); 日期正则1234567891011121314//日期正则，简单判定,未做月份及日期的判定var dP1 = /^\d&#123;4&#125;(\-)\d&#123;1,2&#125;\1\d&#123;1,2&#125;$/;//输出 trueconsole.log(dP1.test("2017-05-11"));//输出 trueconsole.log(dP1.test("2017-15-11"));//日期正则，复杂判定var dP2 = /^(?:(?!0000)[0-9]&#123;4&#125;-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]&#123;2&#125;(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$/;//输出 trueconsole.log(dP2.test("2017-02-11"));//输出 falseconsole.log(dP2.test("2017-15-11"));//输出 falseconsole.log(dP2.test("2017-02-29")); IPv4地址正则1234//ipv4地址正则var ipP = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;//输出 trueconsole.log(ipP.test("115.28.47.26")); 包含中文正则1234//包含中文正则var cnPattern = /[\u4E00-\u9FA5]/;//输出 trueconsole.log(cnPattern.test("42度"));]]></content>
      <categories>
        <category>JavaScript学习总结</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习总结（七）Ajax和Http状态字]]></title>
    <url>%2F2016%2F06%2F17%2FJavaScript%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%83%EF%BC%89Ajax%E5%92%8CHttp%E7%8A%B6%E6%80%81%E5%AD%97%2F</url>
    <content type="text"><![CDATA[Ajax及其工作原理AJAX 是一种与服务器交换数据无需刷新网页的技术，最早由Google公司在谷歌地图里使用，并迅速风靡。 AJAX是不能跨域的，如需跨域，可以使用document.domain=&#39;a.com&#39;；或者使用服务器代理，代理XMLHttpRequest文件 AJAX是基于现有的Internet标准，并且联合使用它们： 1234XMLHttpRequest 对象 (异步的与服务器交换数据)JavaScript/DOM (信息显示/交互)CSS (给数据定义样式)XML (作为转换数据的格式) 创建 XMLHttpRequest 对象所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建XMLHttpRequest对象。 创建Ajax对象：12345//IE6以上var oAjax = new XMLHttpRequest();//IE6var oAjax =new ActiveXObject("Microsoft.XMLHTTP") 连接服务器1oAjax.open(方法,url,是否异步) 我们知道，Ajax即“Asynchronous Javascript And XML”（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术。所以，Ajax天生就是工作在异步模式的（异步为true，同步false） 同步是指：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式。 异步是指：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。 （简单点说：同步就是只能一件一件事的来做，而异步就是可以多件事同时进行） 发送请求send()12345678910111213141516171819202122&lt;script type="text/javascript"&gt;function getDoc()&#123; var xmlhttp; if(window.xmlhttpRequest)&#123; xmlhttp=new XMLHttpRequest(); &#125; else&#123; xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");//for IE6 &#125; xmlhttp.onreadystatechange = function()&#123; if(xmlhttp.readyState==4&amp;&amp;xmlhttp.status==200)&#123; document.getElementById("myId").innerHTML=xmlhttp.responseText; &#125; &#125; xmlhttp.open("GET", index.php,true); xmlhttp.send();&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button type="button" onclick="getDoc()"&gt;请求数据&lt;/button&gt;&lt;/body&gt; GET 还是 POST？ 与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。 然而，在以下情况中，请使用 POST 请求： 123无法使用缓存文件（更新服务器上的文件或数据库）向服务器发送大量数据（POST 没有数据量限制）发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 GET请求通常用于检索数据库的某一个条目，比如news.php?id=4 POST请求通常用于提交表单 接收返回信息12345oAjax.onreadystatechange = function()&#123; //当请求状态改变时要调用的事件处理器 alert(oAjax.readystate); &#125; 只要readyState属性的值发生变化时，便会触发一次readyStatechange事件。可以利用这个事件来检测每次状态变化后readyState的值。通常，我们只对readyState值为4的阶段感兴趣，因为这时所有数据都已经就绪，不过，必须在调用open()之前指定onreadystatechange事件处理程序才能确保跨浏览器兼容性。 完整的Ajax例子： 12345678910111213141516171819//第一步创建一个xhr对象，使用new关键字来调用一个内置构造函数var xhr=new XMLHttpRequest();//第二步指定接收回来的内容，怎么处理。监听xhr对象的onreadystatechange事件，这个事件在xhr对象//的“就绪状态”改变的时候触发。一般我们只关心就绪状态为4的时候的事情。xhr.onreadystatechange=function()&#123; if(xhr.readyState==4)&#123; if(xhr.status&gt;=200&amp;&amp;xhr.status&lt;300||xhr.status==304)&#123; //接收完文件要做的事情，让h1的内容变为读取的东西 biaoti.innerHTML=xhr.responseText;//xhr.responseText就表示接收回来的文本。是一个string类型 &#125; &#125;&#125;//第三步创建一个请求，第一个参数是请求的类型get或者post，第二个参数就是请求的路径，第三个参数是否使用异步机制xhr.open("get","a.txt",true);//第四步发送请求，圆括号里面是请求头的内容，get请求没有报文头写null xhr.send(null); XHR对象XMLHttpRequest这个对象的属性有： 12345678onreadystatechange 每次状态改变所触发事件的事件处理程序。responseText 从服务器进程返回数据的字符串形式。responseXML 从服务器进程返回的DOM兼容的文档数据对象。status 从服务器返回的数字代码，比如常见的404（未找到）和200（已就绪）status Text 伴随状态码的字符串信息 当XHR对象把一个HTTP请求发送到服务器的过程中会经历几个状态，直到请求被处理，然后才接收一个回应。readyState就是XHR请求的状态属性，它本身有5个属性值： 123450（未初始化）还没有调用open()方法1（载入）已调用send()方法，正在发送请求2(载入完成)send()方法完成，已收到全部响应内容3(解析)正在解析响应内容4（完成）响应内容解析完成，可以再客户端使用了 http状态码1字头：消息。这一类型的状态码，代表请求已被接受，需要继续处理。 2字头：成功。这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。 3字头：重定向。这类状态码代表需要客户端采取进一步的操作才能完成请求。 4字头：客户端错误。这类状态码代表了客户端看起来可能发生错误，妨碍了服务器的处理。 5字头：服务器错误。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生 http状态码详解 w3cschool HTTP 状态消息：http://www.w3school.com.cn/tags/html_ref_httpmessages.asp status和statusText statusText是响应返回的文本信息，仅当readyState值为3或4的时候才能使用。当readyState为其它值时视图存取statusText属性将引发异常。 jQuery中的Ajax.load()方法是局部方法，因为他需要一个包含元素的jQuery对象作为前缀，而$.get()和$.post()是全局方法，无需指定某个元素，对于用途而言，.load()适合做静态文件的异步获取，而对于需要传递参数到服务器页面的，$.get()和$.post()更加合适。 GET和POST传入的data是一个键值对 对象，不同的是GET传入的data是通过地址栏传输的，而POST是通过表单提交的， 1234567$(function () &#123; $("input").click(function () &#123; $.get('test.php?url=baidu.com', function (response,status,xhr) &#123; $('#box').html(response); &#125;) &#125;)&#125;); POST提交不能使用url传参。post提交可以使用字符串形式的键值对形式传参，自动转换为http消息实体传参 1234567$(function () &#123; $("input").click(function () &#123; $.post('test.php','url=baidu.com', function (response,status,xhr) &#123; $('#box').html(response); &#125;) &#125;)&#125;); 1234567891011//post提交可以使用对象键值对$(function () &#123; $("input").click(function () &#123; $.post('test.php',&#123; url:'baidu.com'//post提交可以使用对象键值对 &#125;, function (response,status,xhr) &#123; $('#box').html(response); &#125;) &#125;)&#125;); $.get()方法有四个参数，前面三个参数和.load()一样，多了一个第四参数type，即服务器返回的内容格式，包括xml,json,script,html,text等，第一个参数为必选参数，后面三个为可选参数 $.ajax()是所有Ajax方法中最底层的方法，所有其他方法都是基于$.ajax()方法的封装，这个方法只有一个参数，传递一个各个功能键值对的对象。 1234567891011121314$(function () &#123; $("input").click(function () &#123; $.ajax(&#123; type : "POST", url: 'test.php', data:&#123; url: 'baidu.com' &#125;, success : function(response,status,xhr)&#123; $('#box').html(response); &#125; &#125;) &#125;)&#125;); 表单序列化Ajax用的最多的地方莫过于表单操作，而传统的表单操作是通过submit提交将数据传输到服务器，如果使用Ajax异步处理的话，我们需要将每个表单元素获取才能提交，这样工作效率就大大降低 12345678910111213141516171819202122232425&lt;body&gt;&lt;form action=""&gt; 用户名: &lt;input type="text" name="user" /&gt; 邮件: &lt;input type="text" name="email" /&gt; &lt;input type="button" value="提交"/&gt;&lt;/form&gt;&lt;div id="box"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; $(function () &#123; $("form input[type=button]").click(function () &#123; $.ajax(&#123; type: 'POST', url: 'test.php', data: &#123; user: $('form input[name=user]').val(), email: $("form input[name=email]").val(), &#125;, success: function(response)&#123; $("#box").html(response); &#125; &#125;) &#125;) &#125;);&lt;/script&gt;&lt;/body&gt; 表单元素特别多的情况下应采用表单序列化，即data:$(“form”).serialize();//得到的是字符串键值对，并且对url进行编码 serialize()方法不但可以序列化表单内的元素，还可以直接获取单选框，复选框和下拉列表框等内容 123456789101112131415161718&lt;body&gt;&lt;form action=""&gt; 用户名: &lt;input type="text" name="user" /&gt; 邮件: &lt;input type="text" name="email" /&gt; &lt;input type="button" value="提交"/&gt; &lt;input type="radio" name="sex" value="男"/&gt;男 &lt;input type="radio" name="sex" value="女"/&gt;女 &lt;input type="button" value="submit"/&gt;&lt;/form&gt;&lt;div id="box"&gt;&lt;/div&gt;&lt;script&gt; $(function () &#123; $("form input[name=sex]").click(function () &#123; $('#box').html(decodeURIComponent($(this).serialize())); &#125;) &#125;)&lt;/script&gt;&lt;/body&gt; 传统Ajax问题传统的ajax有如下的问题： 12345678910111、可以无刷新改变页面内容，但无法改变页面URL2、为了更好的可访问性，内容发生改变后，通常改变URL的hash3、hash的方式不能很好的处理浏览器的前进、后退等问题4、进而浏览器引入了onhashchange的接口，不支持的浏览器只能定时去判断hash是否改变5、但这种方式对搜索引擎很不友好6、twitter和google约定了使用#!xxx（即hash第一个字符为!），搜索引擎进行支持。]]></content>
      <categories>
        <category>JavaScript学习总结</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习总结（六）数据类型和JSON格式]]></title>
    <url>%2F2016%2F06%2F16%2FJavaScript%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E5%85%AD%EF%BC%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8CJSON%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是JSONJSON：JavaScript 对象表示法（JavaScript Object Notation）。 JSON的形式是用大括号{}包围起来的项目列表，每一个项目间用逗号,分隔，而项目就是用冒号:分隔的属性名和属性值。这是典型的字典表示形式，也再次表明javascript里的对象就是字典结构。不管多么复杂的对象，都可以用一句JSON代码来创建并赋值。在JSON中，名称/值对 包括字段名称（在双引号中），后面写一个冒号，然后是值。 JSON 结构JSON有两种结构 json简单说就是javascript中的对象和数组，所以这两种结构就是对象和数组两种结构，通过这两种结构可以表示各种复杂的结构。 1、对象：对象在js中表示为“{}”括起来的内容，数据结构为 {key：value,key：value,…}的键值对的结构，在面向对象的语言中，key为对象的属性，value为对应的属性值，所以很容易理解，取值方法为 对象.key 获取属性值，这个属性值的类型可以是 数字、字符串、数组、对象几种。 2、数组：数组在js中是中括号“[]”括起来的内容，数据结构为 [“java”,”javascript”,”vb”,…]，取值方式和所有语言中一样，使用索引获取，字段值的类型可以是 数字、字符串、数组、对象几种。经过对象、数组2种结构就可以组合成复杂的数据结构了。 JSON 语法规则JSON 语法是 JavaScript 对象表示法语法的子集。 1234数据在名称/值对中数据由逗号分隔花括号保存对象方括号保存数组 JSON 值可以是： 123456数字（整数或浮点数）字符串（在双引号中）逻辑值（true 或 false）数组（在方括号中）对象（在花括号中）null 除以上6种外，再无其他，没有像js一样的undefined、NAN 12345671） 并列的数据之间用逗号（", "）分隔。2） 映射用冒号（": "）表示。3） 并列数据的集合（数组）用方括号("[]")表示。4） 映射的集合（对象）用大括号（"&#123;&#125;"）表示。 对象是一套无序的名/值对，一个对象以左边分支开始，以右边分支结束 一个值可以是用双引号括起来的字符串，或者是一个数值，一个true or false ，一个数组或者一个对象 JSON与对象字面量在编程语言中,字面量是一种表示值的记法。JSON规定键-值对中的键必须用双引号！ 引号。例如： 1&#123;"first name" : "Mike"&#125;; 在JSON字符串中，不能使用函数或者正则表达式字面量 数据类型：从结构上看，所有的数据（data）最终都可以分解成三种类型： 12345第一种类型是标量（scalar），也就是一个单独的字符串（string）或数字（numbers），比如"北京"这个单独的词。第二种类型是序列（sequence），也就是若干个相关的数据按照一定顺序并列在一起，又叫做数组（array）或列表（List），比如"北京，上海"。第三种类型是映射（mapping），也就是一个名/值对（Name/value），即数据有一个名称，还有一个与之相对应的值，这又称作散列（hash）或字典（dictionary），比如"首都：北京"。 在编程语言中，只要有了数组（array）和对象（object）就能够储存一切数据了。 数组和对象的另一个区别是，数组的数据没有&quot;名称&quot;（name），对象的数据有&quot;名称&quot;（name）。 JavaScript中有5种简单数据类型（也称为基本数据类型）：Undefined、Null、Boolean、Number和String。还有1种复杂数据类型——Object，Object本质上是由一组无序的名值对组成的。 对一个值使用typeof操作符可能返回下列某个字符串： 1234567891011"undefined"——如果这个值未定义；"boolean"——如果这个值是布尔值；"string"——如果这个值是字符串；"number"——如果这个值是数值；"object"——如果这个值是对象或null；"function"——如果这个值是函数； Undefined类型：12 Undefined类型只有一个值，在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined Null类型Null类型是第二个只有一个值的数据类型，这个特殊的值是null。从逻辑角度来看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null时会返回”object”的原因，例如：12var car = null;alert(typeof car); // "object" Number类型这种类型用来表示整数和浮点数值，还有一种特殊的数值，即NaN（非数值 Not a Number）。这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。 String类型 String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。字符串可以由单引号(‘)或双引号(“)表示。 数值、布尔值、对象和字符串值都有toString()方法。但null和undefined值没有这个方法。 多数情况下，调用toString()方法不必传递参数。但是，在调用数值的toString()方法时，可以传递一个参数：输出数值的基数。 123456var num = 10;alert(num.toString()); //"10"alert(num.toString(2)); //"1010"alert(num.toString(8)); //"12"alert(num.toString(10)); //"10"alert(num.toString(16)); //"a" 在不知道要转换的值是不是null或undefined的情况下，还可以使用转型函数String()，这个函数能够将任何类型的值转换为字符串。String()函数遵循下列转换规则： 如果值有toString()方法，则调用该方法（没有参数）并返回相应的结果 如果值null，则返回”null” 如果值是undefined，则返回”undefined” Object类型对象其实就是一组数据和功能的集合。对象可以通过执行new操作符后跟要创建的对象类型的名称来创建。而创建Object类型的实例并为其添加属性和（或）方法，就可以创建自定义对象。 1var o = new Object(); typeof 操作符typeof返回的数据类型有：1undefined、string、number、Boolean、object、function 123456789101112131415161718192021&lt;script type="text/javascript"&gt; var s = "Beme"; var b =true; var c = 21; var u; var n = null; var o = &#123;&#125;; var arr=[]; var fn=function()&#123;&#125;; var obj = new Object;//最好写出new object()形式 alert(typeof s);//string alert(typeof b);//boolean alert(typeof c);//number alert(typeof u);//undefined alert(typeof n);//object alert(typeof o);//object alert(typeof arr);//object alert(typeof fn);//function alert(typeof obj);//object&lt;/script&gt; Json在线解析Json在线解析：http://json.tongxiehui.net/]]></content>
      <categories>
        <category>JavaScript学习总结</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript继承方式详解]]></title>
    <url>%2F2016%2F06%2F15%2FJavaScript%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1. JS继承的概念JS里常用的如下两种继承方式： 一、原型链继承（对象间的继承）； 二、类式继承（构造函数间的继承）。 由于 JS 不像 JAVA 那样是真正面向对象的语言，JS 是基于对象的，它没有类的概念。所以，要想实现继承，可以用 JS 的原型prototype机制或者用apply和call方法去实现。 在面向对象的语言中，我们使用类来创建一个自定义对象。然而 JS 中所有事物都是对象，那么用什么办法来创建自定义对象呢？这就需要用到 JS 的原型： 我们可以简单的把prototype看做是一个模版，新创建的自定义对象都是这个模版（prototype）的一个拷贝 （实际上不是拷贝而是链接，只不过这种链接是不可见，新实例化的对象内部有一个看不见的__Proto__指针，指向原型对象）。 2. 原型式继承与类式继承原型式继承是借助已有的对象创建新的对象，将子类的原型指向父类，就相当于加入了父类这条原型链。 类式继承是在子类型构造函数的内部调用超类型的构造函数。严格的类式继承并不是很常见，一般都是组合着用： 1234567function Super()&#123; this.colors=["red","blue"];&#125; function Sub()&#123; Super.call(this);&#125; 3. 原型链继承为了让子类继承父类的属性（也包括方法），首先需要定义一个构造函数。然后，将父类的新实例赋值给构造函数的原型。代码如下： 12345678910111213141516171819202122&lt;script&gt; function Parent()&#123; this.name = 'mike'; &#125; function Child()&#123; this.age = 12; &#125; Child.prototype = new Parent();//Child继承Parent，通过原型，形成链条 var test = new Child(); alert(test.age); alert(test.name);//得到被继承的属性 //继续原型链继承 function Brother()&#123; //brother构造 this.weight = 60; &#125; Brother.prototype = new Child();//继续原型链继承 var brother = new Brother(); alert(brother.name);//继承了Parent和Child,弹出mike alert(brother.age);//弹出12&lt;/script&gt; 以上原型链继承还缺少一环，那就是Object，所有的构造函数都继承自Object。而继承Object是自动完成的，并不需要我们自己手动继承，那么他们的从属关系是怎样的呢？ 3.1 确定原型和实例的关系可以通过两种方式来确定原型和实例之间的关系。操作符instanceof和isPrototypeof()方法： 1234alert(brother instanceof Object)//truealert(test instanceof Brother);//false,test 是brother的超类alert(brother instanceof Child);//truealert(brother instanceof Parent);//true 只要是原型链中出现过的原型，都可以说是该原型链派生的实例的原型，因此，isPrototypeof()方法也会返回true。 在 JS 中，被继承的函数称为超类型（父类，基类也行），继承的函数称为子类型（子类，派生类）。使用原型继承主要由两个问题：一是字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。 伪类解决引用共享和超类型无法传参的问题，我们可以采用“借用构造函数”技术。 3.2 借用构造函数（类式继承）123456789101112131415&lt;script&gt; function Parent(age)&#123; this.name = ['mike','jack','smith']; this.age = age; &#125; function Child(age)&#123; Parent.call(this,age); &#125; var test = new Child(21); alert(test.age);//21 alert(test.name);//mike,jack,smith test.name.push('bill'); alert(test.name);//mike,jack,smith,bill&lt;/script&gt; 借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起，所以我们需要原型链+借用构造函数的模式，这种模式称为组合继承。 3.3 组合继承（重要）123456789101112131415&lt;script&gt; function Parent(age)&#123; this.name = ['mike','jack','smith']; this.age = age; &#125; Parent.prototype.run = function () &#123; return this.name + ' are both' + this.age; &#125;; function Child(age)&#123; Parent.call(this,age);//对象冒充，给超类型传参 &#125; Child.prototype = new Parent();//原型链继承 var test = new Child(21);//写new Parent(21)也行 alert(test.run());//mike,jack,smith are both21&lt;/script&gt; 组合式继承是比较常用的一种继承方法，其背后的思路是 使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。 call()的用法：调用一个对象的一个方法，以另一个对象替换当前对象。 1call([thisObj[,arg1[, arg2[, [,.argN]]]]]) 4. 原型式继承这种继承借助原型并基于已有的对象创建新对象，同时还不用创建自定义类型的方式称为原型式继承。 123456789101112131415161718192021222324&lt;script&gt; function obj(o)&#123; function F()&#123;&#125; F.prototype = o; return new F(); &#125; var box = &#123; name : 'trigkit4', arr : ['brother','sister','baba'] &#125;; var b1 = obj(box); alert(b1.name);//trigkit4 b1.name = 'mike'; alert(b1.name);//mike alert(b1.arr);//brother,sister,baba b1.arr.push('parents'); alert(b1.arr);//brother,sister,baba,parents var b2 = obj(box); alert(b2.name);//trigkit4 alert(b2.arr);//brother,sister,baba,parents&lt;/script&gt; 原型式继承首先在obj()函数内部创建一个临时性的构造函数 ，然后将传入的对象作为这个构造函数的原型，最后返回这个临时类型的一个新实例。 4.1 寄生式继承这种继承方式是把原型式+工厂模式结合起来，目的是为了封装创建的过程。 123456789&lt;script&gt; function create(o)&#123; var f= obj(o); f.run = function () &#123; return this.arr;//同样，会共享引用 &#125;; return f; &#125;&lt;/script&gt; 4.2 组合式继承的小问题组合式继承是js最常用的继承模式，但组合继承的超类型在使用过程中会被调用两次；一次是创建子类型的时候，另一次是在子类型构造函数的内部 1234567891011121314151617&lt;script&gt; function Parent(name)&#123; this.name = name; this.arr = ['哥哥','妹妹','父母']; &#125; Parent.prototype.run = function () &#123; return this.name; &#125;; function Child(name,age)&#123; Parent.call(this,age);//第二次调用 this.age = age; &#125; Child.prototype = new Parent();//第一次调用&lt;/script&gt; 以上代码是之前的组合继承，那么寄生组合继承，解决了两次调用的问题。 4.3 寄生组合式继承1234567891011121314151617181920212223242526272829303132333435&lt;script&gt; function obj(o)&#123; function F()&#123;&#125; F.prototype = o; return new F(); &#125; function create(parent,test)&#123; var f = obj(parent.prototype);//创建对象 f.constructor = test;//增强对象 &#125; function Parent(name)&#123; this.name = name; this.arr = ['brother','sister','parents']; &#125; Parent.prototype.run = function () &#123; return this.name; &#125;; function Child(name,age)&#123; Parent.call(this,name); this.age =age; &#125; inheritPrototype(Parent,Child);//通过这里实现继承 var test = new Child('trigkit4',21); test.arr.push('nephew'); alert(test.arr);// alert(test.run());//只共享了方法 var test2 = new Child('jack',22); alert(test2.arr);//引用问题解决&lt;/script&gt; 5. call和apply全局函数apply和call可以用来改变函数中this的指向，如下： 12345678910111213141516// 定义一个全局函数 function foo() &#123; console.log(this.fruit); &#125; // 定义一个全局变量 var fruit = "apple"; // 自定义一个对象 var pack = &#123; fruit: "orange" &#125;; // 等价于window.foo(); foo.apply(window); // "apple",此时this等于window // 此时foo中的this === pack foo.apply(pack); // "orange"]]></content>
      <categories>
        <category>JavaScript学习总结</category>
      </categories>
      <tags>
        <tag>继承</tag>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习总结（五）原型和原型链详解]]></title>
    <url>%2F2016%2F06%2F15%2FJavaScript%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%94%EF%BC%89%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[私有变量和函数在函数内部定义的变量和函数，如果不对外提供接口，外部是无法访问到的，也就是该函数的私有的变量和函数。 1234567function Box() &#123; var color = "blue"; //私有变量 var fn = function() //私有函数 &#123; &#125;&#125; 这样在函数对象Box外部无法访问变量color和fn，他们就变成私有的了：123var obj = new Box(); alert(obj.color);//弹出 undefined alert(obj.fn);//同上 静态变量和函数当定义一个函数后通过点号 “.”为其添加的属性和函数，通过对象本身仍然可以访问得到，但是其实例却访问不到，这样的变量和函数分别被称为静态变量和静态函数。12345678910111213141516&lt;script type="text/javascript"&gt; function Obj()&#123;&#125;; Obj.num = 72;//静态变量 Obj.fn = function() //静态函数 &#123; &#125; alert(Obj.num);//72 alert(typeof Obj.fn)//function var t = new Obj(); alert(t.name);//undefined alert(typeof t.fn);//undefined&lt;/script&gt; 实例变量和函数在面向对象编程中除了一些库函数我们还是希望在对象定义的时候同时定义一些属性和方法，实例化后可以访问，js也能做到这样12345678910111213function Box() &#123; this.a = []; //实例变量 this.fn = function() &#123; //实例方法 &#125; &#125;console.log(typeof Box.a); //undefinedconsole.log(typeof Box.fn); //undefinedvar box = new Box();console.log(typeof box.a); //objectconsole.log(typeof box.fn); //function 为实例变量和方法添加新的方法和属性 12345678910111213141516function Box() &#123; this.a = []; //实例变量 this.fn = function() &#123; //实例方法 &#125;&#125;var box1 = new Box();box1.a.push(1);box1.fn = &#123;&#125;;console.log(box1.a); //[1]console.log(typeof box1.fn); //objectvar box2 = new Box();console.log(box2.a); //[]console.log(typeof box2.fn); //function 在box1中修改了a和fn，而在box2中没有改变，由于数组和函数都是对象，是引用类型，这就说明box1中的属性和方法与box2中的属性与方法虽然同名但却不是一个引用，而是对Box对象定义的属性和方法的一个复制。 这个对属性来说没有什么问题，但是对于方法来说问题就很大了，因为方法都是在做完全一样的功能，但是却又两份复制，如果一个函数对象有上千和实例方法，那么它的每个实例都要保持一份上千个方法的复制，这显然是不科学的，这可肿么办呢prototype应运而生。 prototype基本概念我们创建的每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。那么，prototype就是通过调用 构造函数 而创建的那个对象实例的原型对象。 使用原型的好处是可以让对象实例共享它所包含的属性和方法。也就是说，不必在构造函数中添加定义对象信息，而是可以直接将这些信息添加到原型中。使用构造函数的主要问题就是每个方法都要在每个实例中创建一遍。 在JavaScript中,一共有两种类型的值,原始值和对象值。每个对象都有一个内部属性 prototype ,我们通常称之为原型。原型的值可以是一个对象,也可以是null。如果它的值是一个对象，则这个对象也一定有自己的原型。这样就形成了一条线性的链，我们称之为原型链。 含义函数可以用来作为构造函数来使用。另外只有函数才有prototype属性并且可以访问到，但是对象实例不具有该属性，只有一个内部的不可访问的__proto__属性。__proto__是对象中一个指向相关原型的神秘链接。按照标准，__proto__是不对外公开的，也就是说是个私有属性，但是Firefox的引擎将他暴露了出来成为了一个共有的属性，我们可以对外访问和设置。123456789&lt;script type="text/javascript"&gt; var Browser = function()&#123;&#125;; Browser.prototype.run = function()&#123; alert("I'm Gecko,a kernel of firefox"); &#125; var Bro = new Browser(); Bro.run();&lt;/script&gt; 当我们调用Bro.run()方法时，由于Bro中没有这个方法，所以，他就会去他的__proto__中去找，也就是Browser.prototype，所以最终执行了该run()方法。（在这里，函数首字母大写的都代表构造函数，以用来区分普通函数） 当调用构造函数创建一个实例的时候，实例内部将包含一个内部指针（__proto__）指向构造函数的prototype，这个连接存在于实例和构造函数的prototype之间，而不是实例与构造函数之间。 12345678910111213141516&lt;script type="text/javascript"&gt;function Person(name)&#123; //构造函数 this.name=name; &#125; Person.prototype.printName=function() //原型对象 &#123; alert(this.name); &#125; var person1=new Person('Byron');//实例化对象 console.log(person1.__proto__);//Person console.log(person1.constructor);//自己试试看会是什么吧 console.log(Person.prototype);//指向原型对象Person var person2=new Person('Frank');&lt;/script&gt; Person的实例person1中包含了name属性，同时自动生成一个__proto__属性，该属性指向Person的prototype，可以访问到prototype内定义的printName方法，大概就是这个样子的: 每个JavaScript函数都有prototype属性，这个属性引用了一个对象，这个对象就是原型对象。原型对象初始化的时候是空的，我们可以在里面自定义任何属性和方法，这些方法和属性都将被该构造函数所创建的对象继承。 那么，现在问题来了。构造函数、实例和原型对象三者之间有什么关系呢？ 构造函数、实例和原型对象的区别实例就是通过构造函数创建的。实例一创造出来就具有constructor属性（指向构造函数）和__proto__属性（指向原型对象）， 构造函数中有一个prototype属性，这个属性是一个指针，指向它的原型对象。 原型对象内部也有一个指针（constructor属性）指向构造函数:Person.prototype.constructor = Person; 实例可以访问原型对象上定义的属性和方法。 在这里person1和person2就是实例，prototype是他们的原型对象。 再举个例子：1234567891011121314151617function Animal(name) //基类构造函数 &#123; this.name = name; //设置对象属性 &#125; Animal.prototype.behavior = function() //给基类构造函数的prototype添加behavior方法 &#123; alert("this is a " + this.name); &#125; var Dog = new Animal("dog"); //创建Dog对象 var Cat = new Animal("cat"); //创建Cat对象 Dog.behavior(); //通过Dog对象直接调用behavior方法 Cat.behavior(); //output "this is a cat" alert(Dog.behavior == Cat.behavior); //output true; 可以从程序运行结果看出，构造函数的prototype上定义的方法确实可以通过对象直接调用到，而且代码是共享的。（可以试一下将Animal.prototype.behavior 中的prototype属性去掉，看看还能不能运行。）在这里，prototype属性指向Animal对象。 数组对象实例再看个数组对象的实例。当我们创建出array1这个对象的时候，array1实际在Javascript引擎中的对象模型如下： 1var array1 = [1,2,3]; array1对象具有一个length属性值为3，但是我们可以通过如下的方法来为array1增加元素： 1array1.push(4); push这个方法来自于array1的__proto__成员指向对象的一个方法Array.prototye.push()。正是因为所有的数组对象（通过[]来创建的）都包含有一个指向同一个具有push,reverse等方法对象Array.prototype的__proto__成员，才使得这些数组对象可以使用push,reverse等方法。 函数对象实例123function Base() &#123; this.id = "base" &#125; 1var obj = new Base(); 这样代码的结果是什么，我们在Javascript引擎中看到的对象模型是： new操作符具体干了什么呢?其实很简单，就干了三件事情。 12345678910111、创建一个新对象2、将构造函数的作用域赋给新对象（因此this就指向了这个新对象）3、执行构造函数中的代码（为这个新对象添加属性）4、返回新对象var obj = &#123;&#125;; obj.__proto__ = Base.prototype; Base.call(obj); 原型链原型链：当从一个对象那里调取属性或方法时，如果该对象自身不存在这样的属性或方法，就会去自己关联的prototype对象那里寻找，如果prototype没有，就会去prototype关联的前辈prototype那里寻找，如果再没有则继续查找Prototype.Prototype引用的对象，依次类推，直到Prototype.….Prototype为undefined（Object的Prototype就是undefined）从而形成了所谓的“原型链”。 12345678910111213141516171819202122&lt;script type="text/javascript"&gt; function Shape()&#123; this.name = "shape"; this.toString = function()&#123; return this.name; &#125; &#125; function TwoShape()&#123; this.name = "2 shape"; &#125; function Triangle(side,height)&#123; this.name = "Triangle"; this.side = side; this.height = height; this.getArea = function()&#123; return this.side*this.height/2; &#125; &#125; TwoShape.prototype = new Shape(); Triangle.prototype = new TwoShape();&lt;/script&gt; 这里，用构造器Shape()新建了一个实体，然后用它去覆盖该对象的原型。 123456789101112131415161718192021222324252627282930&lt;script type="text/javascript"&gt; function Shape()&#123; this.name = "shape"; this.toString = function()&#123; return this.name; &#125; &#125; function TwoShape()&#123; this.name = "2 shape"; &#125; function Triangle(side,height)&#123; this.name = "Triangle"; this.side = side; this.height = height; this.getArea = function()&#123; return this.side*this.height/2; &#125; &#125; TwoShape.prototype = new Shape(); Triangle.prototype = new TwoShape(); TwoShape.prototype.constructor = TwoShape; Triangle.prototype.constructor = Triangle; var my = new Triangle(5,10); my.getArea(); my.toString();//Triangle my.constructor;//Triangle(side,height)&lt;/script&gt; 原型继承原型继承：在原型链的末端，就是Object构造函数prototype属性指向的那个原型对象。这个原型对象是所有对象的祖先，这个老祖宗实现了诸如toString等所有对象天生就该具有的方法。其他内置构造函数，如Function，Boolean，String，Date和RegExp等的prototype都是从这个老祖宗传承下来的，但他们各自又定义了自身的属性和方法，从而他们的子孙就表现出各自宗族的那些特征。 ECMAScript中，实现继承的方法就是依靠原型链实现的。 123456789101112131415function Father() &#123; //被继承的函数叫做超类型（父类，基类） this.name = "Jack";&#125;function Son() &#123; //继承的函数叫做子类型（子类，派生类） this.age = 10;&#125;//通过原型链继承，赋值给子类型的原型属性//new Father()会将father构造里的信息和原型里的信息都交给SonSon.prototype = new Father(); //Son继承了Father,通过原型，形成链条var son = new Son();alert(son.name); //弹出 Jack 原型链的问题：原型链虽然很强大，可以用它来实现继承，但它也存在一些问题。其中最主要的问题来自包含引用类型的值原型。包含引用类型的原型属性会被所有实例共享；而这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。在通过原型来实现继承时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也就变成了原型的属性。 在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。再加上刚刚讨论的由于原型中包含引用类型值所带来的问题，实践中很少会单独使用原型链。 再举个例子： 123456789101112131415161718192021222324&lt;script type="text/javascript"&gt; function Person(name) &#123; this.name = name;//设置对象属性 &#125;; Person.prototype.company = "Microsoft";//设置原型的属性 Person.prototype.SayHello = function() //原型的方法 &#123; alert("Hello,I'm "+ this.name+ " of " + this.company); &#125;; var BillGates = new Person("BillGates");//创建person对象 BillGates.SayHello();//继承了原型的内容，输出"Hello,I'm BillGates of Microsoft" var Jobs = new Person("Jobs"); Jobs.company = "Apple";//设置自己的company属性，掩盖了原型的company属性 Jobs.SayHello = function() &#123; alert("Hi,"+this.name + " like " + this.company); &#125;; Jobs.SayHello();//自己覆盖的属性和方法，输出"Hi,Jobs like Apple" BillGates.SayHello();//Jobs的覆盖没有影响原型，BillGates还是照样输出&lt;/script&gt; __proto__属性__ptoto__属性（IE浏览器不支持）是实例指向原型对象的一个指针，它的作用就是指向构造函数的原型属性constructor，通过这两个属性，就可以访问原型里的属性和方法了。 Javascript中的对象实例本质上是由一系列的属性组成的，在这些属性中，有一个内部的不可见的特殊属性——__proto__，该属性的值指向该对象实例的原型，一个对象实例只拥有一个唯一的原型。 123456789101112131415&lt;script type="text/javascript"&gt; function Box()&#123; //大写，代表构造函数 Box.prototype.name = "trigkit4";//原型属性 Box.prototype.age = "21"; Box.prototype.run = function()//原型方法 &#123; return this.name + this.age + 'studying'; &#125; &#125; var box1 = new Box(); var box2 = new Box(); alert(box1.constructor);//构造属性，可以获取构造函数本身， //作用是被原型指针定位，然后得到构造函数本身&lt;/script&gt; __proto__属性和prototype属性的区别prototype是function对象中专有的属性。__proto__是普通对象的隐式属性，在new的时候，会指向prototype所指的对象；__ptoto__实际上是某个实体对象的属性，而prototype则是属于构造函数的属性。__ptoto__只能在学习或调试的环境下使用。 原型模式的执行流程 先查找构造函数实例里的属性或方法，如果有，就立即返回。 如果构造函数的实例没有，就去它的原型对象里找，如果有，就立即返回 原型对象的123456789101112131415161718&lt;script type="text/javascript"&gt; function Box()&#123; //大写，代表构造函数 Box.prototype.name = "trigkit4";//原型属性 Box.prototype.age = "21"; Box.prototype.run = function()//原型方法 &#123; return this.name + this.age + 'studying'; &#125; &#125; var box1 = new Box(); alert(box1.name);//trigkit4,原型里的值 box1.name = "Lee"; alert(box1.name);//Lee,就进原则 var box2 = new Box(); alert(box2.name);//trigkit4,原型的值，没有被box1修改&lt;/script&gt; 构造函数的1234567891011121314151617&lt;script type="text/javascript"&gt; function Box()&#123; this.name = "Bill"; &#125; Box.prototype.name = "trigkit4";//原型属性 Box.prototype.age = "21"; Box.prototype.run = function()//原型方法 &#123; return this.name + this.age + 'studying'; &#125; var box1 = new Box(); alert(box1.name);//Bill,原型里的值 box1.name = "Lee"; alert(box1.name);//Lee,就进原则&lt;/script&gt; 综上，整理一下： 123456789101112131415161718&lt;script type="text/javascript"&gt; function Person()&#123;&#125;; Person.prototype.name = "trigkit4"; Person.prototype.say = function()&#123; alert("Hi"); &#125; var p1 = new Person();//prototype是p1和p2的原型对象 var p2 = new Person();//p2为实例化对象，其内部有一个__proto__属性，指向Person的prototype console.log(p1.prototype);//undefined,这个属性是一个对象，访问不到 console.log(Person.prototype);//Person console.log(Person.prototype.constructor);//原型对象内部也有一个指针（constructor属性）指向构造函数 console.log(p1.__proto__);//这个属性是一个指针指向prototype原型对象 p1.say();//实例可以访问到在原型对象上定义的属性和方法 &lt;/script&gt; 123构造函数.prototype = 原型对象原型对象.constructor = 构造函数(模板)原型对象.isPrototypeof(实例对象) 判断实例对象的原型 是不是当前对象 工厂模式123456 function createObject(name,age)&#123; var obj = new Object(); obj.name = name; obj.age = age; return obj;&#125; 工厂模式解决了实例化对象大量重复的问题，但还有一个问题，那就是根本无法搞清楚他们到底是哪个对象的实例。使用构造函数的方法，既解决了重复实例化的问题，又解决了对象识别的问题。 使用构造函数的方法和工厂模式的不同之处在于： 1231.构造函数方法没有显示的创建对象(new Object());2.直接将属性和方法赋值给this对象3.没有return 语句 当使用了构造函数，并且new 构造函数()，那么就在后台执行了new Object()；函数体内的this代表了new Object()出来的对象 1234561.判断属性是在构造函数的实例里，还是在原型里，可以使用`hasOwnProperty()`函数2.字面量创建的方式使用constructor属性不会指向实例，而会指向Object，构造函数创建的方式则相反为什么指向Object？因为Box.prototype = &#123;&#125;;这种写法其实就是创建了一个新对象。而每创建一个函数，就会同时创建它的prototype，这个对象也会自动获取constructor属性3.如果是实例方法，不同的实例化，他们的方法地址是不一样的，是唯一的4.如果是原型方法，那么他们的地址的共享的]]></content>
      <categories>
        <category>JavaScript学习总结</category>
      </categories>
      <tags>
        <tag>函数</tag>
        <tag>原型链</tag>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解JS闭包]]></title>
    <url>%2F2016%2F06%2F14%2F%E8%AF%A6%E8%A7%A3JS%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。 闭包的特性1231.函数嵌套函数2.函数内部可以引用外部的参数和变量3.参数和变量不会被垃圾回收机制回收 闭包的定义及其优缺点闭包 是指有权访问另一个函数作用域中的变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量 闭包的缺点就是常驻内存，会增大内存使用量，使用不当很容易造成内存泄漏。 闭包是javascript语言的一大特点，主要应用闭包场合主要是为了：设计私有的方法和变量。 一般函数执行完毕后，局部活动对象就被销毁，内存中仅仅保存全局作用域。但闭包的情况不同！ 嵌套函数的闭包12345678910function aaa() &#123; var a = 1; return function()&#123; alert(a++) &#125;; &#125; var fun = aaa(); fun();// 1 执行后 a++，，然后a还在~ fun();// 2 fun = null;//a被回收！！ 闭包会使变量始终保存在内存中，如果不当使用会增大内存消耗。 javascript的垃圾回收原理（1）、在javascript中，如果一个对象不再被引用，那么这个对象就会被回收； （2）、如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。 使用闭包的好处1231.希望一个变量长期驻扎在内存中2.避免全局变量的污染3.私有成员的存在 一、全局变量的累加123456789&lt;script&gt;var a = 1;function abc()&#123; a++; alert(a);&#125;abc(); //2abc(); //3&lt;/script&gt; 二、局部变量12345678910&lt;script&gt;function abc()&#123; var a = 1; a++; alert(a);&#125;abc(); //2abc(); //2&lt;/script&gt; 那么怎么才能做到变量a既是局部变量又可以累加呢？ 三、局部变量的累加123456789101112&lt;script&gt;function outer()&#123; var x=10; return function()&#123; //函数嵌套函数 x++; alert(x); &#125;&#125;var y = outer(); //外部函数赋给变量y;y(); //y函数调用一次，结果为11，相当于outer()()；y(); //y函数调用第二次，结果为12，实现了累加&lt;/script&gt; 四、模块化代码，减少全局变量的污染1234567891011&lt;script&gt;var abc = (function()&#123; //abc为外部匿名函数的返回值 var a = 1; return function()&#123; a++; alert(a); &#125;&#125;)();abc(); //2 ；调用一次abc函数，其实是调用里面内部函数的返回值 abc(); //3&lt;/script&gt; 五、私有成员的存在12345678910111213141516171819&lt;script&gt;var aaa = (function()&#123; var a = 1; function bbb()&#123; a++; alert(a); &#125; function ccc()&#123; a++; alert(a); &#125; return &#123; b:bbb, //json结构 c:ccc &#125;&#125;)();aaa.b(); //2aaa.c() //3&lt;/script&gt; 六、使用匿名函数实现累加1234567891011121314151617181920212223//使用匿名函数实现局部变量驻留内存中，从而实现累加&lt;script type="text/javascript"&gt; function box()&#123; var age = 100; return function()&#123; //匿名函数 age++; return age; &#125;; &#125; var b = box();alert(b());alert(b()); //即alert(box()())；alert(b());alert(b); // function () &#123; // age++; // return age; // &#125;b = null； //解除引用，等待垃圾回收&lt;/script&gt; 过度使用闭包会导致性能的下降。函数里放匿名函数，则产生了闭包 七、在循环中直接找到对应元素的索引123456789101112131415161718&lt;body&gt; &lt;ul&gt; &lt;li&gt;abcd&lt;/li&gt; &lt;li&gt;abcd&lt;/li&gt; &lt;li&gt;abcd&lt;/li&gt; &lt;li&gt;abcd&lt;/li&gt; &lt;li&gt;abcd&lt;/li&gt; &lt;/ul&gt; &lt;script type="text/javascript"&gt; var oLi = document.getElementsByTagName('li'); for (var i = 0; i &lt; oLi.length; i++) &#123; oLi[i].onclick = function() &#123; //输出undefined 当点击的时候for循环已经结束 alert(i) &#125; &#125; &lt;/script&gt;&lt;/body&gt; 八、使用闭包改写上面代码1234567891011121314151617181920&lt;body&gt; &lt;ul&gt; &lt;li&gt;abcd&lt;/li&gt; &lt;li&gt;abcd&lt;/li&gt; &lt;li&gt;abcd&lt;/li&gt; &lt;li&gt;abcd&lt;/li&gt; &lt;li&gt;abcd&lt;/li&gt; &lt;/ul&gt; &lt;script type="text/javascript"&gt; var oLi = document.getElementsByTagName('li'); for (var i = 0; i &lt; oLi.length; i++) &#123; (function(i) &#123; oLi[i].onclick = function() &#123; alert(i) &#125; &#125;)(i); &#125; &lt;/script&gt;&lt;/body&gt; 九、内存泄漏问题由于IE的js对象和DOM对象使用不同的垃圾收集方法，因此闭包在IE中会导致内存泄漏问题，也就是无法销毁驻留在内存中的元素 哪些操作会造成内存泄漏？ 1、内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。 2、垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 3、setTimeout的第一个参数使用字符串而非函数的话，会引发内存泄漏。闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） 12345678910111213141516function closure()&#123; var oDiv = document.getElementById('oDiv');//oDiv用完之后一直驻留在内存中 oDiv.onclick = function () &#123; alert('oDiv.innerHTML');//这里用oDiv导致内存泄漏 &#125;;&#125;closure();//最后应将oDiv解除引用来避免内存泄漏function closure()&#123; var oDiv = document.getElementById('oDiv'); var test = oDiv.innerHTML; oDiv.onclick = function () &#123; alert(test); &#125;; oDiv = null;&#125; 闭包： http://www.codeceo.com/article/javascript-closure-interview.html 阮一峰：http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html]]></content>
      <categories>
        <category>JavaScript学习总结</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习总结（四）function函数部分]]></title>
    <url>%2F2016%2F06%2F14%2FJavaScript%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E5%9B%9B%EF%BC%89function%E5%87%BD%E6%95%B0%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[概念 函数是由事件驱动的或者当它被调用时执行的可重复使用的代码块。 js支持两种函数：一类是语言内部的函数（如eval()），另一类是自己创建的。 在 JavaScript 函数内部声明的变量（使用 var）是局部变量，所以只能在函数内部访问它。（该变量的作用域是局部的）。 你可以在不同的函数中使用名称相同的局部变量，因为只有声明过该变量的函数才能识别出该变量。 函数调用有如下四种调用js函数的方式： 作为函数 作为方法 作为构造函数 通过call()和apply() 返回函数的函数1231. 当函数无明确返回值时，返回的值就是`undefined`。2. 当函数有返回值时，返回值是什么就返回什么。 我们可以通过使用 return 语句实现将函数返回调用它的地方。 在使用return 语句时，函数会停止执行，并返回指定的值。 函数通常会返回一个唯一值，那么这个值也可能是另一个函数： 123456789//函数表达式var box = function()&#123; var a=1; return function()&#123; alert(a++) &#125; alert(a);//永远不会执行&#125; alert(box());//弹出"function()&#123;alert(a++)&#125;" 在这里，我们只需将返回值赋值给某个变量，然后就可以像使用一般函数那样调用它了： 12345678var box = function()&#123; var a=1; return function()&#123; alert(++a) &#125;&#125;var newFunc = box();newFunc();//2 如果想让返回的函数立即执行，亦可以使用box()()来执行这段代码。 ECMAScript所有函数的参数都是按值传递的，言下之意就是参数不会按引用传递。 PS：如果存在按引用传递的话，那么函数里的那个变量将会是全局变量，在外部也可以访问。 12（1）值类型：数值、布尔值、null、undefined。（2）引用类型：对象、数组、函数。 引用类型值：指的是那些保存在堆内存中的对象，意思是，变量中保存的实际上只是一个指针，这个指针执行内存中的另一个位置，由该位置保存对象； 创建匿名函数123function()&#123; return ‘hi’; //单独的匿名函数是无法运行的，就算能运行也无法调用，因为没有名字&#125; 这种匿名函数的用法在JQuery中非常多。直接声明一个匿名函数，立即使用。用匿名函数的好处就是省得定义一个用一次就不用的函数，而且免了命名冲突的问题，js中没有命名空间的概念，因此很容易函数名字冲突，一旦命名冲突以最后声明的为准。 在javascript语言里任何匿名函数都是属于window对象。在定义匿名函数时候它会返回自己的内存地址，如果此时有个变量接收了这个内存地址，那么匿名函数就能在程序里被使用了，因为匿名函数也是在全局执行环境构造时候定义和赋值，所以匿名函数的this指向也是window对象123(function()&#123; console.log(this === window);//true&#125;)(); 把匿名函数自我执行的返回值赋给变量：1234567891011&lt;script type="text/javascript"&gt; var box = (function ()&#123; alert('Lee'); &#125;)(); //弹出”Lee”； alert(box); //弹出 undefined&lt;/script&gt;var box= (function () &#123; return 'hi';&#125;)();console.log(box);//hi 自我执行匿名函数的传参：12345&lt;script type="text/javascript"&gt; (function (age)&#123; alert(age); &#125;)(100); //弹出100&lt;/script&gt; 自执行函数的三种写法123var result = function ()&#123; alert(2);&#125;(); 另一种语法也可得到同样结果：123var result = (function () &#123; console.log(2);&#125;)(); 将函数返回值分配给变量：123var result = (function () &#123; return 2;&#125;()); 回调函数回调就是一个函数的调用过程。那么就从理解这个调用过程开始吧。函数a有一个参数，这个参数是个函数b，当函数a执行完以后执行函数b。那么这个过程就叫回调。 其实中文也很好理解：回调，回调，就是回头调用的意思。函数a的事先干完，回头再调用函数b。 这里必须清楚一点：函数b是你以参数形式传给函数a的，那么函数b就叫回调函数。 在jquery里的绝大多数效果函数都涉及到callback函数。jQuery 效果函数 12345&lt;script type="text/javascript"&gt; $("div").show(1000,function()&#123; //callback function &#125;);&lt;/script&gt; 这里的callback function换成实例可以是：12345&lt;script type="text/javascript"&gt; $("div").show(1000,function()&#123; console.log("hello world") &#125;);&lt;/script&gt; 方法和函数的区别1234567891011var arr = [1,2,3,4,5]var a =12; // 变量：自由的arr.a= 5; //属性：属于一个对象function show() //函数：自由的&#123; alert(‘a’);&#125;arr.fn = function() //方法：属于一个对象&#123; alert(‘b’);&#125; 其实方法就是函数，只不过方法是有所属的对象。 我们所熟知的，将函数绑定到click事件 语法：1$(selector).click(function) js全局函数全局函数与内置对象的属性或方法不是一个概念。全局函数它不属于任何一个内置对象。JavaScript 中包含以下 7 个全局函数，用于完成一些常用的功能：12escape( )、eval( )、isFinite( )、isNaN( )、parseFloat( )、parseInt( )、unescape( )。 函数的几个作用 作为一个类构造器使用 123function Class()&#123;&#125;Class.prototype=&#123;&#125;;var item=new Class(); 作为闭包使用 123(function()&#123; //独立作用域&#125;)(); 作为构造函数调用 所谓构造函数，就是通过这个函数生成一个新对象（object）。12345678&lt;script type="text/javascript"&gt; function Test()&#123;//大写，以区分普通函数 this.x = 10; &#125; var obj = new Test(); alert(obj.x); //弹出 10； &lt;/script&gt; ## 原型prototype的定义 在JavaScript中，任何一个函数都有一个prototype属性，指向一个对象。但是原型对于普通函数来说没有任何用处，如果函数是一个构造函数，那么用处极大。 12345678910111213141516171819202122//构造函数。构造函数里面没有任何语句，也就是说，这个构造函数在执行的时候，不会给创建出来的对象添加任何属性。function People()&#123; &#125;//构造函数的原型。我们更改了构造函数的原型，为一个新的对象：People.prototype=&#123; name:"Beme", sex:"男", age:18&#125;//当一个对象被new出来的时候，不仅仅执行了构造函数里面的语句，也会把这个函数的__proto__指向构造函数的prototype。var xiaoming = new People();console.log(xiaoming.__proto__);console.log(xiaoming.__proto__ == People.prototype);//当我们试图访问name、sex、age属性的时候，身上没有。那么就去查找原型，原型身上有，就当做了自己的属性返回了。console.log(xiaoming.name);console.log(xiaoming.sex);console.log(xiaoming.age); JavaScript中的原型链查找： 当我们试图访问一个对象身上的属性的时候，如果这个对象身上有这个属性，则返回它的值。如果它身上没有这个属性，那么将访问它的原型对象，检测它的原型对象身上是否有这个值，如果有返回它原型对象身上的这个值。 任何一个函数都有原型，原型是一个对象，用prototype来访问。当这个函数是构造函数的时候，new出来的对象，它们的原型对象就是这个构造函数的原型。 prototype我们称为“原型”，只有函数有原型 proto我们称为“原型对象”，任何对象都有原型对象。 原型的用途 我们定义一个方法的时候，如果写在构造函数里面：12345678910111213 function People(name,age)&#123; this.name = name; this.age = age; this.sayHello = function()&#123; alert("你好,我是" + this.name + "我今年" + this.age + "岁了"); &#125;; &#125;;var xiaoming = new People("小明",12);var xiaohong = new People("小红",11);xiaoming.sayHello();xiaohong.sayHello(); 实际上这个函数被复制了两份，一份给了xiaoming，一份给了xiaohong。xiaoming和xiaohong这两个实例身上有了相同功能的函数，但是这个函数不是同一个函数！ ==一句话：所有的属性要绑在对象身上，而所有的方法，定义在对象的原型对象中（构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性）：==12345678 function People(name,age)&#123; //构造函数里面，负责定义一些属性，随着构造函数的执行，这些属性将绑定到new出来的对象身上 this.name = name; this.age = age; &#125; //把所有的方法，定义在原型对象身上：People.prototype.sayHello = function()&#123; alert("你好,我是" + this.name + "我今年" + this.age + "岁了");9 &#125; call()和apply()apply()函数有两个参数：第一个参数是上下文，第二个参数是参数组成的数组。如果上下文是null，则使用全局对象代替。例如：1function.apply(this,[1,2,3]) call()的第一个参数是上下文，后续是实例传入的参数序列，例如： 1function.call(this,1,2,3); 函数的递归函数的递归，即一个函数在通过名字调用自身的情况下构成的： 通过使用argument.callee代替函数名： 12345678910//arguments.callee是一个指向正在执行的函数的指针&lt;script&gt; function factorial(num)&#123; if(num&lt;=1)&#123; return 1; &#125;else&#123; return num*arguments.callee(num-1); &#125; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>JavaScript学习总结</category>
      </categories>
      <tags>
        <tag>函数</tag>
        <tag>prototype</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习总结（三）BOM和DOM详解]]></title>
    <url>%2F2016%2F06%2F13%2FJavaScript%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89BOM%E5%92%8CDOM%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[DOM部分DOM：Document Object Model : 文档对象模型 文档：HTML页面 文档对象：页面中的元素 文档对象模型： 为了让程序（JS）去操作页面中的元素 DOM树由节点构成 1节点种类：元素节点、文本节点和属性节点 DOM（文档对象模型）是HTML 和 XML 的应用程序接口（API）。DOM代表着被加载到浏览器窗口里的当前网页：浏览器向我们提供了当前网页的地图（或者说模型），而我们可以通过js去读取这张地图。 BOM主要处理浏览器窗口和框架，不过通常浏览器特定的 JavaScript扩展都被看做BOM的一部分。这些扩展包括：123456弹出新的浏览器窗口移动、关闭浏览器窗口以及调整窗口大小提供 Web 浏览器详细信息的定位对象提供用户屏幕分辨率详细信息的屏幕对象对 cookie 的支持IE 扩展了 BOM，加入了 ActiveXObject 类，可以通过 JavaScript 实例化 ActiveX 对象 window对象对应着浏览器窗口本身，这个对象的属性和方法通常被称为BOM DOM包含：window 123Window对象包含属性：document、location、navigator、screen、history、framesDocument根节点包含子节点：forms、location、anchors、images、links 从window.document已然可以看出，DOM的最根本的对象是BOM的window对象的子对象。 区别：DOM描述了处理网页内容的方法和接口，BOM描述了与浏览器进行交互的方法和接口。 根据W3C DOM规范，DOM是HTML与XML的应用编程接口（API），DOM将整个页面映射为一个由层次节点组成的文件。有1级、2级、3级共3个级别。 将HTML代码分解为DOM节点层次图： 1234 HTML文档可以说由节点构成的集合，DOM节点有:1. 元素节点：上图中&lt;html&gt;、&lt;body&gt;、&lt;p&gt;等都是元素节点，即标签。2. 文本节点:向用户展示的内容，如&lt;li&gt;...&lt;/li&gt;中的JavaScript、DOM、CSS等文本。3. 属性节点:元素属性，如&lt;a&gt;标签的链接属性href="www.xxx.com"。 查找元素W3C提供了比较方便的定位节点的方法和属性，如下所示： 方法 说明 getElementById() 获取特定ID元素的节点 getElementsByTagName() 获取相同元素的节点列表 getElementsByName 获取相同名称的节点列表 getAttribute() 获取特定元素节点属性的值 setAttribute() 设置特定元素节点属性的值 removeAttribute() 移除特定元素节点属性 元素节点属性 属性 说明 tagName 获取原酸节点的标签名 innerHTML 获取元素节点的内容 nodeName 返回一个字符串，其内容是节点的名字 nodeType 返回一个整数，这个数值代表给定节点的类型 nodeValue 返回给定节点的当前值 遍历节点树 节点 说明 childNodes 返回一个数组，这个数组由给定元素的子节点构成 firstChild 返回第一个子节点 lastChild 返回最后一个子节点 parentNode 返回一个给定节点的父节点 nextSibling 返回给定节点的下一个子节点 previousSibling 返回给定节点的上一个子节点 DOM操作 DOM操作 说明 creatElement(element) 创建一个新的元素节点 creatTextNode() 创建一个包含给定文本的新文本节点 appendChild() 指定节点的最后一个节点列表后添加一个新的子节 insertBefore() 将一个给定节点插入到一个给定元素节点的给定子节点的前面 removeChild() 从一个给定元素中删除子节点 replaceChild() 把一个给定父元素里的一个子节点替换为另外一个节点 DOM通过创建树来表示文档，描述了处理网页内容的方法和接口，从而使开发者对文档的内容和结构具有空前的控制力，用DOM API可以轻松地删除、添加和替换节点。 DOM事件12345678910DOM同时两种事件模型：冒泡型事件和捕获型事件 冒泡型事件：事件按照从最特定的事件目标到最不特定的事件目标的顺序触发 &lt;body onclick="handleClick()"&gt; &lt;div onclick="handleClick()"&gt;Click Me&lt;/div&gt; &lt;/body&gt; 触发的顺序是：div、body、html(IE 6.0和Mozilla 1.0)、document、window(Mozilla 1.0) 捕获型事件：与冒泡事件相反的过程，事件从最不精确的对象开始触发，然后到最精确 上面例子触发的顺序是：document、div DOM事件模型最独特的性质是，文本节点也触发事件(在IE中不会)。 事件处理/监听函数DOM0级事件绑定1234oDiv.onclick=function()&#123;&#125;;oDiv.onclick=null //删除onclick属性 这种事件监听方法，只能监听冒泡过程。事件发生顺序：最内层→最外层 用这种方法绑定的监听，this指的是触发这个事件的元素，无浏览器兼容问题 DOM2级事件绑定 addEventListener(“事件”,函数,Boolean); //绑定 removeEventListener(“事件名”，函数，Boolean)//解除 第一个参数：事件名不用写on。click、mouseover、mouseout 第二个参数：可以是匿名函数，也可以是有名函数 第三个参数：true表示监听捕获，false表示监听冒泡阶段 IE的事件绑定 IE6、7、8不支持addEventListener（）方法； oDiv.attachEvent(“onclick”,函数) //只能监听冒泡 detachEvent(事件名，函数) //解除绑定 第一个参数必须写on 有关HTML DOM Event 对象 BOM部分BOM的核心是window，而window对象又具有双重角色，它既是通过js访问浏览器窗口的一个接口，又是一个Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都以window作为其global对象。 document对象1234567891011121314151617181920212223document对象：实际上是window对象的属性，document == window.document为true，是唯一一个既属于BOM又属于DOM的对象 document.lastModified //获取最后一次修改页面的日期的字符串表示 document.referrer //用于跟踪用户从哪里链接过来的 document.title //获取当前页面的标题，可读写 document.URL //获取当前页面的URL，可读写 document.anchors[0]或document.anchors["anchName"] //访问页面中所有的锚 document.forms[0]或document.forms["formName"] //访问页面中所有的表单 document.images[0]或document.images["imgName"] // 访问页面中所有的图像 document.links [0]或document.links["linkName"] //访问页面中所有的链接 document.applets [0]或document.applets["appletName"] //访问页面中所有的Applet document.embeds [0]或document.embeds["embedName"] //访问页面中所有的嵌入式对象 document.write(); 或document.writeln(); //将字符串插入到调用它们的位置 location对象1234567891011121314151617181920212223location对象：表示载入窗口的URL，也可用window.location引用它 location.href //当前载入页面的完整URL，如http://www.somewhere.com/pictures/index.htm location.portocol //URL中使用的协议，即双斜杠之前的部分，如http location.host //服务器的名字，如www.wrox.com location.hostname //通常等于host，有时会省略前面的www location.port //URL声明的请求的端口，默认情况下，大多数URL没有端口信息，如8080 location.pathname //URL中主机名后的部分，如/pictures/index.htm location.search //执行GET请求的URL中的问号后的部分，又称查询字符串，如?param=xxxx location.hash //如果URL包含#，返回该符号之后的内容，如#anchor1 location.assign("http:www.baidu.com"); //同location.href，新地址都会被加到浏览器的历史栈中 location.replace("http:www.baidu.com"); //同assign()，但新地址不会被加到浏览器的历史栈中，不能通过back和forward访问 location.reload(true | false); //重新载入当前页面，为false时从浏览器缓存中重载，为true时从服务器端重载，默认为false navigator对象12345678910111213141516171819 navigator对象：包含大量有关Web浏览器的信息，在检测浏览器及操作系统上非常有用，也可用window.navigator引用它 navigator.appCodeName //浏览器代码名的字符串表示 navigator.appName //官方浏览器名的字符串表示 navigator.appVersion //浏览器版本信息的字符串表示 navigator.cookieEnabled //如果启用cookie返回true，否则返回false navigator.javaEnabled //如果启用java返回true，否则返回false navigator.platform //浏览器所在计算机平台的字符串表示 navigator.plugins //安装在浏览器中的插件数组 navigator.taintEnabled //如果启用了数据污点返回true，否则返回false navigator.userAgent //用户代理头的字符串表示 screen对象1234567891011screen对象：用于获取某些关于用户屏幕的信息，也可用window.screen引用它 screen.width/height //屏幕的宽度与高度，以像素计 screen.availWidth/availHeight //窗口可以使用的屏幕的宽度和高度，以像素计 screen.colorDepth //用户表示颜色的位数，大多数系统采用32位 window.moveTo(0, 0); window.resizeTo(screen.availWidth, screen.availHeight); //填充用户的屏幕 window对象方法 方法 描述 alert() 显示带有一段消息和一个确认按钮的警告框。 blur() 把键盘焦点从顶层窗口移开。 clearInterval() 取消由 setInterval() 设置的 timeout。 clearTimeout() 取消由 setTimeout() 方法设置的 timeout。 close() 关闭浏览器窗口。 confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框。 createPopup() 创建一个 pop-up 窗口。 focus() 把键盘焦点给予一个窗口。 moveBy() 可相对窗口的当前坐标把它移动指定的像素。 moveTo() 把窗口的左上角移动到一个指定的坐标。 open() 打开一个新的浏览器窗口或查找一个已命名的窗口。 print() 打印当前窗口的内容。 prompt() 显示可提示用户输入的对话框。 resizeBy() 按照指定的像素调整窗口的大小。 resizeTo() 把窗口的大小调整到指定的宽度和高度。 scrollBy() 按照指定的像素值来滚动内容。 scrollTo() 把内容滚动到指定的坐标。 setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式。 setTimeout() 在指定的毫秒数后调用函数或计算表达式。 BOM和DOM的结构关系示意图]]></content>
      <categories>
        <category>JavaScript学习总结</category>
      </categories>
      <tags>
        <tag>DOM</tag>
        <tag>BOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习总结（二）数组和对象部分]]></title>
    <url>%2F2016%2F06%2F12%2FJavaScript%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[对象部分Object类型Object 是一个无序的集合，可以存放任意类型对象，所有其他对象都继承自这个对象。 创建Object类型有两种，一种是使用new运算符，一种是字面量表示法。 1.使用new运算符创建Object1var obj = new Object();//注意大写，也可以直接写成Object() 注意，通过new Object()的写法生成新对象，与字面量的写法obj = {}是等价的。 2. 使用字面量方式创建：1234var obj = &#123; name : 'Beme', age : 21&#125;;//分号最好加上 在使用字面量声明Object对象时，不会调用Object()构造函数（FF除外） Object.prototype对象所有构造函数都有一个prototype属性，指向一个原型对象。123var obj = new Object();Object.prototype.print = function()&#123; console.log(111)&#125;;obj.print() // 111 实例obj直接继承了Object.prototype的属性和方法。12345671.对象只是一种特殊的数据。对象拥有属性和方法。 JavaScript 是面向对象的语言，但 JavaScript 不使用类。 JavaScript 基于 [prototype][1]，而不是基于类的。2.属性：是隶属于某个特定对象的变量。方法：是只有某个特定对象才能调用的函数。3.js对象是属性和方法的集合。一个方法就是一个函数，是对象的成员。属性是一个值或一组值（以数组或对象的形式），是对象的成员。4.js对象是基于构造器函数的，使用构造器函数创建一个新对象时，就可以说是实例化了一个新对象。属性是构造器函数内部的变量。 使用构造器函数实例化的对象：1cat = new Animal(); Javascript是一种基于对象（object-based）的语言，你遇到的所有东西几乎都是对象。但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有class（类）。1234567&lt;script type="text/javascript"&gt; //对象是名/值对的集合 var browser = &#123; //对象是由花括号括起来的 name:"Firefox", kernel:"Gecko" &#125;;&lt;/script&gt; 123//通过点号（.）或“[]”来访问对象的属性 browser.name //"Firefox" browser["kernel"] //"Gecko" 对象（objct）是属性（property）的集合，每个属性都由“名/值对”构成，js同样定义了一个特殊的对象——数组，它是带有编号的值的有序集合。 js还定义了一个特殊的对象——函数，函数是具有与他相关联的可执行代码的对象，通过调用函数来执行代码，并返回运算结果。 JS中没有类，但是它取了一个新的名字叫“原型对象”，因此”类==原型对象” 类(原型对象)和对象(实例)的区别与联系1231.类(原型对象)是抽象，是概念的，代表一类事物。2.对象是具体的，实际的，代表一个具体的事物。3.类(原型对象)是对象实例的模板，对象实例是类的一个个体。 一个常见的误解是数字的字面值（literal）不是对象。这是因为 JavaScript 解析器的一个错误，它试图将点操作符解析为浮点数字面值的一部分。 有很多变通方法可以让数字的字面值看起来像对象。1232..toString(); // 第二个点号可以正常解析2 .toString(); // 注意点号前面的空格(2).toString(); // 2先被计算 JavaScript面向对象三大特征123封装：不考虑内部实现，只考虑功能使用继承：从已有对象上，继承出新的对象多态：所谓多态，就是指一个引用在不同情况下的多种状态。 封装封装就是要把属于同一类事物的共性(包括属性与行为)归到一个类中,以方便使用.比如人这个东东,可用下面的方式封装:12345678910人&#123;年龄(属性一)身高(属性二)性别(属性三)做事(行为之一)走路(行为之二)说话(行为之三)&#125; 封装的好处：1234封装保护了内部数据的完整性；封装使对象的重构更轻松；弱化模块间的耦合，提高对象的可重用性；有助于避免命名空间冲突； 看下面一个例子：123456789&lt;script type="text/javascript"&gt; var boy = &#123;&#125;; //创建一个空对象 boy.name = "小明";//按照原型对象的属性赋值 boy.age = 12; var girl = &#123;&#125;; girl.name = "小红"; girl.age = 10; &lt;/script&gt; 这就是最简单的封装了，把两个属性封装在一个对象里面。但是，这样的写法有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。 构造函数模式为了解决从原型对象生成实例的问题，Javascript提供了一个构造函数（Constructor）模式。 所谓”构造函数”，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。 比如boy和girl的原型对象现在就可以这样写：123456&lt;script type="text/javascript"&gt; function Person(name,age)&#123; this.name = name; this.age = age; &#125;&lt;/script&gt; 我们现在就可以生成实例对象了。1234567&lt;script type="text/javascript"&gt; var boy = new Person("小明",12; var girl = new Person("小红",10); alert(boy.name); //小明 alert(boy.age); //12&lt;/script&gt; 这时boy和girl会自动含有一个constructor属性，指向它们的构造函数。123alert(boy.constructor == Person); //truealert(girl.constructor); //输出整串构造函数代码 Prototype模式Javascript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。 这意味着，我们可以把那些不变的属性和方法，直接定义在prototype对象上。12345678910function Person(name,age)&#123; this.name = name; this.age = age;&#125;Person.protype.type = "人类";Person.protype.eat = function()&#123; alert("吃米饭");&#125; 然后，生成实例：12345var boy = new Person("小明","12");var girl = new Person("小红","10");alert(boy.type);//人类boy.eat();//吃饭 这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。1alert(boy.eat == girl.eat); //true 原型属性是一个内置属性，它指定了对象所扩展的构造器函数。 下面的代码为Animal构造器函数添加一个新的属性size，这个新属性是cat对象的原型属性。通过使用原型属性，所有扩展Animal构造器函数的对象就可以访问size属性。12cat = new Animal("feline","meow", "walk/run");cat.prototype.size = "fat"; 在这种情况下，所有的Animal对象的size属性都是“fat”。原型默认为Object的新实例, 由于仍是对象, 故可以给该对象添加新的属性。就好像style是javascript的一个对象一样，也可以往style后继续添加属性。123456789101112//定义一个Person类 function Person(_name,_age,_salary)&#123; //Person类的公开属性，类的公开属性的定义方式是：”this.属性名“ this.Name=_name; //Person类的私有属性，类的私有属性的定义方式是：”var 属性名“ var Age=_age; var Salary=_salary; //定义Person类的公开方法(特权方法) this.Show=function()&#123; alert("Age="+Age+"\t"+"Salary="+Salary);//在公开方法里面访问类的私有属性是允许的 &#125; 对象在查找某个属性的时候，会首先遍历自身的属性，如果没有则会继续查找[[Prototype]]引用的对象，如果再没有则继续查找[[Prototype]].[[Prototype]]引用的对象，依次类推，直到[[Prototype]].….[[Prototype]]为undefined（Object的[[Prototype]]就是undefined） 简单说就是通过对象的[[Prototype]]保存对另一个对象的引用，通过这个引用往上进行属性的查找，这就是原型链。 null 对象js给变量赋null值的作用在于：赋值一个空指针，容易让人理解这个变量是准备用来存放对象的。也方便调错。 全局的window对象JavaScript中的任何一个全局函数或变量都是window的属性。 self对象与window对象完全相同，self通常用于确认就是在当前的窗体内。 window的主对象主要有如下几个：123456JavaScript document 对象JavaScript frames 对象JavaScript history 对象JavaScript location 对象JavaScript navigator 对象JavaScript screen 对象 几个常用方法12345678valueof()方法：返回指定对象的原始值split() 方法：将字符串分割为字符串数组，并返回此数组。indexOf() 方法：可返回某个指定的字符串值在字符串中首次出现的位置。 substring() 方法：用于提取字符串中介于两个指定下标之间的字符。substr() 方法：从字符串中提取从 startPos位置开始的指定数目的字符串。 join()方法：用于把数组中的所有元素放入一个字符串。reverse() 方法：用于颠倒数组中元素的顺序。 slice() 方法：可从已有的数组中返回选定的元素。 对象字面量对象字面量是用于创建包含大量属性的过程，如下所示：123456var company = &#123; name : "Microsoft", ages : 39, employees : 99000, CEO : "Nadella" &#125;; 这里需要注意的是属性和属性值以冒号:隔开；多个属性用逗号,隔开。对象字面量亦可以定义方法，只需在这个对象的属性上写上function就行，这是一个匿名函数，调用它只需要写上他的方法名()即可。 12345678var dog = &#123; name:"husky", age:2, run:function()&#123; return "123";&#125;&#125;alert(dog.run());//如果输入dog.run,那么会弹出它后面的function部分的代码 数组部分Array 对象定义：var arr = [2,3,45,6]; var arr = new Array(2,4,5,7)两者是定义没有任何差别，[]的性能高，因为代码短。 使用数组和对象字面量：var aTest = []；创建数组时，使用数组字面量是个好选择；类似的，对象字面量也可用于节省空间。以下两行是相等的，但是使用对象字面量的更加简短：12var oTest = new Object; //尽量不用var oTest = &#123; &#125;; //最好的选择，或者var 0Test = [ ]; Array 构造函数由于 Array的构造函数在如何处理参数时有点模棱两可，因此总是推荐使用数组的字面语法 [] 来创建数组。 因此下面的代码将会使人很迷惑：12new Array(3, 4, 5); // 结果: [3, 4, 5] new Array(3) // 结果: []，此数组长度为 3 应该尽量避免使用数组构造函数创建新数组。推荐使用数组的字面语法。它们更加短小和简洁，因此增加了代码的可读性。 Array数组的属性Array数组的3个属性：length属性、prototype属性、constructor属性。 length属性 Length属性表示数组的长度，即其中元素的个数。因为数组的索引总是由0开始，所以一个数组的上下限分别是：0和length-1。和其他大多数语言不同的是，JavaScript数组的length属性是可变的，这一点需要特别注意。 prototype属性 返回对象类型原型的引用。prototype属性是object共有的。 对于Array数组对象，以以下例子说明prototype属性的用途。 给数组对象添加返回数组中最大元素值的方法。要完成这一点，声明一个函数，将它加入Array.prototype，并使用它。1234567891011121314function array_max() &#123; var i,max=this[0]; for(i=1;i&lt;this.length;i++) &#123; if(max&lt;this[i]) max=this[i]; &#125; return max; &#125; Array.prototype.max=array_max; var x=new Array(1,2,3,4,5,6); var y=x.max(); 该代码执行后，y保存数组x中的最大值，或说6。 constructor属性 表示创建对象的函数。说明：constructor属性是所有具有prototype的对象的成员。它们包括除Global和Math对象以外的所有JScript固有对象。constructor属性保存了对构造特定对象实例的函数的引用。 Array 对象方法 方法 描述 concat() 连接两个或更多的数组，并返回结果。 join() 把数组的所有元素放入一个字符串。 pop() 删除并返回数组的最后一个元素。 push() 向数组的末尾添加一个或更多元素，并返回新的长度。 reverse() 颠倒数组中元素的顺序。 shift() 删除并返回数组的第一个元素。 slice() 从某个已有的数组返回选定的元素。 sort() 对数组的元素进行排序。 splice() 删除元素，并向数组添加新元素。 toSource() 返回该对象的源代码。 toString() 把数组转换为字符串，并返回结果。 toLocaleString() 把数组转换为本地数组，并返回结果。 unshift() 向数组的开头添加一个或更多元素，并返回新的长度。 valueOf() 返回数组对象的原始值。 sort()方法12var arr = [11,2,28,4,5,1];console.log(arr.sort());//return [1, 11, 2, 28, 4, 5] 为什么这里的11、28没有按照顺序来排列？这是因为不带参数的sort是按照字符编码的顺序进行排序的。那么，如果要让数组元素按照从小到大排序呢？看下面代码：1234var arr = [11,2,28,4,5,1]; console.log(arr.sort(function(a,b)&#123; return a-b;//return [1, 2, 4, 5, 11, 28] &#125;)); 如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下： `若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。若 a 等于 b，则返回 0。若 a 大于 b，则返回一个大于 0 的值。]]></content>
      <categories>
        <category>JavaScript学习总结</category>
      </categories>
      <tags>
        <tag>JS对象</tag>
        <tag>JS数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习总结（一）基础部分]]></title>
    <url>%2F2016%2F06%2F10%2FJavaScript%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[基本概念javascript是一门解释型的语言，浏览器充当解释器。js执行时，在同一个作用域内是先解释再执行。解释的时候会编译function和var这两个关键词定义的变量，编译完成后从上往下执行并向变量赋值。 区分大小写ECMASCript中的一切（包括变量，函数名和操作符）都区分大小写。 一、变量变量在第一次用到时就设置于内存中，便于后来在脚本中引用。使用变量之前先进行声明。可以使用 var 关键字来进行变量声明。 var count, amount, level; // 用单个 var 关键字声明的多个声明。 变量命名变量名包括全局变量，局部变量，类变量，函数参数等等，他们都属于这一类。 变量命名都以类型前缀+有意义的单词组成，用驼峰式命名法增加变量和函式的可读性。例如：sUserName，nCount。 前缀规范 每个局部变量都需要有一个类型前缀，按照类型可以分为： 12345678s：表示字符串。例如：sName，sHtml；n：表示数字。例如：nPage，nTotal；b：表示逻辑。例如：bChecked，bHasLogin；a：表示数组。例如：aList，aGroup；r：表示正则表达式。例如：rDomain，rEmail；f：表示函数。例如：fGetHtml，fInit；o：表示以上未涉及到的其他对象，例如：oButton，oDate；g：表示全局变量，例如：gUserName，gLoginTime； JavaScript 是一种区分大小写的语言。创建合法的变量名称应遵循如下规则： 1234注意第一个字符不能是数字。后面可以跟任意字母或数字以及下划线，但不能是空格变量名称一定不能是 保留字。 JavaScript是一种弱类型语言，JavaScript 会忽略多余的空格。您可以向脚本添加空格，来提高其可读性。 var是javascript的保留字，表明接下来是变量说明，变量名是用户自定义的标识符，变量之间用逗号分开。 如果声明了一个变量但没有对其赋值，该变量存在，其值为 undefined。 强制类型转换在 JavaScript中，可以对不同类型的值执行运算，不必担心 JavaScript 解释器产生异常。相反 JavaScript 解释器自动将数据类型之一改变（强制转换）为另一种数据类型，然后执行运算。例如： 12345运算 结果数值与字符串相加 将数值强制转换为字符串。布尔值与字符串相加 将布尔值强制转换为字符串。数值与布尔值相加 将布尔值强制转换为数值。 要想显式地将字符串转换为整数，使用 parseInt 方法。要想显式地将字符串转换为数字，使用parseFloat 方法。 JavaScript 变量的生存期：当你在函数内声明了一个变量后，就只能在该函数中访问该变量。当退出该函数后，这个变量会被撤销。这种变量称为本地变量。你可以在不同的函数中使用名称相同的本地变量，这是因为只有声明过变量的函数能够识别其中的每个变量。 如果你在函数之外声明了一个变量，则页面上的所有函数都可以访问该变量。这些变量的生存期从声明它们之后开始，在页面关闭时结束。 JavaScript变量思维导图 二、JavaScript的数据类型JavaScript有三种主要数据类型、两种复合数据类型和两种特殊数据类型。 主要（基本）数据类型123String //字符串Number //数值Boolean //布尔 复合（引用）数据类型12Object //对象Array //数组 特殊数据类型12NullUndefined 字符串数据类型：字符串数据类型用来表示JavaScript 中的文本。在JS中，虽然双引号（””）和单引号(‘’)均可表示字符串，而且它们几乎没有任何区别。但只使用双引号(“”)来表示字符串被认为是最佳的。 一个字符串值是排在一起的一串零或零以上的Unicode 字符（字母、数字和标点符号）。 什么是Unicode？Unicode为每个字符都提供了唯一的数值，不管是什么平台、什么程序或什么语言。开发Unicode是为了给处理世界上存在的所有字符提供统一的编码。 数值数据类型我们需要明白一点，JavaScript内部将所有的数值表示为浮点值，因此，在JavaScript中整数和浮点值没有差别。 Boolean数据类型布尔（逻辑）只能有两个值：true或 false。 特殊数据类型Null数据类型：可以通过给一个变量赋null值来清除变量的内容。 JavaScript中 typeof 运算符将报告null 值为 Object类型，而非类型 null。 null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。 Undefined数据类型：如下情况将返回undefined值：121.对象属性不存在。2.声明了变量但从未赋值。 Null和Undefined的区别：null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。 当声明的变量还未被初始化时，变量的默认值为undefined。 null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。 undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是： 12345678910（1）变量被声明了，但没有赋值时，就等于undefined。（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。（3）对象没有赋值的属性，该属性的值为undefined。（4）函数没有返回值时，默认返回undefined。 null表示”没有对象”，即该处不应该有值。典型用法是： 123（1） 作为函数的参数，表示该函数的参数不是对象。（2） 作为对象原型链的终点。 123alert(typeof undefined); //output "undefined" alert(typeof null); //output "object" alert(null == undefined); //output "true" ECMAScript认为undefined是从null派生出来的，所以把它们定义为相等的。 12alert(null === undefined); //output "false" alert(typeof null == typeof undefined); //output "false" null与undefined的类型是不一样的，所以输出”false”。而 === 代表绝对等于，在这里null===undefined输出false 引用数据类型（对象、数组、函数）JavaScript引用数据类型是保存在堆内存中的对象，JavaScript不允许直接访问堆内存空间中的位置和操作堆内存空间，只能通过操作对象在栈内存中的引用地址。所以引用类型的数据，在栈内存中保存的实际上是对象在堆内存中的引用地址。通过这个引用地址可以快速查找到保存在堆内存中的对象。1234var a=&#123;age:20&#125;;var b=a;b.age=21;console.log(a.age);//21 下面我们来演示这个引用数据类型赋值过程： 自然，给obj2添加name属性，实际上是给堆内存中的对象添加了name属性，obj2和obj1在栈内存中保存的只是堆内存对象的引用地址，虽然也是拷贝了一份，但指向的对象却是同一个。故而改变obj2引起了obj1的改变。 基本类型值指的是那些保存在栈内存中的简单数据段，即这种值完全保存在内存中的一个位置。例如：undefined、null、string、number、Boolean 引用类型值则是指那些保存在堆内存中的对象，即变量中保存的实际上只是一个指针，这个指针指向内存中的另一个位置，该位置保存对象。例如：对象、数组、函数。 简而言之，堆内存存放引用值，栈内存存放固定类型值。 在ECMAScript中，变量可以存在两种类型的值，即原始值和引用值。 原始值存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。引用值存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存处。 123456&lt;script type="text/javascript”&gt;var box = new Object(); //创建一个引用类型var box = "Beme"; //基本类型值是字符串，覆盖了前面的引用类型box.age = 21; //基本类型值添加属性很怪异，因为只有对象才可以添加属性。alert(box.age); //undefined。不是引用类型，无法输出。&lt;/script&gt; JavaScript的运算符优先级：指运算符的运算顺序，通俗的说就是先计算哪一部分。 结合性：同一优先级运算符的计算顺序，通俗的说就是从哪个方向算起，是左到右还是右到左。 数据类型转换String() 转换为字符串类型 Number()转换为数字类型 Boolean()转换为布尔类型 parseInt()：将字符串转换为整数。从字符串的开头开始解析，在第一个非整数的位置停止解析，并返回前面读到所有的整数。如果字符串不是以整数开头的，将返回NaN。如：parseInt（“150 hi”）返回的值是：150，parseInt(&quot;hi&quot;)返回的值是：NaN。 parseFloat()：将字符串转换为浮点数。从字符串的开头开始解析，在第一个非整数的位置停止解析，并返回前面读到所有的整数。如果字符串不是以整数开头的，将返回NaN。如：parseFloat(&quot;15.5hi&quot;)返回的值是：15.5，parseFloat(&quot;hi15.5&quot;)返回的值是：NaN。 eval()：将字符串作为JavaScript表达式进行计算，并返回执行结果，如果没有结果则返回undefined如：eval(&quot;2+2&quot;)返回的值是4。 基本包装类型每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而能调用一些方法来操作这些数据。基本包装类型包括Boolean、Number和String。123456789101112var box = 'syzq'; //字面量box.name = 'mike'; //无效属性box.age = function () &#123; //无效方法 return 21;&#125;; //new运算符写法var box = new String('syzq');//new 运算符box.name = 'mike'; //有效属性box.age = function () &#123; //有效方法 return 21;&#125;; String类型包含了三个属性和大量的可用内置方法：1234属性 描述length : 返回字符串的字符长度Constructor : 返回创建String对象的函数prototype : 通过添加属性和方法扩展字符串定义 JavaScript流程控制对于js流程控制语句，这里只讲几个比较难懂的。其他不赘述。 for...in 语句对应于一个对象的每个，或一个数组的每个元素，执行一个或多个语句。1234for (变量 in 对象)&#123; 在此执行代码&#125; 函数函数是由事件驱动的或者当它被调用时执行的可重复使用的代码块。 JavaScript 支持两种函数：一类是语言内部的函数，另一类是自己创建的。 JavaScript 函数允许没有参数（但包含参数的小括号不能省略），也可以向函数传递参数供函数使用。 对象的组成12方法——函数：过程、动态的属性——变量：状态、静态的]]></content>
      <categories>
        <category>JavaScript学习总结</category>
      </categories>
      <tags>
        <tag>JavaScript基础</tag>
        <tag>数组和对象</tag>
        <tag>函数</tag>
        <tag>JS数据类型</tag>
      </tags>
  </entry>
</search>
